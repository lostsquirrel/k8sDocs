<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes – Tasks</title>
    <link>https://lostsquirrel.github.io/k8sDocs/tasks/</link>
    <description>Recent content in Tasks on Kubernetes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://lostsquirrel.github.io/k8sDocs/tasks/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Tasks: 下载安装配置 kubectl</title>
      <link>https://lostsquirrel.github.io/k8sDocs/tasks/tools/00-install-kubectl/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lostsquirrel.github.io/k8sDocs/tasks/tools/00-install-kubectl/</guid>
      <description>
        
        
        &lt;p&gt;kubectl 是 k8s 的命令行工具，用于通过命令管理k8s集群。 kubectl 可以用于部署应用，查看和管理集群资源，查看日志，具体使用明细请见 &lt;a href=&#34;https://kubernetes.io/docs/reference/kubectl/overview/&#34;&gt;源地址&lt;/a&gt; &lt;a href=&#34;../reference/07-kubectl/00-overview.md&#34;&gt;本站地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;准备&#34;&gt;准备&lt;/h2&gt;
&lt;p&gt;kubectl 版本与 k8s 集群必须只能有一个小版本的差异，比如 kubectl 是 v1.2, 只能用于 k8s 集群 master 节点版本为 v1.1 或 v1.3. 使用最新版的 kubectl 可以避免一些神奇的问题&lt;/p&gt;
&lt;h2 id=&#34;linuxubuntu-2004下安装&#34;&gt;Linux(Ubuntu 20.04)下安装&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;下载&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;下载最新版本&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;curl -LO https://storage.googleapis.com/kubernetes-release/release/&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;/bin/linux/amd64/kubectl
wget https://shangao.tech/kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;下载指定版本(例如: v1.18.0)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.18.0/bin/linux/amd64/kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;添加执行权限&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;chmod +x ./kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;移动到PATH&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;sudo mv ./kubectl /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;查看安装的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl version --client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;snap-安装&#34;&gt;snap 安装&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;snap install kubectl --classic

kubectl version --client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;验证配置&#34;&gt;验证配置&lt;/h2&gt;
&lt;p&gt;kubectl 与 k8s集群通信时需要一个配置文件以存放集群相关信息，这个文件一般在集群创建时会自动生成。默认情况下位于以下路径&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt; ~/.kube/config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过以下命令查看集群状态以确定配置信息正确&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl cluster-info
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果出现类似如下信息，则表示成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Kubernetes master is running at http://localhost:8080
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果出现如下类似信秘，则表示配置不正常, 执行 &lt;code&gt;kubectl cluster-info dump&lt;/code&gt; 查看明细原因&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The connection to the server &amp;lt;server-name:port&amp;gt; was refused - did you specify the right host or port?
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;可选配置&#34;&gt;可选配置&lt;/h2&gt;
&lt;p&gt;开启自动补全&lt;/p&gt;
&lt;h3 id=&#34;bash-下开启&#34;&gt;Bash 下开启&lt;/h3&gt;
&lt;h4 id=&#34;说明&#34;&gt;说明&lt;/h4&gt;
&lt;p&gt;kubectl 自动被全脚本可以通过 &lt;code&gt;kubectl completion bash&lt;/code&gt; 生成，此脚本信赖 &lt;a href=&#34;https://github.com/scop/bash-completion&#34;&gt;bash-completion&lt;/a&gt;，需要执行命令 &lt;code&gt;type _init_completion&lt;/code&gt; 确定已经安装。&lt;/p&gt;
&lt;h4 id=&#34;安装-bash-completion&#34;&gt;安装 &lt;code&gt;bash-completion&lt;/code&gt;&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;apt-get install bash-completion
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;加载 &lt;code&gt;bash-completion&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;source /usr/share/bash-completion/bash_completion
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;开启补全&#34;&gt;开启补全&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;为当前用户开启&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;source &amp;lt;(kubectl completion bash)&amp;#39;&lt;/span&gt; &amp;gt;&amp;gt;~/.bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;为所有用户开启&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl completion bash &amp;gt;/etc/bash_completion.d/kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果为 kubectl 添加了别名需要如下配置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;alias k=kubectl&amp;#39;&lt;/span&gt; &amp;gt;&amp;gt;~/.bashrc
echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;complete -F __start_kubectl k&amp;#39;&lt;/span&gt; &amp;gt;&amp;gt;~/.bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Tasks: 安装 Minikube</title>
      <link>https://lostsquirrel.github.io/k8sDocs/tasks/tools/01-install-minikube/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lostsquirrel.github.io/k8sDocs/tasks/tools/01-install-minikube/</guid>
      <description>
        
        
        &lt;p&gt;本文介结 Minikube 安装， Minikube 是一个创建运行在虚拟机的的本地单节点 k8s 集群的工具&lt;/p&gt;
&lt;h2 id=&#34;环境准备&#34;&gt;环境准备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;检查本机虚拟化支持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;grep -E --color &#39;vmx|svm&#39; /proc/cpuinfo&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装 虚拟机管理程序(以下选择一个)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.virtualbox.org/wiki/Downloads&#34;&gt;VirtualBox&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.linux-kvm.org/&#34;&gt;KVM&lt;/a&gt; 和 &lt;a href=&#34;https://www.qemu.org/&#34;&gt;QEMU&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;minikube 也支持配置 &lt;code&gt;--driver=none&lt;/code&gt; 方式，此时 k8s 组件就不会运行在虚拟机中，而是直接运行在当前机器上(这种情况就不需要安装虚拟机)。 使用这种方式需要安装 Docker
如果确定使用 &lt;code&gt;--driver=none&lt;/code&gt;，则k8s组件运行在主机上，只需要安装 Docker 环境，
如果在 Debain 系操作系统安装，需要以 &lt;code&gt;.deb&lt;/code&gt; 方式安装，而不是 &lt;code&gt;snap&lt;/code&gt; 安装， &lt;a href=&#34;https://www.docker.com/products/docker-desktop&#34;&gt;Docker 下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意: &lt;code&gt;--driver=none&lt;/code&gt; 有安全问题和数据丢失的风险， 更多相关信自请参见&lt;a href=&#34;https://minikube.sigs.k8s.io/docs/reference/drivers/none/&#34;&gt;这一篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;minikube 还支持 &lt;code&gt;vm-driver=podman&lt;/code&gt;， 与 Docker 驱动类似。 Podman 需要以超级管理员权限运行以保证容器有权限访问系统上的任意可用资源。&lt;/p&gt;
&lt;h2 id=&#34;linux-安装-minikube&#34;&gt;Linux 安装 minikube&lt;/h2&gt;
&lt;h3 id=&#34;安装-kubectl&#34;&gt;安装 kubectl&lt;/h3&gt;
&lt;p&gt;详见 &lt;a href=&#34;&#34;&gt;kubectl 安装配置&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;通过包管理器安装-minikube&#34;&gt;通过包管理器安装 minikube&lt;/h3&gt;
&lt;p&gt;Github库发行(&lt;a href=&#34;https://github.com/kubernetes/minikube/releases&#34;&gt;https://github.com/kubernetes/minikube/releases&lt;/a&gt;) 有不同操作系统对应包提供下载。可前端下载并安装&lt;/p&gt;
&lt;h3 id=&#34;直接下载二进制文件&#34;&gt;直接下载二进制文件&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; chmod +x minikube
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;添加到一个 PATH 目录&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;sudo mkdir -p /usr/local/bin/
sudo install minikube /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;确认正确安装&#34;&gt;确认正确安装&lt;/h2&gt;
&lt;p&gt;可以通过以下命令启动集群&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;minikube start --driver&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;lt;driver_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;driver_name&lt;/code&gt; 具体请见&lt;a href=&#34;https://kubernetes.io/docs/setup/learning-environment/minikube/#specifying-the-vm-driver&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意: 当使用 KVM 时需要注意，在 Debian 等一些操作系统下 libvirt 默认 QEMU URI 是 &lt;code&gt;qemu:///session&lt;/code&gt;， 而 minikube 默认的 QEMU URI 是 &lt;code&gt;qemu:///system&lt;/code&gt;。 如果你的系统有此问题需要为 &lt;code&gt;minikube start&lt;/code&gt; 添加参数 &lt;code&gt;--kvm-qemu-uri qemu:///session&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当 minikube 启动完成后，通过以下命令查看集群状态&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;minikube status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果命令返回结果类似如下，则表示成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要停止集群则执行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;minikube stop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果在执行 &lt;code&gt;minikube start&lt;/code&gt; 返回如下错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;machine does not exist
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;则需要要清除本地状态，再继续&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;minikube delete
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Tasks: 存活(liveness), 就绪(readiness), 启动(startup)探针配置</title>
      <link>https://lostsquirrel.github.io/k8sDocs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</link>
      <pubDate>Fri, 22 May 2020 10:52:35 +0800</pubDate>
      
      <guid>https://lostsquirrel.github.io/k8sDocs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</guid>
      <description>
        
        
        &lt;p&gt;本文介结怎么配置容器的 存活, 就绪, 启动探针配置&lt;/p&gt;
&lt;p&gt;kubelet 通过存活探针的结果来决定何时应该重启容器。例如，可以发现一个应用在运行但不能继续干活比如发生死锁，在这种情况下，如果不是有bug 那重启便可以使应用恢复，以提高应用的可用性。&lt;/p&gt;
&lt;p&gt;kubelet 通过就绪探针的结果来决定何时容器可以提供服务。当一个Pod所有的容器都就绪后才认为其就绪。就绪探针的一个应用场景为Pod 作为 Service 后台时，当 Pod 不是就绪状态时，会从 Service 的负载均衡列表中移除&lt;/p&gt;
&lt;p&gt;kubelet 通过启动探针的结果为确定应用容器的否启动。当配置启动探针时， 存活探针和就绪探针会在启动探针成功后才开始工作。以保证这些探针不会影响应用正常启动。特别针对启动较慢的应用，防止其在启动之前因为存活探针导致重启&lt;/p&gt;
&lt;h2 id=&#34;基于命令的存活探针实验一&#34;&gt;基于命令的存活探针[实验一]&lt;/h2&gt;
&lt;p&gt;大多数应用长时间运行后最终都会因各种原因而挂掉，不得不重启。k8s 提供存活探针来发现和补救这个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实验镜像 &lt;code&gt;k8s.gcr.io/busybox&lt;/code&gt; (可以是其它任意常见基础镜像)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实验配置(&lt;code&gt;exec-liveness.yaml&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Pod&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;test&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness-exec&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:
  - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;busybox&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;args&lt;/span&gt;:
    - &lt;span style=&#34;color:#ae81ff&#34;&gt;/bin/sh&lt;/span&gt;
    - -&lt;span style=&#34;color:#ae81ff&#34;&gt;c&lt;/span&gt;
    - &lt;span style=&#34;color:#ae81ff&#34;&gt;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;livenessProbe&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;exec&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;command&lt;/span&gt;:
        - &lt;span style=&#34;color:#ae81ff&#34;&gt;cat&lt;/span&gt;
        - &lt;span style=&#34;color:#ae81ff&#34;&gt;/tmp/healthy&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;initialDelaySeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;periodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;配置说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;periodSeconds&lt;/code&gt; kubelet 会每5秒执行一次存活探针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initialDelaySeconds&lt;/code&gt; kubelet 应该在容器启动5秒后，执行第一次存活探针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat /tmp/healthy&lt;/code&gt; kubelet 在目标容器中执行该命令作为探针，如果命令成功返回0，则认为容器存活，否则 kubelet 认为容器已经不能正常工作，会杀死并重启该容器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/bin/sh -c &amp;quot;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&amp;quot;&lt;/code&gt; 容器启动30秒内，&lt;code&gt;cat /tmp/healthy&lt;/code&gt; 返回成功， 之后 &lt;code&gt;cat /tmp/healthy&lt;/code&gt; 返回失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;操作步骤&#34;&gt;操作步骤&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;开启容器&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl apply -f exec-liveness.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;查看容器状态&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl get pod liveness-exec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看当前的重启次数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl describe pod liveness-exec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;30 秒内结果类似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FirstSeen    LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
24s       24s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &amp;quot;k8s.gcr.io/busybox&amp;quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &amp;quot;k8s.gcr.io/busybox&amp;quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;30 秒后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
37s       37s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &amp;quot;k8s.gcr.io/busybox&amp;quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &amp;quot;k8s.gcr.io/busybox&amp;quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
2s        2s      1   {kubelet worker0}   spec.containers{liveness}   Warning     Unhealthy   Liveness probe failed: cat: can&#39;t open &#39;/tmp/healthy&#39;: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再过 30 秒&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;kubectl get pod liveness-exec&lt;/code&gt;， 输出类似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NAME            READY     STATUS    RESTARTS   AGE
liveness-exec   1/1       Running   1          1m
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意查看重启次数的增加&lt;/p&gt;
&lt;h2 id=&#34;基于http请求的存活探针实验二&#34;&gt;基于HTTP请求的存活探针[实验二]&lt;/h2&gt;
&lt;p&gt;另一种存活探针基于 HTTP GET 请求来实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实验镜像 &lt;code&gt;k8s.gcr.io/liveness&lt;/code&gt;(墙内请用 &lt;code&gt;registry.cn-hangzhou.aliyuncs.com/lisong/liveness&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实验配置(&lt;code&gt;http-liveness.yaml&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Pod&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;test&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness-http&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:
  - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;k8s.gcr.io/liveness&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;args&lt;/span&gt;:
    - &lt;span style=&#34;color:#ae81ff&#34;&gt;/server&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;livenessProbe&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;httpGet&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/healthz&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;
        &lt;span style=&#34;color:#f92672&#34;&gt;httpHeaders&lt;/span&gt;:
        - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Custom-Header&lt;/span&gt;
          &lt;span style=&#34;color:#f92672&#34;&gt;value&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Awesome&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;initialDelaySeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;periodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;配置说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;periodSeconds&lt;/code&gt; kubelet 会每3秒执行一次存活探针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;initialDelaySeconds&lt;/code&gt; kubelet 应该在容器启动3秒后，执行第一次存活探针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;port: 8080&lt;/code&gt; kubelet HTTP请求目标端口为 &lt;code&gt;8080&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path: /healthz&lt;/code&gt; kubelet HTTP请求目标路径为 &lt;code&gt;8080&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;kubelet 基于HTTP响应码作为探测依据，若响应码 大于等于&lt;code&gt;200&lt;/code&gt;且小于&lt;code&gt;400&lt;/code&gt;认为成功，其它失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实验容器关键代码(&lt;code&gt;server.go&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/healthz&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;duration&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Now&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;Sub&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;started&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;duration&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Seconds&lt;/span&gt;() &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WriteHeader&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;)
        &lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Write&lt;/span&gt;([]byte(&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sprintf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;error: %v&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;duration&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Seconds&lt;/span&gt;())))
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WriteHeader&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;)
        &lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Write&lt;/span&gt;([]byte(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ok&amp;#34;&lt;/span&gt;))
    }
})

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码说明，在容器开启后 &lt;code&gt;10&lt;/code&gt;秒内返回响应码 &lt;code&gt;200&lt;/code&gt;(成功)，之后返回响应码 &lt;code&gt;500&lt;/code&gt;(错误)&lt;/p&gt;
&lt;h3 id=&#34;操作步骤-1&#34;&gt;操作步骤&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;开启&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl apply -f http-liveness.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;查看容器状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开启后马上查看重启次数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl get pod liveness-http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在开启 10秒内查看容器信息&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl describe pod liveness-http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在开启 10秒后再次查看容器信息&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl describe pod liveness-http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在开启 10秒后再次查看容器重启次数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl get pod liveness-http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;基于-tcp-的存活探针和就绪探针实验三&#34;&gt;基于 TCP 的存活探针和就绪探针[实验三]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实验镜像 &lt;code&gt;k8s.gcr.io/goproxy:0.1&lt;/code&gt; (墙内请用 &lt;code&gt;registry.cn-hangzhou.aliyuncs.com/lisong/goproxy:0.1&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实验配置(&lt;code&gt;tcp-liveness-readiness.yaml&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Pod&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;goproxy&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;labels&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;app&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;goproxy&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;spec&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;containers&lt;/span&gt;:
  - &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;goproxy&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;image&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;k8s.gcr.io/goproxy:0.1&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;ports&lt;/span&gt;:
    - &lt;span style=&#34;color:#f92672&#34;&gt;containerPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;readinessProbe&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;tcpSocket&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;initialDelaySeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;periodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;livenessProbe&lt;/span&gt;:
      &lt;span style=&#34;color:#f92672&#34;&gt;tcpSocket&lt;/span&gt;:
        &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;initialDelaySeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;
      &lt;span style=&#34;color:#f92672&#34;&gt;periodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;配置说明&lt;/p&gt;
&lt;p&gt;由配置可见TCP探针与HTTP探针类似，且本练习中同时配置了存活探针和就绪探针。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;readinessProbe.initialDelaySeconds&lt;/code&gt; 就绪探针于容器开启5秒后开始执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readinessProbe.periodSeconds&lt;/code&gt; 就绪探针每10秒执行一次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;livenessProbe.initialDelaySeconds&lt;/code&gt; kubelet 应该在容器启动15秒后，执行第一次存活探针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;livenessProbe.periodSeconds&lt;/code&gt; kubelet 会每20秒执行一次存活探针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;操作步骤-2&#34;&gt;操作步骤&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;开启&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl apply -f tcp-liveness-readiness.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开启 15秒后，查看状态&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;kubectl describe pod goproxy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;在探针中使用命名端口&#34;&gt;在探针中使用命名端口&lt;/h2&gt;
&lt;p&gt;命令端口可用于 HTTP和TCP 配置存活探针&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;ports&lt;/span&gt;:
- &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness-port&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;containerPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;hostPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;livenessProbe&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;httpGet&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/healthz&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness-port&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;通过启动探针来保护启动时间长的容器&#34;&gt;通过启动探针来保护启动时间长的容器&lt;/h2&gt;
&lt;p&gt;有时为解决传统项目在启动时可能需要额外的初始化需要花费较长时间，此时可以配置与存活探针相同命令的启动探针，示例配置如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;ports&lt;/span&gt;:
- &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness-port&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;containerPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;hostPort&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;livenessProbe&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;httpGet&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/healthz&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness-port&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;failureThreshold&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;periodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;startupProbe&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;httpGet&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;path&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;/healthz&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;port&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;liveness-port&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;failureThreshold&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;periodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;startupProbe.failureThreshold&lt;/code&gt; 启动探针的尝试次数，这里是 30&lt;/li&gt;
&lt;li&gt;&lt;code&gt;startupProbe.periodSeconds&lt;/code&gt; 启动探针每次尝试间隔时间，这里是 10&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此 应用可以有 &lt;code&gt;failureThreshold * periodSeconds&lt;/code&gt; (30 * 10 = 300s)， 即5分针的时间来完成启动，在这个过程中如果启动探针成功一次，则不再继续，转而由存活探针开始工作，如果启动探针最终没有一次成功，则根据容器的重启策略(&lt;code&gt;restartPolicy&lt;/code&gt;)来决定下一步动作&lt;/p&gt;
&lt;h2 id=&#34;定义就绪探针&#34;&gt;定义就绪探针&lt;/h2&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;应用在启动是需要加载大量数据或配置文件&lt;/li&gt;
&lt;li&gt;应用需要信赖外部服务先启动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上场景应用暂时不能提供服务，但并不需要重启，而又不想转发流量到这个应用
注意: 就绪探针在应用整个生命周期都在运行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;readinessProbe&lt;/span&gt;:
  &lt;span style=&#34;color:#f92672&#34;&gt;exec&lt;/span&gt;:
    &lt;span style=&#34;color:#f92672&#34;&gt;command&lt;/span&gt;:
    - &lt;span style=&#34;color:#ae81ff&#34;&gt;cat&lt;/span&gt;
    - &lt;span style=&#34;color:#ae81ff&#34;&gt;/tmp/healthy&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;initialDelaySeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;periodSeconds&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就绪探针与存活探针配置类似
就绪探针与存活搾在同一个容器中，可以并行执行。同时使用它们能保证流量不会到未准备好的容器上，容器挂掉是能重启&lt;/p&gt;
&lt;h2 id=&#34;探针配置&#34;&gt;探针配置&lt;/h2&gt;
&lt;h3 id=&#34;探针有如下配置项以便能更精确的控制检测方式&#34;&gt;探针有如下配置项，以便能更精确的控制检测方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;initialDelaySeconds&lt;/code&gt; 容器开启后多少秒，存活/就绪探针开始工作。默认 &lt;code&gt;0&lt;/code&gt; 最小 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;periodSeconds&lt;/code&gt; 探针每次执行的时间间隔，单位秒， 默认 &lt;code&gt;10&lt;/code&gt;， 最小 &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timeoutSeconds&lt;/code&gt; 探针检测超时时间，单位秒，默认 1， 最小 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;successThreshold&lt;/code&gt; 在失败后，连续多少次成功决定状态为成功， 默认 1， 存活探针必须为 1 ， 最小值 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;failureThreshold&lt;/code&gt; 放弃尝试前的失败次数， 存活探针失败则重启容器。 就绪探针则标记容器为未就绪， 默认 3， 最小 1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http-类探针额外配置项&#34;&gt;HTTP 类探针额外配置项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;host&lt;/code&gt; 请求主机名， 默认为 pod IP, 可以 &lt;code&gt;httpHeaders&lt;/code&gt; 设置 &lt;code&gt;Host&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scheme&lt;/code&gt; 请求协议 (HTTP / HTTPS) 默认 HTTP&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt; 请求路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;httpHeaders&lt;/code&gt; 请求头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;port&lt;/code&gt; 请求端口号或命令端口名称 端口号范围 &lt;code&gt;1 - 65535&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果协议为 https 请求不会验证证书，大多数场景不需要配置 &lt;code&gt;host&lt;/code&gt; 字段。吸的地 应用监听地址为 &lt;code&gt;127.0.0.1&lt;/code&gt; Pod 使用 &lt;code&gt;hostNetwork&lt;/code&gt;, 如果Pod 信赖虚拟主机(比较常见)，此时不应该配置 &lt;code&gt;host&lt;/code&gt; 字段，而通过 &lt;code&gt;httpHeaders&lt;/code&gt; 设置 &lt;code&gt;Host&lt;/code&gt;
如果是 TCP 探针，k8s通过 &lt;code&gt;node&lt;/code&gt; 来连接，因此不能使用 sevice name 作为 &lt;code&gt;host&lt;/code&gt; 字段的值&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;探针类型&lt;/th&gt;
&lt;th&gt;探针目的&lt;/th&gt;
&lt;th&gt;探测成功作用&lt;/th&gt;
&lt;th&gt;探测失败作用&lt;/th&gt;
&lt;th&gt;生命周期&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;启动&lt;/td&gt;
&lt;td&gt;保障启动过程中不被存活探针重启&lt;/td&gt;
&lt;td&gt;表示容器启动成功，并停止运行&lt;/td&gt;
&lt;td&gt;在达到 &lt;code&gt;failureThreshold&lt;/code&gt;之前，无操作，达到后由重启策略决定&lt;/td&gt;
&lt;td&gt;成功后结束或尝试直至达到 &lt;code&gt;failureThreshold&lt;/code&gt; 配置的次数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;就绪&lt;/td&gt;
&lt;td&gt;保证容器能提供服务才引入流量&lt;/td&gt;
&lt;td&gt;标记容器就绪，service 可以分配流量&lt;/td&gt;
&lt;td&gt;标记容器未就绪，service 不能引入流量&lt;/td&gt;
&lt;td&gt;容器整个生命&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;存活&lt;/td&gt;
&lt;td&gt;让容器不能提供服务时重启&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;td&gt;达到 &lt;code&gt;failureThreshold&lt;/code&gt; 配置次数后重启容器&lt;/td&gt;
&lt;td&gt;容器整个生命&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
  </channel>
</rss>
