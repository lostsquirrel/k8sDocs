<!DOCTYPE html>
<html lang="zh-cn">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>网络策略 - Kubernetes</title>
<meta name="description" content="生产级别的容器编排系统">
<meta name="generator" content="Hugo 0.68.3" />
<link href="https://lostsquirrel.github.io/k8sDocsindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/network-policies/">
<link rel="stylesheet" href="https://lostsquirrel.github.io/k8sDocs/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://lostsquirrel.github.io/k8sDocs/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="https://lostsquirrel.github.io/k8sDocs/js/bundle.js"></script><style>
:root {}
</style>
<meta property="og:title" content="网络策略" />
<meta property="og:description" content="podPod 表示集群中运行的一组容器的集合 is allowed to communicate with various network &#34;entities&#34; (we use the word &#34;entity&#34; here to avoid overloading the more common terms such as &#34;endpoints&#34; and &#34;services&#34;, which have specific Kubernetes connotations) over the network. The entities that a Pod can communicate with are identified through a combination of the following 3 identifiers: 1. Other" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/network-policies/" />
<meta property="article:published_time" content="2020-10-09T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-09-23T00:00:00+00:00" /><meta property="og:site_name" content="Kubernetes" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="网络策略"/>
<meta name="twitter:description" content="podPod 表示集群中运行的一组容器的集合 is allowed to communicate with various network &#34;entities&#34; (we use the word &#34;entity&#34; here to avoid overloading the more common terms such as &#34;endpoints&#34; and &#34;services&#34;, which have specific Kubernetes connotations) over the network. The entities that a Pod can communicate with are identified through a combination of the following 3 identifiers: 1. Other"/>
<meta itemprop="name" content="网络策略">
<meta itemprop="description" content="podPod 表示集群中运行的一组容器的集合 is allowed to communicate with various network &#34;entities&#34; (we use the word &#34;entity&#34; here to avoid overloading the more common terms such as &#34;endpoints&#34; and &#34;services&#34;, which have specific Kubernetes connotations) over the network. The entities that a Pod can communicate with are identified through a combination of the following 3 identifiers: 1. Other">
<meta itemprop="datePublished" content="2020-10-09T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-09-23T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="4613">



<meta itemprop="keywords" content="" />
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?46e26ffc9d975f663dff0b89f1cf7931";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>




<link rel="stylesheet" href=/k8sDocs/css/base_fonts.css>

<link rel="stylesheet" href="/k8sDocs/css/jquery-ui.min.css">
<link rel="stylesheet" href="/k8sDocs/css/callouts.css">
<link rel="stylesheet" href="/k8sDocs/css/custom.css">
<link rel="stylesheet" href="/k8sDocs/css/custom-jekyll/tags.css">

</head>
<body><div class="container"><header>
<h1>Kubernetes</h1>

 <span class="version">Version v1.19</span>

<p class="description">生产级别的容器编排系统</p>

</header>

<div class="content-container">
<main><h1>网络策略</h1>
<!--
---
reviewers:
- thockin
- caseydavenport
- danwinship
title: Network Policies
content_type: concept
weight: 50
---
 -->
<!-- overview -->
<!--
If you want to control traffic flow at the IP address or port level (OSI layer 3 or 4), then you might consider using Kubernetes NetworkPolicies for particular applications in your cluster.  NetworkPolicies are an application-centric construct which allow you to specify how a <a class='glossary-tooltip' href='/k8sDocs/concepts/workloads/pods/' target='_blank'>pod<span class='tooltip-text'>Pod 表示集群中运行的一组容器的集合</span>
</a> is allowed to communicate with various network "entities" (we use the word "entity" here to avoid overloading the more common terms such as "endpoints" and "services", which have specific Kubernetes connotations) over the network.

The entities that a Pod can communicate with are identified through a combination of the following 3 identifiers:

1. Other pods that are allowed (exception: a pod cannot block access to itself)
2. Namespaces that are allowed
3. IP blocks (exception: traffic to and from the node where a Pod is running is always allowed, regardless of the IP address of the Pod or the node)

When defining a pod- or namespace- based NetworkPolicy, you use a <a class='glossary-tooltip' href='/k8sDocs/concepts/overview/working-with-objects/labels/' target='_blank'>selector<span class='tooltip-text'>允许用户基于标签过滤资源列表</span>
</a> to specify what traffic is allowed to and from the Pod(s) that match the selector.

Meanwhile, when IP based NetworkPolicies are created, we define policies based on IP blocks (CIDR ranges).
 -->
<p>如果想要在 IP 地址或端口层(OSI 3 或 4 层)控制网络流量，可以考虑对集群中的特定应用使用 k8s 网络策略。
网络策略是一个应用为中心的构造，它允许用户指定怎么控制一个 <a class='glossary-tooltip' href='/k8sDocs/concepts/workloads/pods/' target='_blank'>pod<span class='tooltip-text'>Pod 表示集群中运行的一组容器的集合</span>
</a> 以允许它与其它多种网络实体(这里使用 实体(entity)避免与 &ldquo;Endpoint&rdquo; &ldquo;Service&rdquo;
这此在 k8s 中有明确含义的词混淆)通信。</p>
<p>Pod 可以与之通信的实体可以由以下三个标识组合来识别:</p>
<ol>
<li>其它被允许的 Pod (例外: Pod 不可以禁止与它本身通信)</li>
<li>被允许的命名空间</li>
<li>IP 段(例外: Pod 所在的节点进出流量都是允许的，Pod 和 节点的 IP 如果在禁用段则会被忽略)</li>
</ol>
<p>在定义一个基于 Pod 或 命名空间的网络策略时，可以使用<a class='glossary-tooltip' href='/k8sDocs/concepts/overview/working-with-objects/labels/' target='_blank'>选择器<span class='tooltip-text'>允许用户基于标签过滤资源列表</span>
</a>
来指定只与选择器相匹配的 Pod 在允许与之进行流量往来。</p>
<p>同时，当创建基于 IP 的网络策略时，定义的策略基于 IP 段(CIDR 范围)。</p>
<!-- body -->
<!--
## Prerequisites

Network policies are implemented by the [network plugin](/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/). To use network policies, you must be using a networking solution which supports NetworkPolicy. Creating a NetworkPolicy resource without a controller that implements it will have no effect.
-->
<h2 id="前置条件">前置条件</h2>
<p>网络策略是由
<a href="/k8sDocs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">网络插件</a>
实现的。 要使用网络策略，就必要使用一个支持网络策略的网络解决方案。 创建一个没有实现的控制器的
<code>NetworkPolicy</code> 资源是没有效果的</p>
<!--
## Isolated and Non-isolated Pods

By default, pods are non-isolated; they accept traffic from any source.

Pods become isolated by having a NetworkPolicy that selects them. Once there is any NetworkPolicy in a namespace selecting a particular pod, that pod will reject any connections that are not allowed by any NetworkPolicy. (Other pods in the namespace that are not selected by any NetworkPolicy will continue to accept all traffic.)

Network policies do not conflict; they are additive. If any policy or policies select a pod, the pod is restricted to what is allowed by the union of those policies' ingress/egress rules. Thus, order of evaluation does not affect the policy result.
 -->
<h2 id="隔离和非隔离的-pod">隔离和非隔离的 Pod</h2>
<p>默认情况下，所有的 Pod 都是非隔离的; 它们可以接收来自任意源的流量。</p>
<p>当 Pod 被一个 NetworkPolicy 选中时就会变成隔离的。 当在一个命名空间中有任意 NetworkPolicy
选中了某个 Pod， 这个 Pod 就会拒绝那些不被这些 NetworkPolicy 允许的连接就会被拒绝。(同一个
命名空间中其它没有被任何 NetworkPolicy 选择的 Pod 依然继续接收所有流量。)</p>
<p>网络策略不会冲突； 它们可叠加。 如果任意策略选中了一个 Pod， 该 Pod 就会被限制在这些策略的
<code>ingress/egress</code> 规则交集允许的范围。 因此，执行的顺序并不会影响策略的结果。</p>
<!--
## The NetworkPolicy resource {#networkpolicy-resource}

See the [NetworkPolicy](/docs/reference/generated/kubernetes-api/v1.19/#networkpolicy-v1-networking-k8s-io) reference for a full definition of the resource.

An example NetworkPolicy might look like this:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
    - namespaceSelector:
        matchLabels:
          project: myproject
    - podSelector:
        matchLabels:
          role: frontend
    ports:
    - protocol: TCP
      port: 6379
  egress:
  - to:
    - ipBlock:
        cidr: 10.0.0.0/24
    ports:
    - protocol: TCP
      port: 5978
```

<blockquote class="note">
  <div><strong>说明：</strong> POSTing this to the API server for your cluster will have no effect unless your chosen networking solution supports network policy.</div>
</blockquote>


__Mandatory Fields__: As with all other Kubernetes config, a NetworkPolicy
needs `apiVersion`, `kind`, and `metadata` fields.  For general information
about working with config files, see
[Configure Containers Using a ConfigMap](/docs/tasks/configure-pod-container/configure-pod-configmap/),
and [Object Management](/docs/concepts/overview/working-with-objects/object-management).

__spec__: NetworkPolicy [spec](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status) has all the information needed to define a particular network policy in the given namespace.

__podSelector__: Each NetworkPolicy includes a `podSelector` which selects the grouping of pods to which the policy applies. The example policy selects pods with the label "role=db". An empty `podSelector` selects all pods in the namespace.

__policyTypes__: Each NetworkPolicy includes a `policyTypes` list which may include either `Ingress`, `Egress`, or both. The `policyTypes` field indicates whether or not the given policy applies to ingress traffic to selected pod, egress traffic from selected pods, or both. If no `policyTypes` are specified on a NetworkPolicy then by default `Ingress` will always be set and `Egress` will be set if the NetworkPolicy has any egress rules.

__ingress__: Each NetworkPolicy may include a list of allowed `ingress` rules.  Each rule allows traffic which matches both the `from` and `ports` sections. The example policy contains a single rule, which matches traffic on a single port, from one of three sources, the first specified via an `ipBlock`, the second via a `namespaceSelector` and the third via a `podSelector`.

__egress__: Each NetworkPolicy may include a list of allowed `egress` rules.  Each rule allows traffic which matches both the `to` and `ports` sections. The example policy contains a single rule, which matches traffic on a single port to any destination in `10.0.0.0/24`.

So, the example NetworkPolicy:

1. isolates "role=db" pods in the "default" namespace for both ingress and egress traffic (if they weren't already isolated)
2. (Ingress rules) allows connections to all pods in the "default" namespace with the label "role=db" on TCP port 6379 from:

   * any pod in the "default" namespace with the label "role=frontend"
   * any pod in a namespace with the label "project=myproject"
   * IP addresses in the ranges 172.17.0.0–172.17.0.255 and 172.17.2.0–172.17.255.255 (ie, all of 172.17.0.0/16 except 172.17.1.0/24)
3. (Egress rules) allows connections from any pod in the "default" namespace with the label "role=db" to CIDR 10.0.0.0/24 on TCP port 5978

See the [Declare Network Policy](/docs/tasks/administer-cluster/declare-network-policy/) walkthrough for further examples.
-->
<h2 id="networkpolicy-resource">网络策略资源</h2>
<p>可以在 <a href="/docs/reference/generated/kubernetes-api/v1.19/#networkpolicy-v1-networking-k8s-io">NetworkPolicy</a> 查阅详细定义文档.</p>
<p>一个 NetworkPolicy 示例可能长成这个样子:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: test-network-policy
  <span style="color:#66d9ef">namespace</span>: default
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>:
    <span style="color:#66d9ef">matchLabels</span>:
      <span style="color:#66d9ef">role</span>: db
  <span style="color:#66d9ef">policyTypes</span>:
  - Ingress
  - Egress
  <span style="color:#66d9ef">ingress</span>:
  - <span style="color:#66d9ef">from</span>:
    - <span style="color:#66d9ef">ipBlock</span>:
        <span style="color:#66d9ef">cidr</span>: <span style="color:#ae81ff">172.17.0.0</span>/<span style="color:#ae81ff">16</span>
        <span style="color:#66d9ef">except</span>:
        - <span style="color:#ae81ff">172.17.1.0</span>/<span style="color:#ae81ff">24</span>
    - <span style="color:#66d9ef">namespaceSelector</span>:
        <span style="color:#66d9ef">matchLabels</span>:
          <span style="color:#66d9ef">project</span>: myproject
    - <span style="color:#66d9ef">podSelector</span>:
        <span style="color:#66d9ef">matchLabels</span>:
          <span style="color:#66d9ef">role</span>: frontend
    <span style="color:#66d9ef">ports</span>:
    - <span style="color:#66d9ef">protocol</span>: TCP
      <span style="color:#66d9ef">port</span>: <span style="color:#ae81ff">6379</span>
  <span style="color:#66d9ef">egress</span>:
  - <span style="color:#66d9ef">to</span>:
    - <span style="color:#66d9ef">ipBlock</span>:
        <span style="color:#66d9ef">cidr</span>: <span style="color:#ae81ff">10.0.0.0</span>/<span style="color:#ae81ff">24</span>
    <span style="color:#66d9ef">ports</span>:
    - <span style="color:#66d9ef">protocol</span>: TCP
      <span style="color:#66d9ef">port</span>: <span style="color:#ae81ff">5978</span>
</code></pre></div><blockquote class="note">
  <div><strong>说明：</strong> 如果集群的网络解决方案(网络插件)不支持网络策略，POST 这个配置到集群 api-server 将是没有效果的
也就是说要使用网络策略，就必须要安装支持网络策略的网络插件。</div>
</blockquote>

<p><strong>必要字段</strong>: 与其它所有的 k8s 配置一样， NetworkPolicy 必须有 <code>apiVersion</code>, <code>kind</code>, <code>metadata</code>
字段。 配置文件常用信息请见
<a href="/k8sDocs/tasks/configure-pod-container/configure-pod-configmap/">使用 ConfigMap 配置容器</a>,
和 <a href="/k8sDocs/concepts/overview/working-with-objects/object-management">对象管理</a>.</p>
<p><strong>spec</strong>: NetworkPolicy <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status">spec</a> 包含了在指定命名空间创建特定网络策略的所有信息</p>
<p><strong>podSelector</strong>: 每个 NetworkPolicy 都包含了一个 <code>podSelector</code> 字段，用户选择应用该策略的 Pod 组。
上面例子中的策略选择包含 &ldquo;<code>role=db</code>&rdquo; 标签的 Pod。 如果 <code>podSelector</code> 是空则选择该命名空间中所有的 Pod。</p>
<p><strong>policyTypes</strong>: 每个 NetworkPolicy 包含一个 <code>policyTypes</code> 字段，该字段值为一个列表，
这个列表的值可以是 <code>Ingress</code>, <code>Egress</code> 中的任意一个或同时包含两个。 该字段值是否包含
<code>Ingress</code> 表示是否将该策略执行到输入流量到达选定的 Pod；
<code>Egress</code> 表示是否将该策略执行到选择 Pod 输出的流量。
如果没有指定 <code>policyTypes</code> 字段，则默认情况下 <code>Ingress</code> 问题要设置，而 <code>Egress</code> 则只在
NetworkPolicy 中包含 <code>egress</code> 规则是才设置。</p>
<p><strong>ingress</strong>: 每个 NetworkPolicy 可能包含一个被允许的 <code>ingress</code> 规则列表。
每个规则所允许的流量会同时匹配 <code>from</code> 和 <code>ports</code> 两个部分。上面例子中的策略就包含一个规则
这个规则匹配来自一个端口加上三个源(第一个是通过 <code>ipBlock</code>指定一个 IP 段； 第三个是通过
<code>namespaceSelector</code>；第三个是通过 <code>podSelector</code>)中的一个的组合的流量</p>
<p><strong>egress</strong>: 每个 NetworkPolicy 可能包含一个被允许的 <code>egress</code> 规则列表。 每个规则允许的流量
由 <code>to</code> 和 <code>ports</code> 组合匹配。 上面的例子中的策略包含一个规则，这个规则匹配一个端口加上
<code>10.0.0.0/24</code> 中的任意一个目标的组合的流量。</p>
<p>因此，上面例子中 NetworkPolicy 如下:</p>
<ol>
<li>
<p>在默认(default)命名空间中隔离 &ldquo;role=db&rdquo; 所选择 Pod 的 <code>ingress</code> 和 <code>egress</code> 流量(如果它们还没有被隔离)</p>
</li>
<li>
<p>(Ingress 规则)允许以下范围的所有连接到默认(default)命名空间中包含 &ldquo;role=db&rdquo; 标签的 Pod 的 TCP 端口 6379:</p>
</li>
</ol>
<ul>
<li>默认(default)命名空间中包含 &ldquo;role=frontend&rdquo; 标签的任意 Pod</li>
<li>所在命名空间包含 &ldquo;project=myproject&rdquo; 标签的任意 Pod</li>
<li><code>172.17.0.0–172.17.0.255</code> 和 <code>172.17.2.0–172.17.255.255</code> IP 段中的地址(
<code>172.17.0.0/16</code> 中除了 <code>172.17.1.0/24</code> 之外的地址
)</li>
</ul>
<ol start="3">
<li>(Egress 规则) 允许 默认(default)命名空间中包含 &ldquo;role=db&rdquo; 的任意 Pod 到
CIDR 10.0.0.0/24 TCP 端口 5978 的所有连接</li>
</ol>
<p>更多示例见 <a href="/k8sDocs/tasks/administer-cluster/declare-network-policy/">声明网络策略</a></p>
<!--
## Behavior of `to` and `from` selectors

There are four kinds of selectors that can be specified in an `ingress` `from` section or `egress` `to` section:

__podSelector__: This selects particular Pods in the same namespace as the NetworkPolicy which should be allowed as ingress sources or egress destinations.

__namespaceSelector__: This selects particular namespaces for which all Pods should be allowed as ingress sources or egress destinations.

__namespaceSelector__ *and* __podSelector__: A single `to`/`from` entry that specifies both `namespaceSelector` and `podSelector` selects particular Pods within particular namespaces. Be careful to use correct YAML syntax; this policy:

```yaml
  ...
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          user: alice
      podSelector:
        matchLabels:
          role: client
  ...
```

contains a single `from` element allowing connections from Pods with the label `role=client` in namespaces with the label `user=alice`. But *this* policy:

```yaml
  ...
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          user: alice
    - podSelector:
        matchLabels:
          role: client
  ...
```

contains two elements in the `from` array, and allows connections from Pods in the local Namespace with the label `role=client`, *or* from any Pod in any namespace with the label `user=alice`.

When in doubt, use `kubectl describe` to see how Kubernetes has interpreted the policy.

__ipBlock__: This selects particular IP CIDR ranges to allow as ingress sources or egress destinations. These should be cluster-external IPs, since Pod IPs are ephemeral and unpredictable.

Cluster ingress and egress mechanisms often require rewriting the source or destination IP
of packets. In cases where this happens, it is not defined whether this happens before or
after NetworkPolicy processing, and the behavior may be different for different
combinations of network plugin, cloud provider, `Service` implementation, etc.

In the case of ingress, this means that in some cases you may be able to filter incoming
packets based on the actual original source IP, while in other cases, the "source IP" that
the NetworkPolicy acts on may be the IP of a `LoadBalancer` or of the Pod's node, etc.

For egress, this means that connections from pods to `Service` IPs that get rewritten to
cluster-external IPs may or may not be subject to `ipBlock`-based policies.
 -->
<h2 id="to-和-from-选择器的行为方式"><code>to</code> 和 <code>from</code> 选择器的行为方式</h2>
<p>在 <code>ingress</code> 的 <code>from</code> 区 或 <code>egress</code> 的 <code>to</code> 区可以指定以下四种选择器：</p>
<p><strong>podSelector</strong>:  选择与 NetworkPolicy 在同一个命名空间的指定 Pod 允许为 <code>ingress</code> 的源() 或 <code>egress</code> 的目的
<strong>namespaceSelector</strong>: 选择指定名称空间，其中所有的 Pod 允许为 <code>ingress</code> 的源或 <code>egress</code> 的目的
<strong>namespaceSelector</strong> <em>加</em> <strong>podSelector</strong>: 单个 <code>to</code>/<code>from</code> 条目可以同时指定 <code>namespaceSelector</code> 和 <code>podSelector</code>
来选择指定命名空间的指定 Pod。 需要注意正确地使用 YAML 语法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">  ...
  <span style="color:#66d9ef">ingress</span>:
  - <span style="color:#66d9ef">from</span>:
    - <span style="color:#66d9ef">namespaceSelector</span>:
        <span style="color:#66d9ef">matchLabels</span>:
          <span style="color:#66d9ef">user</span>: alice
      <span style="color:#66d9ef">podSelector</span>:
        <span style="color:#66d9ef">matchLabels</span>:
          <span style="color:#66d9ef">role</span>: client
  ...
</code></pre></div><p>上面的这个策略包含一个 <code>from</code> 元素，它允许连接的 Pod 在包含 <code>user=alice</code> 标签的命名空间中
并且要包含 <code>role=client</code> 标签。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">  ...
  <span style="color:#66d9ef">ingress</span>:
  - <span style="color:#66d9ef">from</span>:
    - <span style="color:#66d9ef">namespaceSelector</span>:
        <span style="color:#66d9ef">matchLabels</span>:
          <span style="color:#66d9ef">user</span>: alice
    - <span style="color:#66d9ef">podSelector</span>:
        <span style="color:#66d9ef">matchLabels</span>:
          <span style="color:#66d9ef">role</span>: client
  ...
</code></pre></div><p>这个策略包含两上 <code>from</code> 元素的数据， 它允许连接的 Pod 有: 同命名空间中有 <code>role=client</code> 标签的 Pod
<em>或</em> 任意命名空间中包含 <code>user=alice</code> 标签的任意 Pod</p>
<p>当搞不清楚的时候，就使用 <code>kubectl describe</code> 来看 k8s 是怎么来解释这个策略的。</p>
<p><strong>ipBlock</strong>: 指定 IP CIDR 范围允许为 <code>ingress</code> 的源或 <code>egress</code> 的目的。这个 IP 范围
应该是集群外部 IP， 因为 Pod 的 IP 是临时的并且是不可预测的。</p>
<p>集群的 <code>ingress</code> 和 <code>egress</code> 经常需要重写包的源或目的 IP。 如果发生了这种情况， 它发生在
NetworkPolicy 之前还是之后不不确定的，由网络插件，云提供商，<code>Service</code> 实现的不同而有不同的行为方式</p>
<p>对于 <code>ingress</code>, 就意味着在某些情况下可能可以通过实际的原始源 IP 地址来过滤包，在另一情况下,
NetworkPolicy 处理的的 &ldquo;源 IP&rdquo; 可能是 <code>LoadBalancer</code> 的 IP 或 Pod 所在节点的 IP 等。</p>
<p>对于 <code>egress</code>， 这就意味着 Pod 连接的目标 <code>Service</code> IP 在重写到集群外部IP 就可能受 <code>ipBlock</code>
策略控制，也可能不受控制。</p>
<!--
## Default policies

By default, if no policies exist in a namespace, then all ingress and egress traffic is allowed to and from pods in that namespace. The following examples let you change the default behavior
in that namespace.
 -->
<h2 id="默认策略">默认策略</h2>
<p>默认情况下，如果一个命名空间中没有策略存在，那这个命名空间中的 Pod 所有的 <code>ingress</code> 和 <code>egress</code>
流量都是允许的。 下面的例子让用户可以修改那个命名空间中的默认行为。</p>
<!--
### Default deny all ingress traffic

You can create a "default" isolation policy for a namespace by creating a NetworkPolicy that selects all pods but does not allow any ingress traffic to those pods.



 













<table class="includecode" id="servicenetworkingnetwork-policy-default-deny-ingressyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-default-deny-ingress.yaml" download="service/networking/network-policy-default-deny-ingress.yaml">
                    <code>service/networking/network-policy-default-deny-ingress.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-default-deny-ingressyaml')" title="Copy service/networking/network-policy-default-deny-ingress.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: default-deny-ingress
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Ingress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>



This ensures that even pods that aren't selected by any other NetworkPolicy will still be isolated. This policy does not change the default egress isolation behavior.
 -->
<h3 id="默认拒绝所有-ingress-流量">默认拒绝所有 <code>ingress</code> 流量</h3>
<p>可以能过创建一个 NetworkPolicy 为命名空间创建一个&quot;默认&quot;的隔离策略。这个 NetworkPolicy
会选择所有的 Pod 并且不允许任何 <code>ingress</code> 流量到这些 Pod。</p>


 













<table class="includecode" id="servicenetworkingnetwork-policy-default-deny-ingressyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-default-deny-ingress.yaml" download="service/networking/network-policy-default-deny-ingress.yaml">
                    <code>service/networking/network-policy-default-deny-ingress.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-default-deny-ingressyaml')" title="Copy service/networking/network-policy-default-deny-ingress.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: default-deny-ingress
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Ingress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


<p>这样可以保证即便有些 Pod 没有被其它任意 NetworkPolicy 选择还是会被隔离。
这个策略不会影响默认的 <code>egress</code> 隔离行为。</p>
<!--
### Default allow all ingress traffic

If you want to allow all traffic to all pods in a namespace (even if policies are added that cause some pods to be treated as "isolated"), you can create a policy that explicitly allows all traffic in that namespace.



 













<table class="includecode" id="servicenetworkingnetwork-policy-allow-all-ingressyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-allow-all-ingress.yaml" download="service/networking/network-policy-allow-all-ingress.yaml">
                    <code>service/networking/network-policy-allow-all-ingress.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-allow-all-ingressyaml')" title="Copy service/networking/network-policy-allow-all-ingress.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: allow-all-ingress
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">ingress</span>:
  - {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Ingress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


 -->
<h3 id="默认允许所有-ingress-流量">默认允许所有 <code>ingress</code> 流量</h3>
<p>如果想要在一个命名空间中允许到达所有 Pod 的所有流量(即便已经添加了一些策略导致有些 Pod 被认为是隔离的)
可以通过创建一个策略显式地允许这个命名空间中的所有离题。</p>


 













<table class="includecode" id="servicenetworkingnetwork-policy-allow-all-ingressyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-allow-all-ingress.yaml" download="service/networking/network-policy-allow-all-ingress.yaml">
                    <code>service/networking/network-policy-allow-all-ingress.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-allow-all-ingressyaml')" title="Copy service/networking/network-policy-allow-all-ingress.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: allow-all-ingress
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">ingress</span>:
  - {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Ingress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


<!--
### Default deny all egress traffic

You can create a "default" egress isolation policy for a namespace by creating a NetworkPolicy that selects all pods but does not allow any egress traffic from those pods.



 













<table class="includecode" id="servicenetworkingnetwork-policy-default-deny-egressyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-default-deny-egress.yaml" download="service/networking/network-policy-default-deny-egress.yaml">
                    <code>service/networking/network-policy-default-deny-egress.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-default-deny-egressyaml')" title="Copy service/networking/network-policy-default-deny-egress.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: default-deny-egress
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Egress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>



This ensures that even pods that aren't selected by any other NetworkPolicy will not be allowed egress traffic. This policy does not
change the default ingress isolation behavior.
 -->
<h3 id="默认拒绝所有-egress-流量">默认拒绝所有 <code>egress</code> 流量</h3>
<p>可以通过创建一个选择所有 Pod 并不接受任何来自这些 Pod 的 egress 流量的 NetworkPolicy 来作为
这个命名空间的默认 <code>egress</code> 隔离策略。</p>


 













<table class="includecode" id="servicenetworkingnetwork-policy-default-deny-egressyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-default-deny-egress.yaml" download="service/networking/network-policy-default-deny-egress.yaml">
                    <code>service/networking/network-policy-default-deny-egress.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-default-deny-egressyaml')" title="Copy service/networking/network-policy-default-deny-egress.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: default-deny-egress
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Egress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


<p>这样可以保证即便有 Pod 没有被其它任意 NetworkPolicy 选中，也不会被允许其 egress 流量。
这个策略不影响默认 <code>ingress</code> 隔离行为。</p>
<!--
### Default allow all egress traffic

If you want to allow all traffic from all pods in a namespace (even if policies are added that cause some pods to be treated as "isolated"), you can create a policy that explicitly allows all egress traffic in that namespace.



 













<table class="includecode" id="servicenetworkingnetwork-policy-allow-all-egressyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-allow-all-egress.yaml" download="service/networking/network-policy-allow-all-egress.yaml">
                    <code>service/networking/network-policy-allow-all-egress.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-allow-all-egressyaml')" title="Copy service/networking/network-policy-allow-all-egress.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: allow-all-egress
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">egress</span>:
  - {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Egress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


 -->
<h3 id="默认允许所有-egress-流量">默认允许所有 <code>egress</code> 流量</h3>
<p>如果想要允许一个命名空间中来自所有 Pod 的所有流量(即便已经添加了一些策略导致有些 Pod 被认为是隔离的)，
也可以通过创建一个策略显式地允许这个命名空间中所有的 <code>egress</code> 流量。</p>


 













<table class="includecode" id="servicenetworkingnetwork-policy-allow-all-egressyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-allow-all-egress.yaml" download="service/networking/network-policy-allow-all-egress.yaml">
                    <code>service/networking/network-policy-allow-all-egress.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-allow-all-egressyaml')" title="Copy service/networking/network-policy-allow-all-egress.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: allow-all-egress
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">egress</span>:
  - {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Egress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


<!--
### Default deny all ingress and all egress traffic

You can create a "default" policy for a namespace which prevents all ingress AND egress traffic by creating the following NetworkPolicy in that namespace.



 













<table class="includecode" id="servicenetworkingnetwork-policy-default-deny-allyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-default-deny-all.yaml" download="service/networking/network-policy-default-deny-all.yaml">
                    <code>service/networking/network-policy-default-deny-all.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-default-deny-allyaml')" title="Copy service/networking/network-policy-default-deny-all.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: default-deny-all
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Ingress
  - Egress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>



This ensures that even pods that aren't selected by any other NetworkPolicy will not be allowed ingress or egress traffic.
 -->
<h3 id="拒绝所有-ingress-和所有-egress-流量">拒绝所有 <code>ingress</code> 和所有 <code>egress</code> 流量</h3>
<p>You can create a &ldquo;default&rdquo; policy for a namespace which prevents all ingress AND egress traffic by creating the following NetworkPolicy in that namespace.
可以在一个命名空间中创建一个如下默认的 NetworkPolicy，同时禁止所有的 <code>ingress</code> 和 <code>egress</code> 流量。</p>


 













<table class="includecode" id="servicenetworkingnetwork-policy-default-deny-allyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/network-policy-default-deny-all.yaml" download="service/networking/network-policy-default-deny-all.yaml">
                    <code>service/networking/network-policy-default-deny-all.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnetwork-policy-default-deny-allyaml')" title="Copy service/networking/network-policy-default-deny-all.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">---
<span style="color:#66d9ef">apiVersion</span>: networking.k8s.io/v1
<span style="color:#66d9ef">kind</span>: NetworkPolicy
<span style="color:#66d9ef">metadata</span>:
  <span style="color:#66d9ef">name</span>: default-deny-all
<span style="color:#66d9ef">spec</span>:
  <span style="color:#66d9ef">podSelector</span>: {}
  <span style="color:#66d9ef">policyTypes</span>:
  - Ingress
  - Egress
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


<p>这样确保即便有 Pod 没有被其它任意 NetworkPolicy 选中，也不会被允许其 <code>ingress</code> 或 <code>egress</code> 流量</p>
<!--
## SCTP support






<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.19 [beta]</code>
</div>



As a beta feature, this is enabled by default. To disable SCTP at a cluster level, you (or your cluster administrator) will need to disable the `SCTPSupport` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/) for the API server with `--feature-gates=SCTPSupport=false,…`.
When the feature gate is enabled, you can set the `protocol` field of a NetworkPolicy to `SCTP`.

<blockquote class="note">
  <div><strong>说明：</strong> You must be using a <a class='glossary-tooltip' href='/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni' target='_blank'>CNI<span class='tooltip-text'>Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification.</span>
</a> plugin that supports SCTP protocol NetworkPolicies.</div>
</blockquote>

 -->
<h2 id="sctp-支持">SCTP 支持</h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.19 [beta]</code>
</div>


<p>作为一个 <code>beta</code> 版本的特性，默认是开启的。要在集群级别禁用 SCTP， 需要在 api-server 使用
<code>--feature-gates=SCTPSupport=false,…</code> 禁用
<code>SCTPSupport</code> <a href="/k8sDocs/reference/command-line-tools-reference/feature-gates/">功能特性阀</a>
当这个特性被启用时，可能在 NetworkPolicy 的 <code>protocol</code> 字段使用 <code>SCTP</code> 协议。
<blockquote class="note">
  <div><strong>说明：</strong> 必须要使用一个支持 NetworkPolicy SCTP 协议的 <a class='glossary-tooltip' href='/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni' target='_blank'>CNI<span class='tooltip-text'>Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification.</span>
</a> 插件</div>
</blockquote>
</p>
<!--
# What you CAN'T do with network policy's (at least, not yet)

As of Kubernetes 1.20, the following functionality does not exist in the NetworkPolicy API, but you might be able to implement workarounds using Operating System components (such as SELinux, OpenVSwitch, IPTables, and so on) or Layer 7 technologies (Ingress controllers, Service Mesh implementations) or admission controllers.  In case you are new to network security in Kubernetes, its worth noting that the following User Stories cannot (yet) be implemented using the NetworkPolicy API.  Some (but not all) of these user stories are actively being discussed for future releases of the NetworkPolicy API.

- Forcing internal cluster traffic to go through a common gateway (this might be best served with a service mesh or other proxy).
- Anything TLS related (use a service mesh or ingress controller for this).
- Node specific policies (you can use CIDR notation for these, but you cannot target nodes by their Kubernetes identities specifically).
- Targeting of namespaces or services by name (you can, however, target pods or namespaces by their<a class='glossary-tooltip' href='/k8sDocs/concepts/overview/working-with-objects/labels' target='_blank'>labels<span class='tooltip-text'>在对象上标上对用户有意义和有关联的属性</span>
</a>, which is often a viable workaround).
- Creation or management of "Policy requests" that are fulfilled by a third party.
- Default policies which are applied to all namespaces or pods (there are some third party Kubernetes distributions and projects which can do this).
- Advanced policy querying and reachability tooling.
- The ability to target ranges of Ports in a single policy declaration.
- The ability to log network security events (for example connections that are blocked or accepted).
- The ability to explicitly deny policies (currently the model for NetworkPolicies are deny by default, with only the ability to add allow rules).
- The ability to prevent loopback or incoming host traffic (Pods cannot currently block localhost access, nor do they have the ability to block access from their resident node).
 -->
<h2 id="不能通过网络策略做到的情况-至少目前还不能">不能通过网络策略做到的情况 (至少目前还不能)</h2>
<p>到 k8s v1.20 为止，以下功能在 NetworkPolicy API 中是不存在的， 但可能可能通过操作系统组件
(如 SELinux， OpenVSwitch， IPTables 等) 或者通过 7 层技术(Ingress 控制器，<code>Service Mesh</code> 实现)
或者 准入控制器(admission controller) 来曲线救国。 假如用户对 k8s 网络安全了解比较少，
需要注意下面的用户故事(User Stories)(还)不能通过使用 NetworkPolicy API 实现。
有些(但不是所有)正在被讨论加入到未来版本中的 NetworkPolicy API 中。</p>
<ul>
<li>强制集群内流量通过一个通用网关(这个最好使用服务网格或其它代理来提供)</li>
<li>所有与 TLS 相关的事(使用服务网格或 Ingress 控制器来实现)</li>
<li>节点特有的策略(可以使用 CIDR 标注，但是不能能过 k8s 标识来特指一些节点)(说的啥？)</li>
<li>通过名称将命名空间或 Service 作为目标(通常的做法是通过 Pod 或命名空间的
<a class='glossary-tooltip' href='/k8sDocs/concepts/overview/working-with-objects/labels' target='_blank'>标签<span class='tooltip-text'>在对象上标上对用户有意义和有关联的属性</span>
</a>来筛选目标)</li>
<li>通过第三方达成对&quot;Policy requests&quot;的创建的或管理</li>
<li>应用到所有命名空间或 Pod 的默认策略(有些第三方 k8s 发行版本和项目提供该功能)</li>
<li>高级策略查询和可到达性检查工具</li>
<li>在一个策略定义中设置端口范围的能力</li>
<li>输出网络安全事件的能力(如，连接是被禁止或接受)</li>
<li>声明显示拒绝的策略的能力(目前的网络策略模型默认为拒绝，只能提供添加允许规则的能力)</li>
<li>能够阻止回环网络或进入主机流量(目前 Pod 不能禁用通过 localhost 的访问，也不能禁止所在主机的访问)</li>
</ul>
<h2 id="相关资料">相关资料</h2>
<ul>
<li>实践 <a href="/docs/tasks/administer-cluster/declare-network-policy/">声明网络策略</a></li>
<li>参阅 <a href="https://github.com/ahmetb/kubernetes-network-policy-recipes">recipes</a>
启用网络策略的常见场景</li>
</ul>
<div class="edit-meta">
Last updated on 23 Sep 2020


<br>
Published on 9 Oct 2020
<br><a href="https://github.com/lostsquirrel/k8sDocs/edit/master/content/concepts/services-networking/network-policies.md" class="edit-page"><i class="fas fa-pen-square"></i> Edit on GitHub</a></div><nav class="pagination"><a class="nav nav-prev" href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/ingress-controllers/" title="Ingress 控制器"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Ingress 控制器</a>
<a class="nav nav-next" href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/" title="通过 HostAliases 向 Pod 的 /etc/hosts 文件中添加条目">Next - 通过 HostAliases 向 Pod 的 /etc/hosts 文件中添加条目 <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs">Home</a></li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/setup/">Getting started<span class="mark closed">+</span></a>
  
<ul class="sub-menu">

<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/setup/00-release/">Release notes and version skew</a>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/setup/01-learning-environment/">学习环境<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/setup/01-learning-environment/00-minikube/">使用 Minikube 搭建 K8s环境</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/setup/01-learning-environment/01-kind/">使用 Kind 搭建 K8s环境</a></li>
</ul>
  
</li>
</ul>
  
</li>

<li class="parent has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/">概念(Concepts)<span class="mark opened">-</span></a>
  
<ul class="sub-menu">

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/">概览<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/00-what-is-k8s/">k8s 是什么</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/01-components/">k8s 组件</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/02-k8s-api/">k8s API 说明</a></li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/working-with-objects/">k8s 对象管理<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/working-with-objects/00-kubernetes-objects/">k8s 对象介绍</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/working-with-objects/names/">对象命令与ID</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/working-with-objects/02-namespace/">命名空间(Namespaces)</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/working-with-objects/labels/">标签和标签选择器</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/working-with-objects/04-annotation/">注解 (Annotations)</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/working-with-objects/05-field-selectors/">字段选择器</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/overview/working-with-objects/06-common-labels/">标签设置指导</a></li>
</ul>
  
</li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/01-architecture/">集群架构<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/01-architecture/00-nodes/">节点</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/01-architecture/01-control-plane-node-communication/">控制中心与节点的通信</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/01-architecture/02-controller/">控制器</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/01-architecture/03-cloud-controller/">Cloud Controller Manager</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/containers/">容器<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/containers/00-images/">镜像</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/containers/01-container-environment/">容器环境</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/containers/02-runtime-class/">Runtime Class</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/containers/container-lifecycle-hooks/">容器生命周期钩子</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/">工作负载(Workload)<span class="mark closed">+</span></a>
  
<ul class="sub-menu">

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/pods/">Pod<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/pods/pod-lifecycle/">Pod 生命周期</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/pods/init-containers/">初始化容器</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/pods/pod-topology-spread-constraints/">Pod 拓扑分布约束条件</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/pods/podpreset/">Pod 预设信息</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/pods/disruptions/">Disruptions</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/pods/ephemeral-containers/">临时容器</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/">控制器<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/deployment/">Deployment</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/replicaset/">ReplicaSet</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/statefulset/">StatefulSet</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/daemonset/">DaemonSet</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/job/">Job</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/garbage-collection/">垃圾回收</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/ttlafterfinished/">用于已完成资源的 TTL 控制器</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/cron-jobs/">CronJob</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/workloads/controllers/replicationcontroller/">ReplicationController</a></li>
</ul>
  
</li>
</ul>
  
</li>

<li class="parent has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/">Service, 负载均衡, 网络<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/service/">Service</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/service-topology/">Service Topology</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/dns-pod-service/">Service 和 Pod 的 DNS</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/connect-applications-service/">通过 Service 连接应用</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/endpoint-slices/">EndpointSlice</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/ingress/">Ingress</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/ingress-controllers/">Ingress 控制器</a></li>
<li class="active"><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/network-policies/">网络策略</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/">通过 HostAliases 向 Pod 的 /etc/hosts 文件中添加条目</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/concepts/services-networking/dual-stack/">IPv4/IPv6 双栈</a></li>
</ul>
  
</li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/tasks/">Tasks<span class="mark closed">+</span></a>
  
<ul class="sub-menu">

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/tasks/tools/">Install Tools<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/tasks/tools/00-install-kubectl/">下载安装配置 kubectl</a></li>
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/tasks/tools/01-install-minikube/">安装 Minikube</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/tasks/configure-pod-container/">Configure Pod Containters<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">存活(liveness), 就绪(readiness), 启动(startup)探针配置</a></li>
</ul>
  
</li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/tutorials/">Tutorials<span class="mark closed">+</span></a>
  
<ul class="sub-menu">

<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/tutorials/00-hello-minikube/">Hello Minikube</a>
  
</li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/reference/">Reference<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/reference/glossary/">Standardized Glossary</a></li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/reference/07-kubectl/">kubectl CLI<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/reference/07-kubectl/00-overview/">kubectl 概览</a></li>
</ul>
  
</li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://lostsquirrel.github.io/k8sDocs/examples/">Examples<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://lostsquirrel.github.io/k8sDocs/examples/readme/"></a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
