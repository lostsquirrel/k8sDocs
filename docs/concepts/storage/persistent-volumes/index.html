<!doctype html>
<html lang="zh" class="no-js">
  <head>
    



<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.75.1" />

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<link rel="shortcut icon" type="image/png" href="/k8sDocs/images/favicon.png">
<link rel="apple-touch-icon" href="/k8sDocs/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/manifest.webmanifest">
<link rel="apple-touch-icon" href="/images/kubernetes-192x192.png">
<title>Persistent Volumes | Kubernetes</title><meta property="og:title" content="Persistent Volumes" />
<meta property="og:description" content="Automatically mount the storage system of your choice, whether from local storage, a public cloud provider such as GCP or AWS, or a network storage system such as NFS, iSCSI, Gluster, Ceph, Cinder, or Flocker. content_type: concept weight: 20 --- -- 本文主要介绍当前 k8s 中 持久化卷(persistent volume) 的状态" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lostsquirrel.github.io/k8sDocs/docs/concepts/storage/persistent-volumes/" />
<meta property="og:site_name" content="Kubernetes" />
<meta itemprop="name" content="Persistent Volumes">
<meta itemprop="description" content="Automatically mount the storage system of your choice, whether from local storage, a public cloud provider such as GCP or AWS, or a network storage system such as NFS, iSCSI, Gluster, Ceph, Cinder, or Flocker. content_type: concept weight: 20 --- -- 本文主要介绍当前 k8s 中 持久化卷(persistent volume) 的状态">

<meta itemprop="wordCount" content="6751">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Persistent Volumes"/>
<meta name="twitter:description" content="Automatically mount the storage system of your choice, whether from local storage, a public cloud provider such as GCP or AWS, or a network storage system such as NFS, iSCSI, Gluster, Ceph, Cinder, or Flocker. content_type: concept weight: 20 --- -- 本文主要介绍当前 k8s 中 持久化卷(persistent volume) 的状态"/>





<link rel="preload" href="/k8sDocs/scss/main.min.537757ec8e00d87ec206229d5725b6d05e078dd447818e448f0802685603e730.css" as="style">
<link href="/k8sDocs/scss/main.min.537757ec8e00d87ec206229d5725b6d05e078dd447818e448f0802685603e730.css" rel="stylesheet" integrity="">


<script src="/k8sDocs/js/jquery-3.5.1.min.js" ></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "https://lostsquirrel.github.io/k8sDocs/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href=/k8sDocs/css/base_fonts.css>

<link rel="stylesheet" href="/k8sDocs/css/jquery-ui.min.css">
<link rel="stylesheet" href="/k8sDocs/css/callouts.css">
<link rel="stylesheet" href="/k8sDocs/css/custom.css">
<link rel="stylesheet" href="/k8sDocs/css/custom-jekyll/tags.css">



<meta name="description" content="Automatically mount the storage system of your choice, whether from local storage, a public cloud provider such as GCP or AWS, or a network storage system such as NFS, iSCSI, Gluster, Ceph, Cinder, or Flocker. content_type: concept weight: 20 --- -- 本文主要介绍当前 k8s 中 持久化卷(persistent volume) 的状态">
<meta property="og:description" content="Automatically mount the storage system of your choice, whether from local storage, a public cloud provider such as GCP or AWS, or a network storage system such as NFS, iSCSI, Gluster, Ceph, Cinder, or Flocker. content_type: concept weight: 20 --- -- 本文主要介绍当前 k8s 中 持久化卷(persistent volume) 的状态">
<meta name="twitter:description" content="Automatically mount the storage system of your choice, whether from local storage, a public cloud provider such as GCP or AWS, or a network storage system such as NFS, iSCSI, Gluster, Ceph, Cinder, or Flocker. content_type: concept weight: 20 --- -- 本文主要介绍当前 k8s 中 持久化卷(persistent volume) 的状态">
<meta property="og:url" content="https://lostsquirrel.github.io/k8sDocs/docs/concepts/storage/persistent-volumes/">
<meta property="og:title" content="Persistent Volumes">
<meta name="twitter:title" content="Persistent Volumes">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/k8sDocs/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">



<script src="/k8sDocs/js/script.js"></script>


    <title>Persistent Volumes | Kubernetes</title>
  </head>
  <body class="td-page td-documentation">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/k8sDocs/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">

		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/k8sDocs/docs/" >Documentation</span></a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		</ul>
	</div>
  

</nav>

      
      <div class="header-filler"></div>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-md-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
            




<div id="td-sidebar-menu" class="td-sidebar__inner">
  
  <form class="td-sidebar__search d-flex align-items-center d-lg-none">
    

    <button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type="button" data-toggle="collapse" data-target="#td-section-nav" aria-controls="td-docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    </button>
  </form>
  
  <nav class="collapse td-sidebar-nav" id="td-section-nav">
    
    






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Kubernetes Documentation</a>
  </li>
  <ul>
    <li class="collapse show" id="k8sdocsdocs">
      
      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">概念(Concepts)</a>
  </li>
  <ul>
    <li class="collapse show" id="k8sdocsdocsconcepts">
      
      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/overview/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">概览</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsoverview">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverview00-what-is-k8s" href="/k8sDocs/docs/concepts/overview/00-what-is-k8s/">k8s 是什么</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverview01-components" href="/k8sDocs/docs/concepts/overview/01-components/">k8s 组件</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverview02-k8s-api" href="/k8sDocs/docs/concepts/overview/02-k8s-api/">k8s API 说明</a>
      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/overview/working-with-objects/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">k8s 对象管理</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsoverviewworking-with-objects">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects00-kubernetes-objects" href="/k8sDocs/docs/concepts/overview/working-with-objects/00-kubernetes-objects/">k8s 对象介绍</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objectsnames" href="/k8sDocs/docs/concepts/overview/working-with-objects/names/">对象命令与ID</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects02-namespace" href="/k8sDocs/docs/concepts/overview/working-with-objects/02-namespace/">命名空间(Namespaces)</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objectslabels" href="/k8sDocs/docs/concepts/overview/working-with-objects/labels/">标签和标签选择器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects04-annotation" href="/k8sDocs/docs/concepts/overview/working-with-objects/04-annotation/">注解 (Annotations)</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects05-field-selectors" href="/k8sDocs/docs/concepts/overview/working-with-objects/05-field-selectors/">字段选择器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects06-common-labels" href="/k8sDocs/docs/concepts/overview/working-with-objects/06-common-labels/">标签设置指导</a>
      
      
    </li>
  </ul>
</ul>

      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/architecture/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">集群架构</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsarchitecture">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsarchitecturenodes" href="/k8sDocs/docs/concepts/architecture/nodes/">节点</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsarchitecturecontrol-plane-node-communication" href="/k8sDocs/docs/concepts/architecture/control-plane-node-communication/">控制中心与节点的通信</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsarchitecturecontroller" href="/k8sDocs/docs/concepts/architecture/controller/">控制器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsarchitecturecloud-controller" href="/k8sDocs/docs/concepts/architecture/cloud-controller/">Cloud Controller Manager</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/containers/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">容器</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptscontainers">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptscontainers00-images" href="/k8sDocs/docs/concepts/containers/00-images/">镜像</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptscontainers01-container-environment" href="/k8sDocs/docs/concepts/containers/01-container-environment/">容器环境</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptscontainers02-runtime-class" href="/k8sDocs/docs/concepts/containers/02-runtime-class/">Runtime Class</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptscontainerscontainer-lifecycle-hooks" href="/k8sDocs/docs/concepts/containers/container-lifecycle-hooks/">容器生命周期钩子</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/workloads/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">工作负载(Workload)</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsworkloads">
      
      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/workloads/pods/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">Pod</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsworkloadspods">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodspod-lifecycle" href="/k8sDocs/docs/concepts/workloads/pods/pod-lifecycle/">Pod 生命周期</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodsinit-containers" href="/k8sDocs/docs/concepts/workloads/pods/init-containers/">初始化容器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodspod-topology-spread-constraints" href="/k8sDocs/docs/concepts/workloads/pods/pod-topology-spread-constraints/">Pod 拓扑分布约束条件</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodspodpreset" href="/k8sDocs/docs/concepts/workloads/pods/podpreset/">Pod 预设信息</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodsdisruptions" href="/k8sDocs/docs/concepts/workloads/pods/disruptions/">Disruptions</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodsephemeral-containers" href="/k8sDocs/docs/concepts/workloads/pods/ephemeral-containers/">临时容器</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/workloads/controllers/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">控制器</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsworkloadscontrollers">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersdeployment" href="/k8sDocs/docs/concepts/workloads/controllers/deployment/">Deployment</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersreplicaset" href="/k8sDocs/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersstatefulset" href="/k8sDocs/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersdaemonset" href="/k8sDocs/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersjob" href="/k8sDocs/docs/concepts/workloads/controllers/job/">Job</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersgarbage-collection" href="/k8sDocs/docs/concepts/workloads/controllers/garbage-collection/">垃圾回收</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersttlafterfinished" href="/k8sDocs/docs/concepts/workloads/controllers/ttlafterfinished/">用于已完成资源的 TTL 控制器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollerscron-jobs" href="/k8sDocs/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersreplicationcontroller" href="/k8sDocs/docs/concepts/workloads/controllers/replicationcontroller/">ReplicationController</a>
      
      
    </li>
  </ul>
</ul>

      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/services-networking/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">Service, 负载均衡, 网络</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsservices-networking">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingservice" href="/k8sDocs/docs/concepts/services-networking/service/">Service</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingservice-topology" href="/k8sDocs/docs/concepts/services-networking/service-topology/">Service Topology</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingdns-pod-service" href="/k8sDocs/docs/concepts/services-networking/dns-pod-service/">Service 和 Pod 的 DNS</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingconnect-applications-service" href="/k8sDocs/docs/concepts/services-networking/connect-applications-service/">通过 Service 连接应用</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingendpoint-slices" href="/k8sDocs/docs/concepts/services-networking/endpoint-slices/">EndpointSlice</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingingress" href="/k8sDocs/docs/concepts/services-networking/ingress/">Ingress</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingingress-controllers" href="/k8sDocs/docs/concepts/services-networking/ingress-controllers/">Ingress 控制器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingnetwork-policies" href="/k8sDocs/docs/concepts/services-networking/network-policies/">网络策略</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingadd-entries-to-pod-etc-hosts-with-host-aliases" href="/k8sDocs/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/">通过 HostAliases 向 Pod 的 /etc/hosts 文件中添加条目</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingdual-stack" href="/k8sDocs/docs/concepts/services-networking/dual-stack/">IPv4/IPv6 双栈</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/storage/" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">存储(Storage)</a>
  </li>
  <ul>
    <li class="collapse show" id="k8sdocsdocsconceptsstorage">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page  active" id="m-k8sdocsdocsconceptsstoragepersistent-volumes" href="/k8sDocs/docs/concepts/storage/persistent-volumes/">Persistent Volumes</a>
      
      
    </li>
  </ul>
</ul>

      
      
    </li>
  </ul>
</ul>

      
      
    </li>
  </ul>
</ul>

  </nav>
</div>




          </div>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            <nav aria-label="breadcrumb" class="d-none d-md-block d-print-none">
	<ol class="breadcrumb spb-1">
		













<li class="breadcrumb-item" >
	<a href="https://lostsquirrel.github.io/k8sDocs/docs/">Kubernetes Documentation</a>
</li>




<li class="breadcrumb-item" >
	<a href="https://lostsquirrel.github.io/k8sDocs/docs/concepts/">概念(Concepts)</a>
</li>




<li class="breadcrumb-item" >
	<a href="https://lostsquirrel.github.io/k8sDocs/docs/concepts/storage/">存储(Storage)</a>
</li>




<li class="breadcrumb-item active" aria-current="page">
	<a href="https://lostsquirrel.github.io/k8sDocs/docs/concepts/storage/persistent-volumes/">Persistent Volumes</a>
</li>

	</ol>
</nav	>

            
              
            
              
    <div class="td-content">
    
<p>
  <a href="https://github.com/kubernetes/website/edit/master/content/zh/docs/concepts/storage/persistent-volumes.md" id="editPageButton" target="_blank" data-proofer-ignore>
    Edit This Page
  </a>
</p>

  <h1>Persistent Volumes</h1>
  
  

<!--
---
reviewers:
- jsafrane
- saad-ali
- thockin
- msau42
- xing-yang
title: Persistent Volumes
feature:
  title: Storage orchestration
  description: >
    Automatically mount the storage system of your choice, whether from local storage, a public cloud provider such as <a href="https://cloud.google.com/storage/">GCP</a> or <a href="https://aws.amazon.com/products/storage/">AWS</a>, or a network storage system such as NFS, iSCSI, Gluster, Ceph, Cinder, or Flocker.

content_type: concept
weight: 20
---
 -->
<!-- overview -->
<!--
This document describes the current state of _persistent volumes_ in Kubernetes. Familiarity with [volumes](/docs/concepts/storage/volumes/) is suggested.
 -->
<p>本文主要介绍当前 k8s 中 <em>持久化卷(persistent volume)</em> 的状态。
建议先熟悉 <a href="/k8sDocs/concepts/storage/volumes/">volumes</a></p>
<!-- body -->
<!--
## Introduction

Managing storage is a distinct problem from managing compute instances. The PersistentVolume subsystem provides an API for users and administrators that abstracts details of how storage is provided from how it is consumed. To do this, we introduce two new API resources:  PersistentVolume and PersistentVolumeClaim.

A _PersistentVolume_ (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using [Storage Classes](/docs/concepts/storage/storage-classes/). It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.

A _PersistentVolumeClaim_ (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory).  Claims can request specific size and access modes (e.g., they can be mounted ReadWriteOnce, ReadOnlyMany or ReadWriteMany, see [AccessModes](#access-modes)).

While PersistentVolumeClaims allow a user to consume abstract storage resources, it is common that users need PersistentVolumes with varying properties, such as performance, for different problems. Cluster administrators need to be able to offer a variety of PersistentVolumes that differ in more ways than just size and access modes, without exposing users to the details of how those volumes are implemented. For these needs, there is the _StorageClass_ resource.

See the [detailed walkthrough with working examples](/docs/tasks/configure-pod-container/configure-persistent-volume-storage/).
 -->
<h2 id="介绍">介绍</h2>
<p>管理存储和管理实例是两个不同的问题。 PersistentVolume 子系统为用户和管理员提供了一套 API 将
存储是怎么提供的细节从存储使用中抽象出来。 而为了做到这一个我们要介绍两个新的 API 资源:
PersistentVolume 和 PersistentVolumeClaim.</p>
<p><em>PersistentVolume</em> (PV) 是集群中的一块存储，它可能由管理员管理或使用
<a href="/docs/concepts/storage/storage-classes/">StorageClass</a>
动态管理。它是集群中的一个资源，就像节点是集群中的一个资源一样。 PV 是与卷(Volume)类似的卷插件，
但它的生命周期与使用它的 Pod 的生命周期是相互独立的。这个 API 对象中包含了存储的实现细节，包含
NFS, iSCSI, 云服务提供的存储系统。</p>
<p><em>PersistentVolumeClaim</em> (PVC) 是一个用户对存储的请求。 它就像是一个 Pod。Pod 使用的是节点上的资源
而 PVC 使用的是 PV 资源。 Pod 可以申请指定级别的资源(CPU 和 Memory)。 PVC 可以申请指定容量的存储
和访问模式 (如，它们可以以 <code>ReadWriteOnce</code>, <code>ReadOnlyMany</code> 或 <code>ReadWriteMany</code> 方式挂载，
见 <a href="#access-modes">AccessMode</a>)</p>
<p>因为 <code>PersistentVolumeClaim</code> 允许用户使用抽象的存储资源，通常用户都需要 PersistentVolume
中包含许多属性，如性能，来应对不同的问题。 集群管理员需要能够提供多样的 PersistentVolume，而不
仅仅是容量和访问模式，还需要向用户提供这些卷的实现细节。 为了满足这些需求，我们就有了 <em>StorageClass</em> 资源。</p>
<p><a href="/k8sDocs/tasks/configure-pod-container/configure-persistent-volume-storage/">亲自上手试试</a>.</p>
<!--
## Lifecycle of a volume and claim

PVs are resources in the cluster. PVCs are requests for those resources and also act as claim checks to the resource. The interaction between PVs and PVCs follows this lifecycle:
 -->
<h2 id="pv-和-pvc-的生命周期">PV 和 PVC 的生命周期</h2>
<p>PV 是集群中的资源。 PVC 是对这些资源的申请同时也表现为对这些资源的检查声明。PV 和 PVC 之间的
相互影响遵守以下生命周期:</p>
<!--
### Provisioning

There are two ways PVs may be provisioned: statically or dynamically.
 -->
<h3 id="供给">供给</h3>
<p>PV 可以被两个方式提供: 静态供给 或 动态供给</p>
<!--
#### Static

A cluster administrator creates a number of PVs. They carry the details of the real storage, which is available for use by cluster users. They exist in the Kubernetes API and are available for consumption.
 -->
<h4 id="静态供给">静态供给</h4>
<p>集群管理创建一系列 PV。 它们包含真实存储的细节，可以被集群用户使用。
它们存在于 k8s API 中，可以被取用。</p>
<!--
#### Dynamic

When none of the static PVs the administrator created match a user's PersistentVolumeClaim,
the cluster may try to dynamically provision a volume specially for the PVC.
This provisioning is based on StorageClasses: the PVC must request a
[storage class](/docs/concepts/storage/storage-classes/) and
the administrator must have created and configured that class for dynamic
provisioning to occur. Claims that request the class `""` effectively disable
dynamic provisioning for themselves.

To enable dynamic storage provisioning based on storage class, the cluster administrator
needs to enable the `DefaultStorageClass` [admission controller](/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass)
on the API server. This can be done, for example, by ensuring that `DefaultStorageClass` is
among the comma-delimited, ordered list of values for the `--enable-admission-plugins` flag of
the API server component. For more information on API server command-line flags,
check [kube-apiserver](/docs/admin/kube-apiserver/) documentation.
 -->
<h4 id="动态供给">动态供给</h4>
<p>当管理创建的 PV 不能满足用户的 PersistentVolumeClaim 时，集群可能就会尝试为这个 PVC 动态
提供一个卷。这种供给基于 <code>StorageClass</code>: PVC 必须要申请一个
<a href="/k8sDocs/concepts/storage/storage-classes/">StorageClass</a>
并且在动态供给发生之前管理员必须要完成该 <code>StorageClass</code> 的创建和配置。
如果 PVC 的 <code>StorageClass</code> 被设置为 <code>&quot;&quot;</code> 实际上表示关闭自身的动态供给。</p>
<p>要启用基于 <code>StorageClass</code> 的动态存储供给需要集群管理在 api-server 中的
<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass">准入控制</a>
中启用 <code>DefaultStorageClass</code>。 具体的配置方法就是确认 api-server 组件的 <code>--enable-admission-plugins</code> 选项
的值中有没有 <code>DefaultStorageClass</code>。 更多关于 api-server 命令行参数见
<a href="https://kubernetes.io/docs/admin/kube-apiserver/">kube-apiserver</a> 文档</p>
<!--
### Binding

A user creates, or in the case of dynamic provisioning, has already created, a PersistentVolumeClaim with a specific amount of storage requested and with certain access modes. A control loop in the master watches for new PVCs, finds a matching PV (if possible), and binds them together. If a PV was dynamically provisioned for a new PVC, the loop will always bind that PV to the PVC. Otherwise, the user will always get at least what they asked for, but the volume may be in excess of what was requested. Once bound, PersistentVolumeClaim binds are exclusive, regardless of how they were bound. A PVC to PV binding is a one-to-one mapping, using a ClaimRef which is a bi-directional binding between the PersistentVolume and the PersistentVolumeClaim.

Claims will remain unbound indefinitely if a matching volume does not exist. Claims will be bound as matching volumes become available. For example, a cluster provisioned with many 50Gi PVs would not match a PVC requesting 100Gi. The PVC can be bound when a 100Gi PV is added to the cluster.
 -->
<h3 id="binding">绑定</h3>
<p>当一个指定容量和访问模式的 <code>PersistentVolumeClaim</code> 被创建后。 主控中心中的一个控制回环会监控新创建的 PVC，
如果有匹配的 PV 存在，则将它们绑定在一起。 如果这个 PV 是动态供给给这个新建的 PVC 的， 那么控制
回环将会始终将这个 PV 绑定到这个 PVC。 否则用户会得到至少满足其请求的卷，但这个卷容量可能实际是超出请求的。
当绑定完成，就会确定绑定关系，不管它们是怎么绑定的。 PVC 到 PV 的绑定是一对一关系，PV 使用的 <code>spec.claimRef</code>
实现 <code>PersistentVolume</code> 与 <code>PersistentVolumeClaim</code> 的双向绑定。</p>
<p>如果没有匹配的 PV 存在，PVC 会永远保持在未绑定状态。 当有可用的匹配 PV 出现时 PVC 就会绑定。
例如， 集群中提供许多 50Gi PV 是不会被一个申请 100Gi 的 PVC 匹配到的。当集群中添加了一个
100Gi PV 时，这个 PVC 就可以绑定了。</p>
<!--
### Using

Pods use claims as volumes. The cluster inspects the claim to find the bound volume and mounts that volume for a Pod. For volumes that support multiple access modes, the user specifies which mode is desired when using their claim as a volume in a Pod.

Once a user has a claim and that claim is bound, the bound PV belongs to the user for as long as they need it. Users schedule Pods and access their claimed PVs by including a `persistentVolumeClaim` section in a Pod's `volumes` block. See [Claims As Volumes](#claims-as-volumes) for more details on this.
 -->
<h3 id="使用">使用</h3>
<p>Pod 会将 PVC 当作卷来使用。 集群会检视这个 PVC 找到它绑定的 PV 然后将这个 PV 挂载到 Pod 中。
对于支持多次访问模式的卷，用户在 Pod 当作卷的 PVC 中指定需要的访问模式。</p>
<p>当一个用户拥有一个 PVC 并且这个 PVC 完成绑定，则这个被绑定的 PV 在用户需要时始终属于该用户。
用户通过 Pod 中的 <code>volumes</code> 配置区中添加 <code>persistentVolumeClaim</code> 配置区来访问这些由
PVC 管理的 PV。
更多信息见 <a href="#claims-as-volumes">将 PVC 当作卷(PV)</a></p>
<!--
### Storage Object in Use Protection
The purpose of the Storage Object in Use Protection feature is to ensure that PersistentVolumeClaims (PVCs) in active use by a Pod and PersistentVolume (PVs) that are bound to PVCs are not removed from the system, as this may result in data loss.

<blockquote class="note">
  <div><strong>说明：</strong> PVC is in active use by a Pod when a Pod object exists that is using the PVC.</div>
</blockquote>


If a user deletes a PVC in active use by a Pod, the PVC is not removed immediately. PVC removal is postponed until the PVC is no longer actively used by any Pods. Also, if an admin deletes a PV that is bound to a PVC, the PV is not removed immediately. PV removal is postponed until the PV is no longer bound to a PVC.

You can see that a PVC is protected when the PVC's status is `Terminating` and the `Finalizers` list includes `kubernetes.io/pvc-protection`:

```shell
kubectl describe pvc hostpath
Name:          hostpath
Namespace:     default
StorageClass:  example-hostpath
Status:        Terminating
Volume:
Labels:        <none>
Annotations:   volume.beta.kubernetes.io/storage-class=example-hostpath
               volume.beta.kubernetes.io/storage-provisioner=example.com/hostpath
Finalizers:    [kubernetes.io/pvc-protection]
...
```

You can see that a PV is protected when the PV's status is `Terminating` and the `Finalizers` list includes `kubernetes.io/pv-protection` too:

```shell
kubectl describe pv task-pv-volume
Name:            task-pv-volume
Labels:          type=local
Annotations:     <none>
Finalizers:      [kubernetes.io/pv-protection]
StorageClass:    standard
Status:          Terminating
Claim:
Reclaim Policy:  Delete
Access Modes:    RWO
Capacity:        1Gi
Message:
Source:
    Type:          HostPath (bare host directory volume)
    Path:          /tmp/data
    HostPathType:
Events:            <none>
```
 -->
<h3 id="使用保护模式的存储对象">使用保护模式的存储对象</h3>
<p>保护模式的存储对象特性的目的是保证被 Pod 使用的有效的 PVC 和与 PVC 绑定的 PV 能会被系统删除，
从而可能导致数据丢失。
<blockquote class="note">
  <div><strong>说明：</strong> 当一个使用 PVC 的 Pod 对象存在时就表示 PVC 被 Pod 有效使用。</div>
</blockquote>
</p>
<p>如果用户删除了一个被 Pod 有效使用的 PVC， 这个 PVC 不会立马被删除。 PVC 会延迟到没有被任何
Pod 有效使用后才会删除。 同样，如果管理员删除了一个与 PVC 绑定的 PV， 这个 PV 也不会被立马删除，
PV 的删除行为会被延迟到不再与 PVC 绑定时。</p>
<p>当 PVC 的状态是 <code>Terminating</code> 并且 <code>Finalizers</code> 列表中包含 <code>kubernetes.io/pvc-protection</code>
就表示这个 PVC 是被保护的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe pvc hostpath
Name:          hostpath
Namespace:     default
StorageClass:  example-hostpath
Status:        Terminating
Volume:
Labels:        &lt;none&gt;
Annotations:   volume.beta.kubernetes.io/storage-class<span style="color:#f92672">=</span>example-hostpath
               volume.beta.kubernetes.io/storage-provisioner<span style="color:#f92672">=</span>example.com/hostpath
Finalizers:    <span style="color:#f92672">[</span>kubernetes.io/pvc-protection<span style="color:#f92672">]</span>
...
</code></pre></div><p>同样，当 PV 的状态是 <code>Terminating</code> 并且 <code>Finalizers</code> 列表中包含 <code>kubernetes.io/pvc-protection</code>
就表示这个 PV 是被保护的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe pv task-pv-volume
Name:            task-pv-volume
Labels:          type<span style="color:#f92672">=</span>local
Annotations:     &lt;none&gt;
Finalizers:      <span style="color:#f92672">[</span>kubernetes.io/pv-protection<span style="color:#f92672">]</span>
StorageClass:    standard
Status:          Terminating
Claim:
Reclaim Policy:  Delete
Access Modes:    RWO
Capacity:        1Gi
Message:
Source:
    Type:          HostPath <span style="color:#f92672">(</span>bare host directory volume<span style="color:#f92672">)</span>
    Path:          /tmp/data
    HostPathType:
Events:            &lt;none&gt;
</code></pre></div><!--
### Reclaiming

When a user is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy for a PersistentVolume tells the cluster what to do with the volume after it has been released of its claim. Currently, volumes can either be Retained, Recycled, or Deleted.
 -->
<h3 id="回收">回收</h3>
<p>当用于不再需要一个卷时，可以通过 API 删除这个 PVC 对象，这样就允许对对应资源的回收。 PV 的回收
策略让集群可以在 PV 释放以后使用对应的方式回收。 目前，卷的回收策略有 保留(<code>Retain</code>),
循环使用(<code>Recycle</code>), 删除 (<code>Delete</code>).</p>
<!--
#### Retain

The `Retain` reclaim policy allows for manual reclamation of the resource. When the PersistentVolumeClaim is deleted, the PersistentVolume still exists and the volume is considered "released". But it is not yet available for another claim because the previous claimant's data remains on the volume. An administrator can manually reclaim the volume with the following steps.

1. Delete the PersistentVolume. The associated storage asset in external infrastructure (such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume) still exists after the PV is deleted.
1. Manually clean up the data on the associated storage asset accordingly.
1. Manually delete the associated storage asset, or if you want to reuse the same storage asset, create a new PersistentVolume with the storage asset definition.
 -->
<h4 id="保留retained">保留(<code>Retained</code>)</h4>
<p>保留(<code>Retained</code>) 回收策略允许对资源手动回收。 当 PVC 被删除后，其之前绑定的 PV 依然存在并被
认为是已经释放。 但是它还不被另一个 PVC 使用，因为其中还有上一个 PVC 时的数据。 管理员可以
通过以下步骤手动回收这个卷:</p>
<ol>
<li>删除 PV 对象。 它所关联的外部存储设施(如 AWS EBS, GCE PD, Azure Disk, Cinder 卷)依然存在。</li>
<li>根据需要手动清理对应存储资源上的数据</li>
<li>手动删除对应的存储资源，如果想要重新使用该存储资源，可以再创建一个新的 PV 对象与之关联。</li>
</ol>
<!--
#### Delete

For volume plugins that support the `Delete` reclaim policy, deletion removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume. Volumes that were dynamically provisioned inherit the [reclaim policy of their StorageClass](#reclaim-policy), which defaults to `Delete`. The administrator should configure the StorageClass according to users' expectations; otherwise, the PV must be edited or patched after it is created. See [Change the Reclaim Policy of a PersistentVolume](/docs/tasks/administer-cluster/change-pv-reclaim-policy/).
 -->
<h4 id="删除-delete">删除 (<code>Delete</code>)</h4>
<p>对于支持 删除 (<code>Delete</code>) 回收策略的卷插件，在删除 PVC 对象之后与其郑的 PV 对象也会被删除，
而且对应的外部存储资源，如 AWS EBS, GCE PD, Azure Disk, Cinder 卷也会一同被删除。
动态提供的卷的回收策略继承自 <a href="#reclaim-policy">它们的 StorageClass 的回收策略</a>，默认为 删除 (<code>Delete</code>)
管理应该根据用户期望设置 StorageClass 的回收策略，否则 PV 在创建后再需要再次修改才行。
见 <a href="/k8sDocs/tasks/administer-cluster/change-pv-reclaim-policy/">修改 PersistentVolume 的回收策略</a>.</p>
<!--
#### Recycle

<blockquote class="warning">
  <div><strong>警告：</strong> The <code>Recycle</code> reclaim policy is deprecated. Instead, the recommended approach is to use dynamic provisioning.</div>
</blockquote>


If supported by the underlying volume plugin, the `Recycle` reclaim policy performs a basic scrub (`rm -rf /thevolume/*`) on the volume and makes it available again for a new claim.

However, an administrator can configure a custom recycler Pod template using
the Kubernetes controller manager command line arguments as described in the
[reference](/docs/reference/command-line-tools-reference/kube-controller-manager/).
The custom recycler Pod template must contain a `volumes` specification, as
shown in the example below:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pv-recycler
  namespace: default
spec:
  restartPolicy: Never
  volumes:
  - name: vol
    hostPath:
      path: /any/path/it/will/be/replaced
  containers:
  - name: pv-recycler
    image: "k8s.gcr.io/busybox"
    command: ["/bin/sh", "-c", "test -e /scrub && rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  && test -z \"$(ls -A /scrub)\" || exit 1"]
    volumeMounts:
    - name: vol
      mountPath: /scrub
```

However, the particular path specified in the custom recycler Pod template in the `volumes` part is replaced with the particular path of the volume that is being recycled.
-->
<h4 id="循环使用recycle">循环使用(<code>Recycle</code>)</h4>
<blockquote class="warning">
  <div><strong>警告：</strong> 循环使用(<code>Recycle</code>) 回收策略已经废弃。 推荐使用动态供给方式。</div>
</blockquote>

<p>如果底层卷插件支持， 循环使用(<code>Recycle</code>) 回收策略在卷上执行基础的清理操作 (<code>rm -rf /thevolume/*</code>)
然后它就可以再次被新的 PVC 使用了。</p>
<p>但是，管理也可以使用 k8s 控制管理器的命令行参数配置一个自定义的回收器 Pod 模板。具体见
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/
">这里</a>.
这个自定义的回收器 Pod 模板必须要包含 <code>volumes</code> 定义，下面就是一个示例:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">pv-recycler</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">default</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">restartPolicy</span>: <span style="color:#ae81ff">Never</span>
  <span style="color:#f92672">volumes</span>:
  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">vol</span>
    <span style="color:#f92672">hostPath</span>:
      <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/any/path/it/will/be/replaced</span>
  <span style="color:#f92672">containers</span>:
  - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">pv-recycler</span>
    <span style="color:#f92672">image</span>: <span style="color:#e6db74">&#34;k8s.gcr.io/busybox&#34;</span>
    <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;/bin/sh&#34;</span>, <span style="color:#e6db74">&#34;-c&#34;</span>, <span style="color:#e6db74">&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]
    <span style="color:#f92672">volumeMounts</span>:
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">vol</span>
      <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/scrub</span>
</code></pre></div><p>回收器 Pod 模板中的 <code>volumes</code> 部分指定的路径，就是要被回收的卷</p>
<!--
### Reserving a PersistentVolume

The control plane can [bind PersistentVolumeClaims to matching PersistentVolumes](#binding) in the
cluster. However, if you want a PVC to bind to a specific PV, you need to pre-bind them.

By specifying a PersistentVolume in a PersistentVolumeClaim, you declare a binding between that specific PV and PVC.
If the PersistentVolume exists and has not reserved PersistentVolumeClaims through its `claimRef` field, then the PersistentVolume and PersistentVolumeClaim will be bound.

The binding happens regardless of some volume matching criteria, including node affinity.
The control plane still checks that [storage class](/docs/concepts/storage/storage-classes/), access modes, and requested storage size are valid.

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: foo-pvc
  namespace: foo
spec:
  storageClassName: "" # Empty string must be explicitly set otherwise default StorageClass will be set
  volumeName: foo-pv
  ...
```

This method does not guarantee any binding privileges to the PersistentVolume. If other PersistentVolumeClaims could use the PV that you specify, you first need to reserve that storage volume. Specify the relevant PersistentVolumeClaim in the `claimRef` field of the PV so that other PVCs can not bind to it.

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: foo-pv
spec:
  storageClassName: ""
  claimRef:
    name: foo-pvc
    namespace: foo
  ...
```

This is useful if you want to consume PersistentVolumes that have their `claimPolicy` set
to `Retain`, including cases where you are reusing an existing PV.
 -->
<h3 id="保留-persistentvolume">保留 <code>PersistentVolume</code></h3>
<p>控制中心可以在集群中将<a href="#binding"> <code>PersistentVolumeClaim</code> 与匹配的 <code>PersistentVolume</code> 绑定</a>。
但是，如果想要将 PVC 与指定 PV 绑定， 则需要预先绑定(而不是自动绑定)。</p>
<p>通过在 <code>PersistentVolumeClaim</code> 中指定一个 <code>PersistentVolume</code>，就可以将 PV 绑定到这个 PVC 上。
如果 PV 已经存在， 可能通过设置它的 <code>claimRef</code> 字段指定一个 <code>PersistentVolumeClaim</code>，
这样 PV 和 PVC 就会绑定。</p>
<p>这种绑定会忽略一些卷匹配条件，包括节点亲和性。 控制中心还是会检测，
<a href="/k8sDocs/concepts/storage/storage-classes/">StorageClass</a>, 访问模式，申请容量是否是有效的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">foo-pvc</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">foo</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">storageClassName</span>: <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#75715e"># 这里必须要显示地设置，否则就会使用默认的 StorageClass</span>
  <span style="color:#f92672">volumeName</span>: <span style="color:#ae81ff">foo-pv</span>
  <span style="color:#ae81ff">...</span>
</code></pre></div><p>这种方式不对绑定 PV 的优先级做任何保证。 如果其它的 PVC 能够使用过这个 PV，必须要先保留存储卷。
在需要绑定的 PV <code>claimRef</code> 的 PVC 这样其它的 PVC 才不能绑定这个 PV。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolume</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">foo-pv</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">storageClassName</span>: <span style="color:#e6db74">&#34;&#34;</span>
  <span style="color:#f92672">claimRef</span>:
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">foo-pvc</span>
    <span style="color:#f92672">namespace</span>: <span style="color:#ae81ff">foo</span>
  <span style="color:#ae81ff">...</span>
</code></pre></div><p>如果想要使用 <code>claimPolicy</code> 是 <code>Retain</code> 的 PV 这一招很有用， 包括重复使用那些已经存在的 PV。</p>
<!--
### Expanding Persistent Volumes Claims






<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.11 [beta]</code>
</div>



Support for expanding PersistentVolumeClaims (PVCs) is now enabled by default. You can expand
the following types of volumes:

* gcePersistentDisk
* awsElasticBlockStore
* Cinder
* glusterfs
* rbd
* Azure File
* Azure Disk
* Portworx
* FlexVolumes
* CSI

You can only expand a PVC if its storage class's `allowVolumeExpansion` field is set to true.

``` yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gluster-vol-default
provisioner: kubernetes.io/glusterfs
parameters:
  resturl: "http://192.168.10.100:8080"
  restuser: ""
  secretNamespace: ""
  secretName: ""
allowVolumeExpansion: true
```

To request a larger volume for a PVC, edit the PVC object and specify a larger
size. This triggers expansion of the volume that backs the underlying PersistentVolume. A
new PersistentVolume is never created to satisfy the claim. Instead, an existing volume is resized.
 -->
<h3 id="扩展-pvc">扩展 PVC</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.11 [beta]</code>
</div>


<p>对 PVC 的扩展默认是启用的。 可以对以下类型的卷进行扩展:</p>
<ul>
<li>gcePersistentDisk</li>
<li>awsElasticBlockStore</li>
<li>Cinder</li>
<li>glusterfs</li>
<li>rbd</li>
<li>Azure File</li>
<li>Azure Disk</li>
<li>Portworx</li>
<li>FlexVolumes</li>
<li>CSI</li>
</ul>
<p>只能对 StorageClass 的 <code>allowVolumeExpansion</code> 字段为 <code>true</code> PVC 进行扩展</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">storage.k8s.io/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">StorageClass</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">gluster-vol-default</span>
<span style="color:#f92672">provisioner</span>: <span style="color:#ae81ff">kubernetes.io/glusterfs</span>
<span style="color:#f92672">parameters</span>:
  <span style="color:#f92672">resturl</span>: <span style="color:#e6db74">&#34;http://192.168.10.100:8080&#34;</span>
  <span style="color:#f92672">restuser</span>: <span style="color:#e6db74">&#34;&#34;</span>
  <span style="color:#f92672">secretNamespace</span>: <span style="color:#e6db74">&#34;&#34;</span>
  <span style="color:#f92672">secretName</span>: <span style="color:#e6db74">&#34;&#34;</span>
<span style="color:#f92672">allowVolumeExpansion</span>: <span style="color:#66d9ef">true</span>
</code></pre></div><p>想要为 PVC 申请一个更大的卷，只需要修改 PVC 对象，设置一个更大的容量。 这会触发卷底层的 PV 的扩充。
这样做不会创建一个新的 PV 来满足这个 PVC， 而是通过修改原来的容量来实现。</p>
<!--
#### CSI Volume expansion






<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.16 [beta]</code>
</div>



Support for expanding CSI volumes is enabled by default but it also requires a specific CSI driver to support volume expansion. Refer to documentation of the specific CSI driver for more information.
 -->
<h4 id="csi-卷扩容">CSI 卷扩容</h4>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.16 [beta]</code>
</div>


<p>对 CSI 卷扩展 扩容默认是开启的，但也是需要相应的 CSI 驱动支持卷扩容。 具体信息请参阅相应
CSI 驱动的文档。</p>
<!--
#### Resizing a volume containing a file system

You can only resize volumes containing a file system if the file system is XFS, Ext3, or Ext4.

When a volume contains a file system, the file system is only resized when a new Pod is using
the PersistentVolumeClaim in `ReadWrite` mode. File system expansion is either done when a Pod is starting up
or when a Pod is running and the underlying file system supports online expansion.

FlexVolumes allow resize if the driver is set with the `RequiresFSResize` capability to `true`.
The FlexVolume can be resized on Pod restart.
 -->
<h4 id="修改包含文件系统的卷的容量">修改包含文件系统的卷的容量</h4>
<p>如果郑文件系统是  XFS, Ext3, Ext4 之一，则可以修改其容量。</p>
<p>当卷中包含文件文件系统时，只有在
新的 Pod 使用 <code>ReadWrite</code> 模式的 PVC 时才会变更容量。文件系统的扩容只有在 Pod 启动或
正在运行的 Pod 底层的文件系统支持在线扩容时才能生效。</p>
<p>FlexVolume 允许在 驱动的 <code>RequiresFSResize</code> 设置为 <code>true</code> 时变更容量。
FlexVolume 的容量变更只能在 Pod 重启时生效。</p>
<!--
#### Resizing an in-use PersistentVolumeClaim






<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.15 [beta]</code>
</div>



<blockquote class="note">
  <div><strong>说明：</strong> Expanding in-use PVCs is available as beta since Kubernetes 1.15, and as alpha since 1.11. The <code>ExpandInUsePersistentVolumes</code> feature must be enabled, which is the case automatically for many clusters for beta features. Refer to the <a href="/docs/reference/command-line-tools-reference/feature-gates/">feature gate</a> documentation for more information.</div>
</blockquote>


In this case, you don't need to delete and recreate a Pod or deployment that is using an existing PVC.
Any in-use PVC automatically becomes available to its Pod as soon as its file system has been expanded.
This feature has no effect on PVCs that are not in use by a Pod or deployment. You must create a Pod that
uses the PVC before the expansion can complete.


Similar to other volume types - FlexVolume volumes can also be expanded when in-use by a Pod.

<blockquote class="note">
  <div><strong>说明：</strong> FlexVolume resize is possible only when the underlying driver supports resize.</div>
</blockquote>


<blockquote class="note">
  <div><strong>说明：</strong> Expanding EBS volumes is a time-consuming operation. Also, there is a per-volume quota of one modification every 6 hours.</div>
</blockquote>

 -->
<h4 id="对使用中的-persistentvolumeclaim-变更容量">对使用中的 PersistentVolumeClaim 变更容量</h4>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.15 [beta]</code>
</div>


<blockquote class="note">
  <div><strong>说明：</strong> 对使用中的 PersistentVolumeClaim 变更容量 在 k8s <code>v1.15</code> 是 <code>beta</code> 状态，
<code>v1.11</code> 是 <code>alpha</code> 状态, <code>ExpandInUsePersistentVolumes</code> 在 <code>beta</code> 时是默认打开的。
更多信息请见
<a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/">功能阀</a></div>
</blockquote>

<p>在这种情况下，不需要删除或重新创建使用现有 PVC 的 Pod 或 Deployment. 任意使用中的 PVC 在
文件系统扩容后在 Pod 中自动变得可用。 这个特性对那些没有被 Pod 或 Deployment 的 PVC 无效。
要想扩容生效必须要有一个使用 PVC 的 Pod。</p>
<p>与其它的卷类型类似， FlexVolume 也可以在被 Pod 使用时扩容。
<blockquote class="note">
  <div><strong>说明：</strong> FlexVolume 变量容量只能在底层驱动支持的情况下才行。</div>
</blockquote>
</p>
<blockquote class="note">
  <div><strong>说明：</strong> 对 EBS 卷扩容是一个耗时的操作。并且还有一个每个卷每 6 个小时只能扩容的限制</div>
</blockquote>

<!--
#### Recovering from Failure when Expanding Volumes

If expanding underlying storage fails, the cluster administrator can manually recover the Persistent Volume Claim (PVC) state and cancel the resize requests. Otherwise, the resize requests are continuously retried by the controller without administrator intervention.

1. Mark the PersistentVolume(PV) that is bound to the PersistentVolumeClaim(PVC) with `Retain` reclaim policy.
2. Delete the PVC. Since PV has `Retain` reclaim policy - we will not lose any data when we recreate the PVC.
3. Delete the `claimRef` entry from PV specs, so as new PVC can bind to it. This should make the PV `Available`.
4. Re-create the PVC with smaller size than PV and set `volumeName` field of the PVC to the name of the PV. This should bind new PVC to existing PV.
5. Don't forget to restore the reclaim policy of the PV.
 -->
<h4 id="从卷扩展失败中恢复">从卷扩展失败中恢复</h4>
<p>如果底层存储扩容的失败，集群管理可以通过手动恢复 PVC 的状态，取消扩容请求。否则，在没管理员中止
的情况下控制器会不断地重试容量变更请求。</p>
<ol>
<li>将与 PersistentVolumeClaim(PVC) 绑定的 PersistentVolume(PV) 回收策略改为 <code>Retain</code></li>
<li>删除 PVC。 因为 PV 的回收策略是 <code>Retain</code>，所以在重新创建 PVC 之前数据不会丢失。</li>
<li>删除 PV 对象中的 <code>claimRef</code> 实体， 这样新的 PVC 才可以与它绑定， 可以可以将 PV 变为 <code>Available</code></li>
<li>以小于 PV 的容量重新创建一个 PVC，这个 PVC 的 <code>volumeName</code> 设置 PV 的名称。这样就可以将
原来的 PV 绑定到新的 PVC 上</li>
<li>不要忘记将 PV 的回收策略也改加原来的值</li>
</ol>
<h2 id="types-of-persistent-volumes">Types of Persistent Volumes</h2>
<p>PersistentVolume types are implemented as plugins.  Kubernetes currently supports the following plugins:</p>
<ul>
<li>GCEPersistentDisk</li>
<li>AWSElasticBlockStore</li>
<li>AzureFile</li>
<li>AzureDisk</li>
<li>CSI</li>
<li>FC (Fibre Channel)</li>
<li>FlexVolume</li>
<li>Flocker</li>
<li>NFS</li>
<li>iSCSI</li>
<li>RBD (Ceph Block Device)</li>
<li>CephFS</li>
<li>Cinder (OpenStack block storage)</li>
<li>Glusterfs</li>
<li>VsphereVolume</li>
<li>Quobyte Volumes</li>
<li>HostPath (Single node testing only &ndash; local storage is not supported in any way and WILL NOT WORK in a multi-node cluster)</li>
<li>Portworx Volumes</li>
<li>ScaleIO Volumes</li>
<li>StorageOS</li>
</ul>
<h2 id="persistent-volumes">Persistent Volumes</h2>
<p>Each PV contains a spec and status, which is the specification and status of the volume.
The name of a PersistentVolume object must be a valid
<a href="/docs/concepts/overview/working-with-objects/names#dns-subdomain-names">DNS subdomain name</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolume</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">pv0003</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">capacity</span>:
    <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">5Gi</span>
  <span style="color:#f92672">volumeMode</span>: <span style="color:#ae81ff">Filesystem</span>
  <span style="color:#f92672">accessModes</span>:
    - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">persistentVolumeReclaimPolicy</span>: <span style="color:#ae81ff">Recycle</span>
  <span style="color:#f92672">storageClassName</span>: <span style="color:#ae81ff">slow</span>
  <span style="color:#f92672">mountOptions</span>:
    - <span style="color:#ae81ff">hard</span>
    - <span style="color:#ae81ff">nfsvers=4.1</span>
  <span style="color:#f92672">nfs</span>:
    <span style="color:#f92672">path</span>: <span style="color:#ae81ff">/tmp</span>
    <span style="color:#f92672">server</span>: <span style="color:#ae81ff">172.17.0.2</span>
</code></pre></div><blockquote class="note">
  <div><strong>说明：</strong> Helper programs relating to the volume type may be required for consumption of a PersistentVolume within a cluster.  In this example, the PersistentVolume is of type NFS and the helper program /sbin/mount.nfs is required to support the mounting of NFS filesystems.</div>
</blockquote>

<h3 id="capacity">Capacity</h3>
<p>Generally, a PV will have a specific storage capacity.  This is set using the PV&rsquo;s <code>capacity</code> attribute.  See the Kubernetes <a href="https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md">Resource Model</a> to understand the units expected by <code>capacity</code>.</p>
<p>Currently, storage size is the only resource that can be set or requested.  Future attributes may include IOPS, throughput, etc.</p>
<h3 id="volume-mode">Volume Mode</h3>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.18 [stable]</code>
</div>


<p>Kubernetes supports two <code>volumeModes</code> of PersistentVolumes: <code>Filesystem</code> and <code>Block</code>.</p>
<p><code>volumeMode</code> is an optional API parameter.
<code>Filesystem</code> is the default mode used when <code>volumeMode</code> parameter is omitted.</p>
<p>A volume with <code>volumeMode: Filesystem</code> is <em>mounted</em> into Pods into a directory. If the volume
is backed by a block device and the device is empty, Kuberneretes creates a filesystem
on the device before mounting it for the first time.</p>
<p>You can set the value of <code>volumeMode</code> to <code>Block</code> to use a volume as a raw block device.
Such volume is presented into a Pod as a block device, without any filesystem on it.
This mode is useful to provide a Pod the fastest possible way to access a volume, without
any filesystem layer between the Pod and the volume. On the other hand, the application
running in the Pod must know how to handle a raw block device.
See <a href="#raw-block-volume-support">Raw Block Volume Support</a>
for an example on how to use a volume with <code>volumeMode: Block</code> in a Pod.</p>
<h3 id="access-modes">Access Modes</h3>
<p>A PersistentVolume can be mounted on a host in any way supported by the resource provider. As shown in the table below, providers will have different capabilities and each PV&rsquo;s access modes are set to the specific modes supported by that particular volume.  For example, NFS can support multiple read/write clients, but a specific NFS PV might be exported on the server as read-only. Each PV gets its own set of access modes describing that specific PV&rsquo;s capabilities.</p>
<p>The access modes are:</p>
<ul>
<li>ReadWriteOnce &ndash; the volume can be mounted as read-write by a single node</li>
<li>ReadOnlyMany &ndash; the volume can be mounted read-only by many nodes</li>
<li>ReadWriteMany &ndash; the volume can be mounted as read-write by many nodes</li>
</ul>
<p>In the CLI, the access modes are abbreviated to:</p>
<ul>
<li>RWO - ReadWriteOnce</li>
<li>ROX - ReadOnlyMany</li>
<li>RWX - ReadWriteMany</li>
</ul>
<blockquote>
<p><strong>Important!</strong> A volume can only be mounted using one access mode at a time, even if it supports many.  For example, a GCEPersistentDisk can be mounted as ReadWriteOnce by a single node or ReadOnlyMany by many nodes, but not at the same time.</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">Volume Plugin</th>
<th style="text-align:center">ReadWriteOnce</th>
<th style="text-align:center">ReadOnlyMany</th>
<th style="text-align:center">ReadWriteMany</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AWSElasticBlockStore</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">AzureFile</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:left">AzureDisk</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">CephFS</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:left">Cinder</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">CSI</td>
<td style="text-align:center">depends on the driver</td>
<td style="text-align:center">depends on the driver</td>
<td style="text-align:center">depends on the driver</td>
</tr>
<tr>
<td style="text-align:left">FC</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">FlexVolume</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">depends on the driver</td>
</tr>
<tr>
<td style="text-align:left">Flocker</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">GCEPersistentDisk</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">Glusterfs</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:left">HostPath</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">iSCSI</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">Quobyte</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:left">NFS</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:left">RBD</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">VsphereVolume</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
<td style="text-align:center">- (works when Pods are collocated)</td>
</tr>
<tr>
<td style="text-align:left">PortworxVolume</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:left">ScaleIO</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:left">StorageOS</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h3 id="class">Class</h3>
<p>A PV can have a class, which is specified by setting the
<code>storageClassName</code> attribute to the name of a
<a href="/docs/concepts/storage/storage-classes/">StorageClass</a>.
A PV of a particular class can only be bound to PVCs requesting
that class. A PV with no <code>storageClassName</code> has no class and can only be bound
to PVCs that request no particular class.</p>
<p>In the past, the annotation <code>volume.beta.kubernetes.io/storage-class</code> was used instead
of the <code>storageClassName</code> attribute. This annotation is still working; however,
it will become fully deprecated in a future Kubernetes release.</p>
<!--
### Reclaim Policy

Current reclaim policies are:

* Retain -- manual reclamation
* Recycle -- basic scrub (`rm -rf /thevolume/*`)
* Delete -- associated storage asset such as AWS EBS, GCE PD, Azure Disk, or OpenStack Cinder volume is deleted

Currently, only NFS and HostPath support recycling. AWS EBS, GCE PD, Azure Disk, and Cinder volumes support deletion.
 -->
<h3 id="reclain-policy">回收策略</h3>
<p>Current reclaim policies are:</p>
<ul>
<li>Retain &ndash; manual reclamation</li>
<li>Recycle &ndash; basic scrub (<code>rm -rf /thevolume/*</code>)</li>
<li>Delete &ndash; associated storage asset such as AWS EBS, GCE PD, Azure Disk, or OpenStack Cinder volume is deleted</li>
</ul>
<p>Currently, only NFS and HostPath support recycling. AWS EBS, GCE PD, Azure Disk, and Cinder volumes support deletion.</p>
<h3 id="mount-options">Mount Options</h3>
<p>A Kubernetes administrator can specify additional mount options for when a Persistent Volume is mounted on a node.</p>
<blockquote class="note">
  <div><strong>说明：</strong> Not all Persistent Volume types support mount options.</div>
</blockquote>

<p>The following volume types support mount options:</p>
<ul>
<li>AWSElasticBlockStore</li>
<li>AzureDisk</li>
<li>AzureFile</li>
<li>CephFS</li>
<li>Cinder (OpenStack block storage)</li>
<li>GCEPersistentDisk</li>
<li>Glusterfs</li>
<li>NFS</li>
<li>Quobyte Volumes</li>
<li>RBD (Ceph Block Device)</li>
<li>StorageOS</li>
<li>VsphereVolume</li>
<li>iSCSI</li>
</ul>
<p>Mount options are not validated, so mount will simply fail if one is invalid.</p>
<p>In the past, the annotation <code>volume.beta.kubernetes.io/mount-options</code> was used instead
of the <code>mountOptions</code> attribute. This annotation is still working; however,
it will become fully deprecated in a future Kubernetes release.</p>
<h3 id="node-affinity">Node Affinity</h3>
<blockquote class="note">
  <div><strong>说明：</strong> For most volume types, you do not need to set this field. It is automatically populated for <a href="/docs/concepts/storage/volumes/#awselasticblockstore">AWS EBS</a>, <a href="/docs/concepts/storage/volumes/#gcepersistentdisk">GCE PD</a> and <a href="/docs/concepts/storage/volumes/#azuredisk">Azure Disk</a> volume block types. You need to explicitly set this for <a href="/docs/concepts/storage/volumes/#local">local</a> volumes.</div>
</blockquote>

<p>A PV can specify <a href="/docs/reference/generated/kubernetes-api/v1.19/#volumenodeaffinity-v1-core">node affinity</a> to define constraints that limit what nodes this volume can be accessed from. Pods that use a PV will only be scheduled to nodes that are selected by the node affinity.</p>
<h3 id="phase">Phase</h3>
<p>A volume will be in one of the following phases:</p>
<ul>
<li>Available &ndash; a free resource that is not yet bound to a claim</li>
<li>Bound &ndash; the volume is bound to a claim</li>
<li>Released &ndash; the claim has been deleted, but the resource is not yet reclaimed by the cluster</li>
<li>Failed &ndash; the volume has failed its automatic reclamation</li>
</ul>
<p>The CLI will show the name of the PVC bound to the PV.</p>
<h2 id="persistentvolumeclaims">PersistentVolumeClaims</h2>
<p>Each PVC contains a spec and status, which is the specification and status of the claim.
The name of a PersistentVolumeClaim object must be a valid
<a href="/docs/concepts/overview/working-with-objects/names#dns-subdomain-names">DNS subdomain name</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">myclaim</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">accessModes</span>:
    - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">volumeMode</span>: <span style="color:#ae81ff">Filesystem</span>
  <span style="color:#f92672">resources</span>:
    <span style="color:#f92672">requests</span>:
      <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">8Gi</span>
  <span style="color:#f92672">storageClassName</span>: <span style="color:#ae81ff">slow</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">release</span>: <span style="color:#e6db74">&#34;stable&#34;</span>
    <span style="color:#f92672">matchExpressions</span>:
      - {<span style="color:#f92672">key: environment, operator: In, values</span>: [<span style="color:#ae81ff">dev]}</span>
</code></pre></div><h3 id="access-modes-1">Access Modes</h3>
<p>Claims use the same conventions as volumes when requesting storage with specific access modes.</p>
<h3 id="volume-modes">Volume Modes</h3>
<p>Claims use the same convention as volumes to indicate the consumption of the volume as either a filesystem or block device.</p>
<h3 id="resources">Resources</h3>
<p>Claims, like Pods, can request specific quantities of a resource. In this case, the request is for storage. The same <a href="https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md">resource model</a> applies to both volumes and claims.</p>
<h3 id="selector">Selector</h3>
<p>Claims can specify a <a href="/docs/concepts/overview/working-with-objects/labels/#label-selectors">label selector</a> to further filter the set of volumes. Only the volumes whose labels match the selector can be bound to the claim. The selector can consist of two fields:</p>
<ul>
<li><code>matchLabels</code> - the volume must have a label with this value</li>
<li><code>matchExpressions</code> - a list of requirements made by specifying key, list of values, and operator that relates the key and values. Valid operators include In, NotIn, Exists, and DoesNotExist.</li>
</ul>
<p>All of the requirements, from both <code>matchLabels</code> and <code>matchExpressions</code>, are ANDed together – they must all be satisfied in order to match.</p>
<h3 id="class-1">Class</h3>
<p>A claim can request a particular class by specifying the name of a
<a href="/docs/concepts/storage/storage-classes/">StorageClass</a>
using the attribute <code>storageClassName</code>.
Only PVs of the requested class, ones with the same <code>storageClassName</code> as the PVC, can
be bound to the PVC.</p>
<p>PVCs don&rsquo;t necessarily have to request a class. A PVC with its <code>storageClassName</code> set
equal to <code>&quot;&quot;</code> is always interpreted to be requesting a PV with no class, so it
can only be bound to PVs with no class (no annotation or one set equal to
<code>&quot;&quot;</code>). A PVC with no <code>storageClassName</code> is not quite the same and is treated differently
by the cluster, depending on whether the
<a href="/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass"><code>DefaultStorageClass</code> admission plugin</a>
is turned on.</p>
<ul>
<li>If the admission plugin is turned on, the administrator may specify a
default StorageClass. All PVCs that have no <code>storageClassName</code> can be bound only to
PVs of that default. Specifying a default StorageClass is done by setting the
annotation <code>storageclass.kubernetes.io/is-default-class</code> equal to <code>true</code> in
a StorageClass object. If the administrator does not specify a default, the
cluster responds to PVC creation as if the admission plugin were turned off. If
more than one default is specified, the admission plugin forbids the creation of
all PVCs.</li>
<li>If the admission plugin is turned off, there is no notion of a default
StorageClass. All PVCs that have no <code>storageClassName</code> can be bound only to PVs that
have no class. In this case, the PVCs that have no <code>storageClassName</code> are treated the
same way as PVCs that have their <code>storageClassName</code> set to <code>&quot;&quot;</code>.</li>
</ul>
<p>Depending on installation method, a default StorageClass may be deployed
to a Kubernetes cluster by addon manager during installation.</p>
<p>When a PVC specifies a <code>selector</code> in addition to requesting a StorageClass,
the requirements are ANDed together: only a PV of the requested class and with
the requested labels may be bound to the PVC.</p>
<blockquote class="note">
  <div><strong>说明：</strong> Currently, a PVC with a non-empty <code>selector</code> can&rsquo;t have a PV dynamically provisioned for it.</div>
</blockquote>

<p>In the past, the annotation <code>volume.beta.kubernetes.io/storage-class</code> was used instead
of <code>storageClassName</code> attribute. This annotation is still working; however,
it won&rsquo;t be supported in a future Kubernetes release.</p>
<!--
## Claims As Volumes

Pods access storage by using the claim as a volume. Claims must exist in the same namespace as the Pod using the claim. The cluster finds the claim in the Pod's namespace and uses it to get the PersistentVolume backing the claim. The volume is then mounted to the host and into the Pod.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: nginx
      volumeMounts:
      - mountPath: "/var/www/html"
        name: mypd
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: myclaim
```
 -->
<h2 id="claims-as-volumes">将 PVC 当作卷(PV)</h2>
<p>Pods access storage by using the claim as a volume. Claims must exist in the same namespace as the Pod using the claim. The cluster finds the claim in the Pod&rsquo;s namespace and uses it to get the PersistentVolume backing the claim. The volume is then mounted to the host and into the Pod.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">mypod</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">containers</span>:
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">myfrontend</span>
      <span style="color:#f92672">image</span>: <span style="color:#ae81ff">nginx</span>
      <span style="color:#f92672">volumeMounts</span>:
      - <span style="color:#f92672">mountPath</span>: <span style="color:#e6db74">&#34;/var/www/html&#34;</span>
        <span style="color:#f92672">name</span>: <span style="color:#ae81ff">mypd</span>
  <span style="color:#f92672">volumes</span>:
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">mypd</span>
      <span style="color:#f92672">persistentVolumeClaim</span>:
        <span style="color:#f92672">claimName</span>: <span style="color:#ae81ff">myclaim</span>
</code></pre></div><h3 id="a-note-on-namespaces">A Note on Namespaces</h3>
<p>PersistentVolumes binds are exclusive, and since PersistentVolumeClaims are namespaced objects, mounting claims with &ldquo;Many&rdquo; modes (<code>ROX</code>, <code>RWX</code>) is only possible within one namespace.</p>
<h2 id="raw-block-volume-support">Raw Block Volume Support</h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.18 [stable]</code>
</div>


<p>The following volume plugins support raw block volumes, including dynamic provisioning where
applicable:</p>
<ul>
<li>AWSElasticBlockStore</li>
<li>AzureDisk</li>
<li>CSI</li>
<li>FC (Fibre Channel)</li>
<li>GCEPersistentDisk</li>
<li>iSCSI</li>
<li>Local volume</li>
<li>OpenStack Cinder</li>
<li>RBD (Ceph Block Device)</li>
<li>VsphereVolume</li>
</ul>
<h3 id="persistent-volume-using-a-raw-block-volume">PersistentVolume using a Raw Block Volume</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolume</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">block-pv</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">capacity</span>:
    <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">10Gi</span>
  <span style="color:#f92672">accessModes</span>:
    - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">volumeMode</span>: <span style="color:#ae81ff">Block</span>
  <span style="color:#f92672">persistentVolumeReclaimPolicy</span>: <span style="color:#ae81ff">Retain</span>
  <span style="color:#f92672">fc</span>:
    <span style="color:#f92672">targetWWNs</span>: [<span style="color:#e6db74">&#34;50060e801049cfd1&#34;</span>]
    <span style="color:#f92672">lun</span>: <span style="color:#ae81ff">0</span>
    <span style="color:#f92672">readOnly</span>: <span style="color:#66d9ef">false</span>
</code></pre></div><h3 id="persistent-volume-claim-requesting-a-raw-block-volume">PersistentVolumeClaim requesting a Raw Block Volume</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">block-pvc</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">accessModes</span>:
    - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">volumeMode</span>: <span style="color:#ae81ff">Block</span>
  <span style="color:#f92672">resources</span>:
    <span style="color:#f92672">requests</span>:
      <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">10Gi</span>
</code></pre></div><h3 id="pod-specification-adding-raw-block-device-path-in-container">Pod specification adding Raw Block Device path in container</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Pod</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">pod-with-block-volume</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">containers</span>:
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">fc-container</span>
      <span style="color:#f92672">image</span>: <span style="color:#ae81ff">fedora:26</span>
      <span style="color:#f92672">command</span>: [<span style="color:#e6db74">&#34;/bin/sh&#34;</span>, <span style="color:#e6db74">&#34;-c&#34;</span>]
      <span style="color:#f92672">args</span>: [ <span style="color:#e6db74">&#34;tail -f /dev/null&#34;</span> ]
      <span style="color:#f92672">volumeDevices</span>:
        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">data</span>
          <span style="color:#f92672">devicePath</span>: <span style="color:#ae81ff">/dev/xvda</span>
  <span style="color:#f92672">volumes</span>:
    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">data</span>
      <span style="color:#f92672">persistentVolumeClaim</span>:
        <span style="color:#f92672">claimName</span>: <span style="color:#ae81ff">block-pvc</span>
</code></pre></div><blockquote class="note">
  <div><strong>说明：</strong> When adding a raw block device for a Pod, you specify the device path in the container instead of a mount path.</div>
</blockquote>

<h3 id="binding-block-volumes">Binding Block Volumes</h3>
<p>If a user requests a raw block volume by indicating this using the <code>volumeMode</code> field in the PersistentVolumeClaim spec, the binding rules differ slightly from previous releases that didn&rsquo;t consider this mode as part of the spec.
Listed is a table of possible combinations the user and admin might specify for requesting a raw block device. The table indicates if the volume will be bound or not given the combinations:
Volume binding matrix for statically provisioned volumes:</p>
<table>
<thead>
<tr>
<th>PV volumeMode</th>
<th style="text-align:center">PVC volumeMode</th>
<th style="text-align:right">Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>unspecified</td>
<td style="text-align:center">unspecified</td>
<td style="text-align:right">BIND</td>
</tr>
<tr>
<td>unspecified</td>
<td style="text-align:center">Block</td>
<td style="text-align:right">NO BIND</td>
</tr>
<tr>
<td>unspecified</td>
<td style="text-align:center">Filesystem</td>
<td style="text-align:right">BIND</td>
</tr>
<tr>
<td>Block</td>
<td style="text-align:center">unspecified</td>
<td style="text-align:right">NO BIND</td>
</tr>
<tr>
<td>Block</td>
<td style="text-align:center">Block</td>
<td style="text-align:right">BIND</td>
</tr>
<tr>
<td>Block</td>
<td style="text-align:center">Filesystem</td>
<td style="text-align:right">NO BIND</td>
</tr>
<tr>
<td>Filesystem</td>
<td style="text-align:center">Filesystem</td>
<td style="text-align:right">BIND</td>
</tr>
<tr>
<td>Filesystem</td>
<td style="text-align:center">Block</td>
<td style="text-align:right">NO BIND</td>
</tr>
<tr>
<td>Filesystem</td>
<td style="text-align:center">unspecified</td>
<td style="text-align:right">BIND</td>
</tr>
</tbody>
</table>
<blockquote class="note">
  <div><strong>说明：</strong> Only statically provisioned volumes are supported for alpha release. Administrators should take care to consider these values when working with raw block devices.</div>
</blockquote>

<h2 id="volume-snapshot-and-restore-volume-from-snapshot-support">Volume Snapshot and Restore Volume from Snapshot Support</h2>





<div style="margin-top: 10px; margin-bottom: 10px;">
<b>功能特性状态:</b> <code>Kubernetes v1.17 [beta]</code>
</div>


<p>Volume snapshot feature was added to support CSI Volume Plugins only. For details, see <a href="/docs/concepts/storage/volume-snapshots/">volume snapshots</a>.</p>
<p>To enable support for restoring a volume from a volume snapshot data source, enable the
<code>VolumeSnapshotDataSource</code> feature gate on the apiserver and controller-manager.</p>
<h3 id="create-persistent-volume-claim-from-volume-snapshot">Create a PersistentVolumeClaim from a Volume Snapshot</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">restore-pvc</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">storageClassName</span>: <span style="color:#ae81ff">csi-hostpath-sc</span>
  <span style="color:#f92672">dataSource</span>:
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">new-snapshot-test</span>
    <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">VolumeSnapshot</span>
    <span style="color:#f92672">apiGroup</span>: <span style="color:#ae81ff">snapshot.storage.k8s.io</span>
  <span style="color:#f92672">accessModes</span>:
    - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">resources</span>:
    <span style="color:#f92672">requests</span>:
      <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">10Gi</span>
</code></pre></div><h2 id="volume-cloning">Volume Cloning</h2>
<p><a href="/docs/concepts/storage/volume-pvc-datasource/">Volume Cloning</a> only available for CSI volume plugins.</p>
<h3 id="create-persistent-volume-claim-from-an-existing-pvc">Create PersistentVolumeClaim from an existing PVC</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">cloned-pvc</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">storageClassName</span>: <span style="color:#ae81ff">my-csi-plugin</span>
  <span style="color:#f92672">dataSource</span>:
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">existing-src-pvc-name</span>
    <span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
  <span style="color:#f92672">accessModes</span>:
    - <span style="color:#ae81ff">ReadWriteOnce</span>
  <span style="color:#f92672">resources</span>:
    <span style="color:#f92672">requests</span>:
      <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">10Gi</span>
</code></pre></div><h2 id="writing-portable-configuration">Writing Portable Configuration</h2>
<p>If you&rsquo;re writing configuration templates or examples that run on a wide range of clusters
and need persistent storage, it is recommended that you use the following pattern:</p>
<ul>
<li>
<p>Include PersistentVolumeClaim objects in your bundle of config (alongside
Deployments, ConfigMaps, etc).</p>
</li>
<li>
<p>Do not include PersistentVolume objects in the config, since the user instantiating
the config may not have permission to create PersistentVolumes.</p>
</li>
<li>
<p>Give the user the option of providing a storage class name when instantiating
the template.</p>
<ul>
<li>If the user provides a storage class name, put that value into the
<code>persistentVolumeClaim.storageClassName</code> field.
This will cause the PVC to match the right storage
class if the cluster has StorageClasses enabled by the admin.</li>
<li>If the user does not provide a storage class name, leave the
<code>persistentVolumeClaim.storageClassName</code> field as nil. This will cause a
PV to be automatically provisioned for the user with the default StorageClass
in the cluster. Many cluster environments have a default StorageClass installed,
or administrators can create their own default StorageClass.</li>
</ul>
</li>
<li>
<p>In your tooling, watch for PVCs that are not getting bound after some time
and surface this to the user, as this may indicate that the cluster has no
dynamic storage support (in which case the user should create a matching PV)
or the cluster has no storage system (in which case the user cannot deploy
config requiring PVCs).</p>
<h2 id="相关资料">相关资料</h2>
</li>
</ul>
<ul>
<li>Learn more about <a href="/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume">Creating a PersistentVolume</a>.</li>
<li>Learn more about <a href="/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim">Creating a PersistentVolumeClaim</a>.</li>
<li>Read the <a href="https://git.k8s.io/community/contributors/design-proposals/storage/persistent-storage.md">Persistent Storage design document</a>.</li>
</ul>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="/docs/reference/generated/kubernetes-api/v1.19/#persistentvolume-v1-core">PersistentVolume</a></li>
<li><a href="/docs/reference/generated/kubernetes-api/v1.19/#persistentvolumespec-v1-core">PersistentVolumeSpec</a></li>
<li><a href="/docs/reference/generated/kubernetes-api/v1.19/#persistentvolumeclaim-v1-core">PersistentVolumeClaim</a></li>
<li><a href="/docs/reference/generated/kubernetes-api/v1.19/#persistentvolumeclaimspec-v1-core">PersistentVolumeClaimSpec</a></li>
</ul>



            
            <div class="text-muted mt-5 pt-3 border-top">最后修改 January 1, 0001
</div>
            
          </main>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
            











<nav id="TableOfContents">
  <ul>
    <li><a href="#介绍">介绍</a></li>
    <li><a href="#pv-和-pvc-的生命周期">PV 和 PVC 的生命周期</a>
      <ul>
        <li><a href="#供给">供给</a></li>
        <li><a href="#binding">绑定</a></li>
        <li><a href="#使用">使用</a></li>
        <li><a href="#使用保护模式的存储对象">使用保护模式的存储对象</a></li>
        <li><a href="#回收">回收</a></li>
        <li><a href="#保留-persistentvolume">保留 <code>PersistentVolume</code></a></li>
        <li><a href="#扩展-pvc">扩展 PVC</a></li>
      </ul>
    </li>
    <li><a href="#types-of-persistent-volumes">Types of Persistent Volumes</a></li>
    <li><a href="#persistent-volumes">Persistent Volumes</a>
      <ul>
        <li><a href="#capacity">Capacity</a></li>
        <li><a href="#volume-mode">Volume Mode</a></li>
        <li><a href="#access-modes">Access Modes</a></li>
        <li><a href="#class">Class</a></li>
        <li><a href="#reclain-policy">回收策略</a></li>
        <li><a href="#mount-options">Mount Options</a></li>
        <li><a href="#node-affinity">Node Affinity</a></li>
        <li><a href="#phase">Phase</a></li>
      </ul>
    </li>
    <li><a href="#persistentvolumeclaims">PersistentVolumeClaims</a>
      <ul>
        <li><a href="#access-modes-1">Access Modes</a></li>
        <li><a href="#volume-modes">Volume Modes</a></li>
        <li><a href="#resources">Resources</a></li>
        <li><a href="#selector">Selector</a></li>
        <li><a href="#class-1">Class</a></li>
      </ul>
    </li>
    <li><a href="#claims-as-volumes">将 PVC 当作卷(PV)</a>
      <ul>
        <li><a href="#a-note-on-namespaces">A Note on Namespaces</a></li>
      </ul>
    </li>
    <li><a href="#raw-block-volume-support">Raw Block Volume Support</a>
      <ul>
        <li><a href="#persistent-volume-using-a-raw-block-volume">PersistentVolume using a Raw Block Volume</a></li>
        <li><a href="#persistent-volume-claim-requesting-a-raw-block-volume">PersistentVolumeClaim requesting a Raw Block Volume</a></li>
        <li><a href="#pod-specification-adding-raw-block-device-path-in-container">Pod specification adding Raw Block Device path in container</a></li>
        <li><a href="#binding-block-volumes">Binding Block Volumes</a></li>
      </ul>
    </li>
    <li><a href="#volume-snapshot-and-restore-volume-from-snapshot-support">Volume Snapshot and Restore Volume from Snapshot Support</a>
      <ul>
        <li><a href="#create-persistent-volume-claim-from-volume-snapshot">Create a PersistentVolumeClaim from a Volume Snapshot</a></li>
      </ul>
    </li>
    <li><a href="#volume-cloning">Volume Cloning</a>
      <ul>
        <li><a href="#create-persistent-volume-claim-from-an-existing-pvc">Create PersistentVolumeClaim from an existing PVC</a></li>
      </ul>
    </li>
    <li><a href="#writing-portable-configuration">Writing Portable Configuration</a></li>
    <li><a href="#相关资料">相关资料</a>
      <ul>
        <li><a href="#reference">Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>



          </div>
        </div>
      </div>
      
<footer class="bg-dark py-5 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">
        
      </div>
      <div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
        
      </div>
      <div class="col-12 col-sm-4 text-center py-2 order-sm-2">
        
        
	
		
	
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>











<script src="/k8sDocs/js/main.min.446a2e681f8167f44314691b77368dd561bf0b67514487f3f0fd999316c6da4a.js" integrity="sha256-RGouaB&#43;BZ/RDFGkbdzaN1WG/C2dRRIfz8P2ZkxbG2ko=" crossorigin="anonymous"></script>




  </body>
</html>