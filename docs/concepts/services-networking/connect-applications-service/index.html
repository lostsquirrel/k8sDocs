<!doctype html>
<html lang="zh" class="no-js">
  <head>
    



<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.75.1" />

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">

<link rel="shortcut icon" type="image/png" href="/k8sDocs/images/favicon.png">
<link rel="apple-touch-icon" href="/k8sDocs/favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="manifest" href="/k8sDocs/manifest.webmanifest">
<link rel="apple-touch-icon" href="/k8sDocs/images/kubernetes-192x192.png">

<title>通过 Service 连接应用 | Kubernetes</title><meta property="og:title" content="通过 Service 连接应用" />
<meta property="og:description" content="连接到容器的 k8s 模型 到目前为止我们有一个持续运行的多副本应用，我们可以把它暴露到一个网络中。 在讨论 k8s 的网络实现前， 值得花点时间来看看 Docker 中普通的" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lostsquirrel.github.io/k8sDocs/docs/concepts/services-networking/connect-applications-service/" />
<meta property="article:published_time" content="2020-09-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-12-22T15:20:17+08:00" /><meta property="og:site_name" content="Kubernetes" />
<meta itemprop="name" content="通过 Service 连接应用">
<meta itemprop="description" content="连接到容器的 k8s 模型 到目前为止我们有一个持续运行的多副本应用，我们可以把它暴露到一个网络中。 在讨论 k8s 的网络实现前， 值得花点时间来看看 Docker 中普通的">
<meta itemprop="datePublished" content="2020-09-16T00:00:00+00:00" />
<meta itemprop="dateModified" content="2020-12-22T15:20:17+08:00" />
<meta itemprop="wordCount" content="4955">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="通过 Service 连接应用"/>
<meta name="twitter:description" content="连接到容器的 k8s 模型 到目前为止我们有一个持续运行的多副本应用，我们可以把它暴露到一个网络中。 在讨论 k8s 的网络实现前， 值得花点时间来看看 Docker 中普通的"/>





<link rel="preload" href="/k8sDocs/scss/main.min.537757ec8e00d87ec206229d5725b6d05e078dd447818e448f0802685603e730.css" as="style">
<link href="/k8sDocs/scss/main.min.537757ec8e00d87ec206229d5725b6d05e078dd447818e448f0802685603e730.css" rel="stylesheet" integrity="">


<script src="/k8sDocs/js/jquery-3.3.1.min.js" ></script>





<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Organization",
    "url": "https://kubernetes.io",
    "logo": "https://kubernetes.io/images/favicon.png",
    "potentialAction": {
      "@type": "SearchAction",
      "target": "https://lostsquirrel.github.io/k8sDocs/search/?q={search_term_string}",
      "query-input": "required name=search_term_string"
    }

  }
</script>
<meta name="theme-color" content="#326ce5">




<link rel="stylesheet" href=/k8sDocs/css/base_fonts.css>

<link rel="stylesheet" href="/k8sDocs/css/jquery-ui.min.css">
<link rel="stylesheet" href="/k8sDocs/css/callouts.css">
<link rel="stylesheet" href="/k8sDocs/css/custom.css">
<link rel="stylesheet" href="/k8sDocs/css/custom-jekyll/tags.css">



<meta name="description" content="连接到容器的 k8s 模型 到目前为止我们有一个持续运行的多副本应用，我们可以把它暴露到一个网络中。 在讨论 k8s 的网络实现前， 值得花点时间来看看 Docker 中普通的">
<meta property="og:description" content="连接到容器的 k8s 模型 到目前为止我们有一个持续运行的多副本应用，我们可以把它暴露到一个网络中。 在讨论 k8s 的网络实现前， 值得花点时间来看看 Docker 中普通的">
<meta name="twitter:description" content="连接到容器的 k8s 模型 到目前为止我们有一个持续运行的多副本应用，我们可以把它暴露到一个网络中。 在讨论 k8s 的网络实现前， 值得花点时间来看看 Docker 中普通的">
<meta property="og:url" content="https://lostsquirrel.github.io/k8sDocs/docs/concepts/services-networking/connect-applications-service/">
<meta property="og:title" content="通过 Service 连接应用">
<meta name="twitter:title" content="通过 Service 连接应用">
<meta name="twitter:image" content="https://kubernetes.io/images/favicon.png" />

<meta name="twitter:image:alt" content="Kubernetes">

<meta property="og:image" content="/k8sDocs/images/kubernetes-horizontal-color.png">

<meta property="og:type" content="article">



<script src="/k8sDocs/js/script.js"></script>


    <title>通过 Service 连接应用 | Kubernetes</title>
  </head>
  <body class="td-page td-documentation">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark  flex-row td-navbar" data-auto-burger="primary">
        <a class="navbar-brand" href="/k8sDocs/"></a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">

		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			
			
			<li class="nav-item mr-2 mb-lg-0">
				
				<a class="nav-link active" href="/k8sDocs/docs/" >Documentation</span></a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		</ul>
	</div>
  

</nav>

      
      <div class="header-filler"></div>
    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-md-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
            




<div id="td-sidebar-menu" class="td-sidebar__inner">
  
  <form class="td-sidebar__search d-flex align-items-center d-lg-none">
    

    <button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type="button" data-toggle="collapse" data-target="#td-section-nav" aria-controls="td-docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    </button>
  </form>
  
  <nav class="collapse td-sidebar-nav" id="td-section-nav">
    
    






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Kubernetes Documentation</a>
  </li>
  <ul>
    <li class="collapse show" id="k8sdocsdocs">
      
      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">概念(Concepts)</a>
  </li>
  <ul>
    <li class="collapse show" id="k8sdocsdocsconcepts">
      
      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/overview/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">概览</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsoverview">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverview00-what-is-k8s" href="/k8sDocs/docs/concepts/overview/00-what-is-k8s/">k8s 是什么</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverview01-components" href="/k8sDocs/docs/concepts/overview/01-components/">k8s 组件</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverview02-k8s-api" href="/k8sDocs/docs/concepts/overview/02-k8s-api/">k8s API 说明</a>
      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/overview/working-with-objects/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">k8s 对象管理</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsoverviewworking-with-objects">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects00-kubernetes-objects" href="/k8sDocs/docs/concepts/overview/working-with-objects/00-kubernetes-objects/">k8s 对象介绍</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objectsnames" href="/k8sDocs/docs/concepts/overview/working-with-objects/names/">对象命令与ID</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects02-namespace" href="/k8sDocs/docs/concepts/overview/working-with-objects/02-namespace/">命名空间(Namespaces)</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objectslabels" href="/k8sDocs/docs/concepts/overview/working-with-objects/labels/">标签和标签选择器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects04-annotation" href="/k8sDocs/docs/concepts/overview/working-with-objects/04-annotation/">注解 (Annotations)</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects05-field-selectors" href="/k8sDocs/docs/concepts/overview/working-with-objects/05-field-selectors/">字段选择器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsoverviewworking-with-objects06-common-labels" href="/k8sDocs/docs/concepts/overview/working-with-objects/06-common-labels/">标签设置指导</a>
      
      
    </li>
  </ul>
</ul>

      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/architecture/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">集群架构</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsarchitecture">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsarchitecturenodes" href="/k8sDocs/docs/concepts/architecture/nodes/">节点</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsarchitecturecontrol-plane-node-communication" href="/k8sDocs/docs/concepts/architecture/control-plane-node-communication/">控制中心与节点的通信</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsarchitecturecontroller" href="/k8sDocs/docs/concepts/architecture/controller/">控制器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsarchitecturecloud-controller" href="/k8sDocs/docs/concepts/architecture/cloud-controller/">Cloud Controller Manager</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/containers/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">容器</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptscontainers">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptscontainers00-images" href="/k8sDocs/docs/concepts/containers/00-images/">镜像</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptscontainers01-container-environment" href="/k8sDocs/docs/concepts/containers/01-container-environment/">容器环境</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptscontainers02-runtime-class" href="/k8sDocs/docs/concepts/containers/02-runtime-class/">Runtime Class</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptscontainerscontainer-lifecycle-hooks" href="/k8sDocs/docs/concepts/containers/container-lifecycle-hooks/">容器生命周期钩子</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/workloads/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">工作负载(Workload)</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsworkloads">
      
      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/workloads/pods/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">Pod</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsworkloadspods">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodspod-lifecycle" href="/k8sDocs/docs/concepts/workloads/pods/pod-lifecycle/">Pod 生命周期</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodsinit-containers" href="/k8sDocs/docs/concepts/workloads/pods/init-containers/">初始化容器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodspod-topology-spread-constraints" href="/k8sDocs/docs/concepts/workloads/pods/pod-topology-spread-constraints/">Pod 拓扑分布约束条件</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodspodpreset" href="/k8sDocs/docs/concepts/workloads/pods/podpreset/">Pod 预设信息</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodsdisruptions" href="/k8sDocs/docs/concepts/workloads/pods/disruptions/">Disruptions</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadspodsephemeral-containers" href="/k8sDocs/docs/concepts/workloads/pods/ephemeral-containers/">临时容器</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/workloads/controllers/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">控制器</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsworkloadscontrollers">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersdeployment" href="/k8sDocs/docs/concepts/workloads/controllers/deployment/">Deployment</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersreplicaset" href="/k8sDocs/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersstatefulset" href="/k8sDocs/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersdaemonset" href="/k8sDocs/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersjob" href="/k8sDocs/docs/concepts/workloads/controllers/job/">Job</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersgarbage-collection" href="/k8sDocs/docs/concepts/workloads/controllers/garbage-collection/">垃圾回收</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersttlafterfinished" href="/k8sDocs/docs/concepts/workloads/controllers/ttlafterfinished/">用于已完成资源的 TTL 控制器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollerscron-jobs" href="/k8sDocs/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsworkloadscontrollersreplicationcontroller" href="/k8sDocs/docs/concepts/workloads/controllers/replicationcontroller/">ReplicationController</a>
      
      
    </li>
  </ul>
</ul>

      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/services-networking/" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Service, 负载均衡, 网络</a>
  </li>
  <ul>
    <li class="collapse show" id="k8sdocsdocsconceptsservices-networking">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingservice" href="/k8sDocs/docs/concepts/services-networking/service/">Service</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingservice-topology" href="/k8sDocs/docs/concepts/services-networking/service-topology/">Service Topology</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingdns-pod-service" href="/k8sDocs/docs/concepts/services-networking/dns-pod-service/">Service 和 Pod 的 DNS</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page  active" id="m-k8sdocsdocsconceptsservices-networkingconnect-applications-service" href="/k8sDocs/docs/concepts/services-networking/connect-applications-service/">通过 Service 连接应用</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingendpoint-slices" href="/k8sDocs/docs/concepts/services-networking/endpoint-slices/">EndpointSlice</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingingress" href="/k8sDocs/docs/concepts/services-networking/ingress/">Ingress</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingingress-controllers" href="/k8sDocs/docs/concepts/services-networking/ingress-controllers/">Ingress 控制器</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingnetwork-policies" href="/k8sDocs/docs/concepts/services-networking/network-policies/">网络策略</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingadd-entries-to-pod-etc-hosts-with-host-aliases" href="/k8sDocs/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/">通过 HostAliases 向 Pod 的 /etc/hosts 文件中添加条目</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsservices-networkingdual-stack" href="/k8sDocs/docs/concepts/services-networking/dual-stack/">IPv4/IPv6 双栈</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/storage/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">存储(Storage)</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsstorage">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstoragevolumes" href="/k8sDocs/docs/concepts/storage/volumes/">卷(Volume)</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstoragepersistent-volumes" href="/k8sDocs/docs/concepts/storage/persistent-volumes/">持久化卷(PV)</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstoragevolume-snapshots" href="/k8sDocs/docs/concepts/storage/volume-snapshots/">卷快照</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstoragevolume-pvc-datasource" href="/k8sDocs/docs/concepts/storage/volume-pvc-datasource/">CSI 卷克隆</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstoragestorage-classes" href="/k8sDocs/docs/concepts/storage/storage-classes/">StorageClass</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstoragevolume-snapshot-classes" href="/k8sDocs/docs/concepts/storage/volume-snapshot-classes/">VolumeSnapshotClass</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstoragedynamic-provisioning" href="/k8sDocs/docs/concepts/storage/dynamic-provisioning/">卷动态供应</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstoragestorage-capacity" href="/k8sDocs/docs/concepts/storage/storage-capacity/">存储容量</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstorageephemeral-volumes" href="/k8sDocs/docs/concepts/storage/ephemeral-volumes/">临时卷</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsstoragestorage-limits" href="/k8sDocs/docs/concepts/storage/storage-limits/">节点级别的卷限制</a>
      
      
    </li>
  </ul>
</ul>

      
      
      
      






<ul class="td-sidebar-nav__section pr-md-3">
  <li class="td-sidebar-nav__section-title">
    <a  href="/k8sDocs/docs/concepts/configuration/" class="align-left pl-0 pr-2 collapsed td-sidebar-link td-sidebar-link__section">配置</a>
  </li>
  <ul>
    <li class="collapse " id="k8sdocsdocsconceptsconfiguration">
      
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsconfigurationoverview" href="/k8sDocs/docs/concepts/configuration/overview/">配置最佳实践</a>
      
      
      
      
      
      <a class="td-sidebar-link td-sidebar-link__page " id="m-k8sdocsdocsconceptsconfigurationconfigmap" href="/k8sDocs/docs/concepts/configuration/configmap/">ConfigMap</a>
      
      
    </li>
  </ul>
</ul>

      
      
    </li>
  </ul>
</ul>

      
      
    </li>
  </ul>
</ul>

  </nav>
</div>




          </div>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            <nav aria-label="breadcrumb" class="d-none d-md-block d-print-none">
	<ol class="breadcrumb spb-1">
		













<li class="breadcrumb-item" >
	<a href="https://lostsquirrel.github.io/k8sDocs/docs/">Kubernetes Documentation</a>
</li>




<li class="breadcrumb-item" >
	<a href="https://lostsquirrel.github.io/k8sDocs/docs/concepts/">概念(Concepts)</a>
</li>




<li class="breadcrumb-item" >
	<a href="https://lostsquirrel.github.io/k8sDocs/docs/concepts/services-networking/">Service, 负载均衡, 网络</a>
</li>




<li class="breadcrumb-item active" aria-current="page">
	<a href="https://lostsquirrel.github.io/k8sDocs/docs/concepts/services-networking/connect-applications-service/">通过 Service 连接应用</a>
</li>

	</ol>
</nav	>

            
              
            
              
    <div class="td-content">
    
<p>
  <a href="https://github.com/kubernetes/website/edit/master/content/zh/docs/concepts/services-networking/connect-applications-service.md" id="editPageButton" target="_blank" data-proofer-ignore>
    Edit This Page
  </a>
</p>

  <h1>通过 Service 连接应用</h1>
  
  

<!--
---
reviewers:
- caesarxuchao
- lavalamp
- thockin
title: Connecting Applications with Services
content_type: concept
weight: 30
---
 -->
<!-- overview -->
<!--
## The Kubernetes model for connecting containers

Now that you have a continuously running, replicated application you can expose it on a network. Before discussing the Kubernetes approach to networking, it is worthwhile to contrast it with the "normal" way networking works with Docker.

By default, Docker uses host-private networking, so containers can talk to other containers only if they are on the same machine. In order for Docker containers to communicate across nodes, there must be allocated ports on the machine's own IP address, which are then forwarded or proxied to the containers. This obviously means that containers must either coordinate which ports they use very carefully or ports must be allocated dynamically.

Coordinating port allocations across multiple developers or teams that provide containers is very difficult to do at scale, and exposes users to cluster-level issues outside of their control. Kubernetes assumes that pods can communicate with other pods, regardless of which host they land on. Kubernetes gives every pod its own cluster-private IP address, so you do not need to explicitly create links between pods or map container ports to host ports. This means that containers within a Pod can all reach each other's ports on localhost, and all pods in a cluster can see each other without NAT. The rest of this document elaborates on how you can run reliable services on such a networking model.

This guide uses a simple nginx server to demonstrate proof of concept.
 -->
<h2 id="连接到容器的-k8s-模型">连接到容器的 k8s 模型</h2>
<p>到目前为止我们有一个持续运行的多副本应用，我们可以把它暴露到一个网络中。 在讨论 k8s 的网络实现前，
值得花点时间来看看 Docker 中普通的网络是怎么工作的。</p>
<p>默认情况下， Docker 使用私有网络，因此只有同一个主机上的容器之间可以相互通信。要使不同主机之间
的容器能够通信，必须要通过主机自己的 IP 地址加上分配端口以转发或代理的方式连接到容器。
通过这种方式很明显的一个问题就是不同容器必须要十分小心地协调怎么分配端口，或者必须动态地分配端口。</p>
<p>大规模在多个开发者或项目组之间为容器协调端口分配是十分困难的， 并且也直接将用户暴露在无法控制的
集群级问题中。 k8s 确保 Pod 无论他们在哪个主机上，其相互之间都可以通信。k8s 会为每个 Pod 分配
集群内的私有 IP 地址，因此不需要用户显示地创建 Pod 之间的连接，也不需要做容器端口与主机端口的映射关系。
这就是说在一个 Pod 中的容器可以通过本地回环(localhost)以端口实现相互之间的通信，并且集群中
所有的 Pod 都可以在没有 NAT 的情况互相通信。 本文接下来的部分将说结阐怎么通过这个网络模型运行
可靠的服务。</p>
<p>本文使用一个简单的 nginx 服务来演示证明这个观点。</p>
<!-- body -->
<!--
## Exposing pods to the cluster

We did this in a previous example, but let's do it once again and focus on the networking perspective.
Create an nginx Pod, and note that it has a container port specification:



 













<table class="includecode" id="servicenetworkingrun-my-nginxyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/run-my-nginx.yaml" download="service/networking/run-my-nginx.yaml">
                    <code>service/networking/run-my-nginx.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingrun-my-nginxyaml')" title="Copy service/networking/run-my-nginx.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">2</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">nginx</span>
        <span style="color:#f92672">ports</span>:
        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">80</span>

</code></pre></div>  </td>
        </tr>
    </tbody>
</table>



This makes it accessible from any node in your cluster. Check the nodes the Pod is running on:

```shell
kubectl apply -f ./run-my-nginx.yaml
kubectl get pods -l run=my-nginx -o wide
```
```
NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
```

Check your pods' IPs:

```shell
kubectl get pods -l run=my-nginx -o yaml | grep podIP
    podIP: 10.244.3.4
    podIP: 10.244.2.5
```

You should be able to ssh into any node in your cluster and curl both IPs. Note that the containers are *not* using port 80 on the node, nor are there any special NAT rules to route traffic to the pod. This means you can run multiple nginx pods on the same node all using the same containerPort and access them from any other pod or node in your cluster using IP. Like Docker, ports can still be published to the host node's interfaces, but the need for this is radically diminished because of the networking model.

You can read more about [how we achieve this](/docs/concepts/cluster-administration/networking/#how-to-achieve-this) if you're curious.
 -->
<h2 id="将-pod-暴露到集群中">将 Pod 暴露到集群中</h2>
<p>这是我们之间用过的一个盒子，让我们再做一次，但这次专注于网络的角度。 创建一个 nginx 的 Pod，
注意这个定义中有关于端口的定义:</p>


 













<table class="includecode" id="servicenetworkingrun-my-nginxyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/run-my-nginx.yaml" download="service/networking/run-my-nginx.yaml">
                    <code>service/networking/run-my-nginx.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingrun-my-nginxyaml')" title="Copy service/networking/run-my-nginx.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">2</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">nginx</span>
        <span style="color:#f92672">ports</span>:
        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">80</span>

</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f ./run-my-nginx.yaml
</code></pre></div><p>这使用它可以从集群中的任意节点访问。通过以下命令查看 Pod 运行在哪个节点上</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l run<span style="color:#f92672">=</span>my-nginx -o wide
</code></pre></div><pre><code>NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
</code></pre><p>查看 Pod 的 IP 地址:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -l run<span style="color:#f92672">=</span>my-nginx -o yaml | grep podIP
</code></pre></div><pre><code>podIP: 10.244.3.4
podIP: 10.244.2.5
</code></pre><p>用户可以通过 ssh 连接到集群中的任意节点，并通过 curl 命令访问以上两个 IP。 要注意容器并 <em>没有</em>
使用节点上的 80 端口，也没有任何特殊的 NAT 规则将流量路由到 Pod。 也就是说用户可以在同一个节点
上使用一样的 <code>containerPort</code> 运行多个 nginx 的 Pod， 并且可以从集群中任意 Pod 或 节点使用
它的 IP 访问它。 与 Docker 一样， 端口也可以发布到主机的网卡上， 因为网络模型的原因，应该尽量减少这
种方式的使用。</p>
<p>如果用户比较好奇这个是怎么实现的见 <a href="/k8sDocs/docs/concepts/cluster-administration/networking/#how-to-achieve-this">这里</a></p>
<!--
## Creating a Service

So we have pods running nginx in a flat, cluster wide, address space. In theory, you could talk to these pods directly, but what happens when a node dies? The pods die with it, and the Deployment will create new ones, with different IPs. This is the problem a Service solves.

A Kubernetes Service is an abstraction which defines a logical set of Pods running somewhere in your cluster, that all provide the same functionality. When created, each Service is assigned a unique IP address (also called clusterIP). This address is tied to the lifespan of the Service, and will not change while the Service is alive. Pods can be configured to talk to the Service, and know that communication to the Service will be automatically load-balanced out to some pod that is a member of the Service.

You can create a Service for your 2 nginx replicas with `kubectl expose`:

```shell
kubectl expose deployment/my-nginx
```
```
service/my-nginx exposed
```

This is equivalent to `kubectl apply -f` the following yaml:



 













<table class="includecode" id="servicenetworkingnginx-svcyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/nginx-svc.yaml" download="service/networking/nginx-svc.yaml">
                    <code>service/networking/nginx-svc.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnginx-svcyaml')" title="Copy service/networking/nginx-svc.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">ports</span>:
  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>



This specification will create a Service which targets TCP port 80 on any Pod
with the `run: my-nginx` label, and expose it on an abstracted Service port
(`targetPort`: is the port the container accepts traffic on, `port`: is the
abstracted Service port, which can be any port other pods use to access the
Service).
View [Service](/docs/reference/generated/kubernetes-api/v1.19/#service-v1-core)
API object to see the list of supported fields in service definition.
Check your Service:

```shell
kubectl get svc my-nginx
```
```
NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-nginx   ClusterIP   10.0.162.149   <none>        80/TCP    21s
```

As mentioned previously, a Service is backed by a group of Pods. These Pods are
exposed through `endpoints`. The Service's selector will be evaluated continuously
and the results will be POSTed to an Endpoints object also named `my-nginx`.
When a Pod dies, it is automatically removed from the endpoints, and new Pods
matching the Service's selector will automatically get added to the endpoints.
Check the endpoints, and note that the IPs are the same as the Pods created in
the first step:

```shell
kubectl describe svc my-nginx
```
```
Name:                my-nginx
Namespace:           default
Labels:              run=my-nginx
Annotations:         <none>
Selector:            run=my-nginx
Type:                ClusterIP
IP:                  10.0.162.149
Port:                <unset> 80/TCP
Endpoints:           10.244.2.5:80,10.244.3.4:80
Session Affinity:    None
Events:              <none>
```
```shell
kubectl get ep my-nginx
```
```
NAME       ENDPOINTS                     AGE
my-nginx   10.244.2.5:80,10.244.3.4:80   1m
```

You should now be able to curl the nginx Service on `<CLUSTER-IP>:<PORT>` from
any node in your cluster. Note that the Service IP is completely virtual, it
never hits the wire. If you're curious about how this works you can read more
about the [service proxy](/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies).
 -->
<h2 id="创建一个-service">创建一个 Service</h2>
<p>这样我们就一个集群范围以平铺方式地址空间运行 nginx 的 Pod. 理论上，用户可以直接与这些 Pod 通信，
但是要是一个节点挂了会发生什么呢? 节点上面的 Pod 也会跟着一起挂掉， 然后 Deployment 会创建
新的 Pod， 但这些 Pod 的 IP 已经不是之前的了。 这就是 Service 要解决的问题。</p>
<p>一个 k8s 的 Service 就是对定义了一个集群中运行的提供同样功能的 Pod 的逻辑集合的抽象。每个
Service 被创建了以后都会被分配一个唯一的 IP 地址(也被称为集群IP(clusterIP)). 这个地址与该
Service 一生相伴，在 Service 的整个生命期内都不会改变。 Pod 也可以被配置为与 Service 通信，
访问 Service 的请求会被负载均衡到该 Service 所属的一个 Pod 上。</p>
<p>可以通过如下 <code>kubectl expose</code> 为上面的两个 nginx 副本创建一个 Service:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl expose deployment/my-nginx
</code></pre></div><pre><code>service/my-nginx exposed
</code></pre><p>这个命令与 <code>kubectl apply -f</code> 下面这个 yaml 文件等效:</p>


 













<table class="includecode" id="servicenetworkingnginx-svcyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/nginx-svc.yaml" download="service/networking/nginx-svc.yaml">
                    <code>service/networking/nginx-svc.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnginx-svcyaml')" title="Copy service/networking/nginx-svc.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">ports</span>:
  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


<p>这个配置文件中定义会创建一个 Service, 这个 Service 的目标为任意一个标签为 <code>run: my-nginx</code>
的 Pod 的 TCP 80 端口，并将这些端口暴露在一个抽象的 Service 端口(<code>targetPort</code>: 是容器
接收流量的端口，<code>port</code>: 是抽象 Service 的端口，可以是任意端口，用于其它的 Pod 访问该 Service)
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#service-v1-core">Service</a>
的 API 对象中有所有 Service 定义支持的字段列表。</p>
<p>查看创建的 Service:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get svc my-nginx
</code></pre></div><pre><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-nginx   ClusterIP   10.0.162.149   &lt;none&gt;        80/TCP    21s
</code></pre><p>就如之前提到的，一个 Service 背后都有一组(个) Pod. 这些 Pod 是通过 <code>Endpoint</code> 来暴露的。
Service 会持续执行然后将结果通过 POST 请求到一个也叫 <code>my-nginx</code> 的 Endpoint 对象。当有一个
Pod 挂掉时，该 Pod 的端点会自动从 Endpoint 上移除，当有一个新的 Pod 匹配 Service 的选择器
时也会自动添加到 Endpoint 上。 检查 Endpoint， 可以看到上面的 IP 地址与第一步 Pod 创建时的 IP 地址
是一样的</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe svc my-nginx
</code></pre></div><pre><code>Name:                my-nginx
Namespace:           default
Labels:              run=my-nginx
Annotations:         &lt;none&gt;
Selector:            run=my-nginx
Type:                ClusterIP
IP:                  10.0.162.149
Port:                &lt;unset&gt; 80/TCP
Endpoints:           10.244.2.5:80,10.244.3.4:80
Session Affinity:    None
Events:              &lt;none&gt;
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get ep my-nginx
</code></pre></div><pre><code>NAME       ENDPOINTS                     AGE
my-nginx   10.244.2.5:80,10.244.3.4:80   1m
</code></pre><p>这个时候就能在集群中的任意一个 Pod 中通过 curl 访问 <code>&lt;CLUSTER-IP&gt;:&lt;PORT&gt;</code> 来访问这个 nginx
的 Service.  要注意 Service 的 IP 完全是虚拟的。 如果用户对此有兴趣可以看看
<a href="/k8sDocs/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">service proxy</a>.</p>
<!--
## Accessing the Service

Kubernetes supports 2 primary modes of finding a Service - environment variables
and DNS. The former works out of the box while the latter requires the
[CoreDNS cluster addon](https://releases.k8s.io/master/cluster/addons/dns/coredns).
<blockquote class="note">
  <div><strong>说明：</strong> If the service environment variables are not desired (because possible clashing with expected program ones,
too many variables to process, only using DNS, etc) you can disable this mode by setting the <code>enableServiceLinks</code>
flag to <code>false</code> on the <a href="/docs/reference/generated/kubernetes-api/v1.19/#pod-v1-core">pod spec</a>.</div>
</blockquote>

 -->
<h2 id="访问这个-service">访问这个 Service</h2>
<p>k8s 主要有两种发现 Service 的模式 - 环境变量和 DNS。 前一个是直接可以用的(要注意顺序问题)
后一种则需要
<a href="https://releases.k8s.io/master/cluster/addons/dns/coredns">CoreDNS 集群插件</a>
<blockquote class="note">
  <div><strong>说明：</strong> 如果不需要 Service 的环境变量(因为可能与程序有冲突，需要处理的变量太多，只使用 DNS 等)， 可以
通过在
<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.19/#pod-v1-core">Pod 定义中</a>
将 <code>enableServiceLinks</code> 字段的值设置为 <code>false</code> 来禁用这种模式</div>
</blockquote>
</p>
<!--
### Environment Variables

When a Pod runs on a Node, the kubelet adds a set of environment variables for
each active Service. This introduces an ordering problem. To see why, inspect
the environment of your running nginx Pods (your Pod name will be different):

```shell
kubectl exec my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE
```
```
KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
```

Note there's no mention of your Service. This is because you created the replicas
before the Service. Another disadvantage of doing this is that the scheduler might
put both Pods on the same machine, which will take your entire Service down if
it dies. We can do this the right way by killing the 2 Pods and waiting for the
Deployment to recreate them. This time around the Service exists *before* the
replicas. This will give you scheduler-level Service spreading of your Pods
(provided all your nodes have equal capacity), as well as the right environment
variables:

```shell
kubectl scale deployment my-nginx --replicas=0; kubectl scale deployment my-nginx --replicas=2;

kubectl get pods -l run=my-nginx -o wide
```
```
NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
```

You may notice that the pods have different names, since they are killed and recreated.

```shell
kubectl exec my-nginx-3800858182-e9ihh -- printenv | grep SERVICE
```
```
KUBERNETES_SERVICE_PORT=443
MY_NGINX_SERVICE_HOST=10.0.162.149
KUBERNETES_SERVICE_HOST=10.0.0.1
MY_NGINX_SERVICE_PORT=80
KUBERNETES_SERVICE_PORT_HTTPS=443
```
 -->
<h3 id="环境变量">环境变量</h3>
<p>当一个 Pod 在一个节点上运行时， kubelet 为会每个活跃的 Service 添加一系列环境变量。这会引入
一个顺序问题。为啥呢，先看看现在运行的 nginx Pod 的环境变量(Pod 名称根据实际会不同)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl exec my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE
</code></pre></div><pre><code>KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><p>可以看到没有 nginx Service 的信息。 这是因为这些 Pod 副本是在 Service 之前创建的。另一个缺点
是调度器可能将两个 Pod 都丢到一个节点点上，如果这个节点挂了，则整个 Service 也就挂了。这时候
先杀掉这两个 Pod 然后等 Deployment 重建。 这样 Service 就在这些 Pod 创建 <em>之前</em> 就存在了.
这样就会让 Pod 在 Service 的调度级别(所有节点均匀分布)，同时环境变量也有了:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl scale deployment my-nginx --replicas<span style="color:#f92672">=</span>0; kubectl scale deployment my-nginx --replicas<span style="color:#f92672">=</span>2;

kubectl get pods -l run<span style="color:#f92672">=</span>my-nginx -o wide
</code></pre></div><pre><code>NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
</code></pre><p>这时候可以看到 Pod 的名称也变了，因为它们被干掉然后重建了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl exec my-nginx-3800858182-e9ihh -- printenv | grep SERVICE
</code></pre></div><pre><code>KUBERNETES_SERVICE_PORT=443
MY_NGINX_SERVICE_HOST=10.0.162.149
KUBERNETES_SERVICE_HOST=10.0.0.1
MY_NGINX_SERVICE_PORT=80
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><!--
### DNS

Kubernetes offers a DNS cluster addon Service that automatically assigns dns names to other Services. You can check if it's running on your cluster:

```shell
kubectl get services kube-dns --namespace=kube-system
```
```
NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.0.0.10    <none>        53/UDP,53/TCP   8m
```

The rest of this section will assume you have a Service with a long lived IP
(my-nginx), and a DNS server that has assigned a name to that IP. Here we use the CoreDNS cluster addon (application name `kube-dns`), so you can talk to the Service from any pod in your cluster using standard methods (e.g. `gethostbyname()`). If CoreDNS isn't running, you can enable it referring to the [CoreDNS README](https://github.com/coredns/deployment/tree/master/kubernetes) or [Installing CoreDNS](/docs/tasks/administer-cluster/coredns/#installing-coredns). Let's run another curl application to test this:

```shell
kubectl run curl --image=radial/busyboxplus:curl -i --tty
```
```
Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false
Hit enter for command prompt
```

Then, hit enter and run `nslookup my-nginx`:

```shell
[ root@curl-131556218-9fnch:/ ]$ nslookup my-nginx
Server:    10.0.0.10
Address 1: 10.0.0.10

Name:      my-nginx
Address 1: 10.0.162.149
```
 -->
<h3 id="dns">DNS</h3>
<p>k8s 提供了一个 DNS 集群插件的 Service, 它会自动地为其它的 Service 分配 DNS 名称。
可以通过以下命令查看集群中是否运行了该服务:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get services kube-dns --namespace<span style="color:#f92672">=</span>kube-system
</code></pre></div><pre><code>NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m
</code></pre><p>本节接下来部分假设有一个拥有长期存在 IP 的 Service (my-nginx), 并且 DNS 服务为这个 IP
分配了一个名称。 这里我们使用的是 CoreDNS 集群插件(应用名称为 <code>kube-dns</code>)， 因此可以在集群中
的任意一个 Pod 通过标准方式(例如，<code>gethostbyname()</code> ) 与这个 Service 通信。 如果没有 CoreDNS，
可以参考
<a href="https://github.com/coredns/deployment/tree/master/kubernetes">CoreDNS README</a>
或
<a href="/docs/tasks/administer-cluster/coredns/#installing-coredns">安装 CoreDNS</a>.
这时候再运行 curl 应用来验证:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl run curl --image<span style="color:#f92672">=</span>radial/busyboxplus:curl -i --tty
</code></pre></div><pre><code>Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre><p>看到以上提供，再次敲回车键，然后运行 <code>nslookup my-nginx</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#f92672">[</span> root@curl-131556218-9fnch:/ <span style="color:#f92672">]</span>$ nslookup my-nginx
</code></pre></div><pre><code>Server:    10.0.0.10
Address 1: 10.0.0.10

Name:      my-nginx
Address 1: 10.0.162.149
</code></pre><!--
## Securing the Service

Till now we have only accessed the nginx server from within the cluster. Before exposing the Service to the internet, you want to make sure the communication channel is secure. For this, you will need:

* Self signed certificates for https (unless you already have an identity certificate)
* An nginx server configured to use the certificates
* A [secret](/docs/concepts/configuration/secret/) that makes the certificates accessible to pods

You can acquire all these from the [nginx https example](https://github.com/kubernetes/examples/tree/master/staging/https-nginx/). This requires having go and make tools installed. If you don't want to install those, then follow the manual steps later. In short:

```shell
make keys KEY=/tmp/nginx.key CERT=/tmp/nginx.crt
kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt
```
```
secret/nginxsecret created
```
```shell
kubectl get secrets
```
```
NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
```
And also the configmap:
```shell
kubectl create configmap nginxconfigmap --from-file=default.conf
```
```
configmap/nginxconfigmap created
```
```shell
kubectl get configmaps
```
```
NAME             DATA   AGE
nginxconfigmap   1      114s
```
Following are the manual steps to follow in case you run into problems running make (on windows for example):

```shell
# Create a public private key pair
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj "/CN=my-nginx/O=my-nginx"
# Convert the keys to base64 encoding
cat /d/tmp/nginx.crt | base64
cat /d/tmp/nginx.key | base64
```
Use the output from the previous commands to create a yaml file as follows. The base64 encoded value should all be on a single line.

```yaml
apiVersion: "v1"
kind: "Secret"
metadata:
  name: "nginxsecret"
  namespace: "default"
type: kubernetes.io/tls
data:
  tls.crt: "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lKQUp5M3lQK0pzMlpJTUEwR0NTcUdTSWIzRFFFQkJRVUFNQ1l4RVRBUEJnTlYKQkFNVENHNW5hVzU0YzNaak1SRXdEd1lEVlFRS0V3aHVaMmx1ZUhOMll6QWVGdzB4TnpFd01qWXdOekEzTVRKYQpGdzB4T0RFd01qWXdOekEzTVRKYU1DWXhFVEFQQmdOVkJBTVRDRzVuYVc1NGMzWmpNUkV3RHdZRFZRUUtFd2h1CloybHVlSE4yWXpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSjFxSU1SOVdWM0IKMlZIQlRMRmtobDRONXljMEJxYUhIQktMSnJMcy8vdzZhU3hRS29GbHlJSU94NGUrMlN5ajBFcndCLzlYTnBwbQppeW1CL3JkRldkOXg5UWhBQUxCZkVaTmNiV3NsTVFVcnhBZW50VWt1dk1vLzgvMHRpbGhjc3paenJEYVJ4NEo5Ci82UVRtVVI3a0ZTWUpOWTVQZkR3cGc3dlVvaDZmZ1Voam92VG42eHNVR0M2QURVODBpNXFlZWhNeVI1N2lmU2YKNHZpaXdIY3hnL3lZR1JBRS9mRTRqakxCdmdONjc2SU90S01rZXV3R0ljNDFhd05tNnNTSzRqYUNGeGpYSnZaZQp2by9kTlEybHhHWCtKT2l3SEhXbXNhdGp4WTRaNVk3R1ZoK0QrWnYvcW1mMFgvbVY0Rmo1NzV3ajFMWVBocWtsCmdhSXZYRyt4U1FVQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjcKTUI4R0ExVWRJd1FZTUJhQUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjdNQXdHQTFVZEV3UUZNQU1CQWY4dwpEUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRVhTMW9FU0lFaXdyMDhWcVA0K2NwTHI3TW5FMTducDBvMm14alFvCjRGb0RvRjdRZnZqeE04Tzd2TjB0clcxb2pGSW0vWDE4ZnZaL3k4ZzVaWG40Vm8zc3hKVmRBcStNZC9jTStzUGEKNmJjTkNUekZqeFpUV0UrKzE5NS9zb2dmOUZ3VDVDK3U2Q3B5N0M3MTZvUXRUakViV05VdEt4cXI0Nk1OZWNCMApwRFhWZmdWQTRadkR4NFo3S2RiZDY5eXM3OVFHYmg5ZW1PZ05NZFlsSUswSGt0ejF5WU4vbVpmK3FqTkJqbWZjCkNnMnlwbGQ0Wi8rUUNQZjl3SkoybFIrY2FnT0R4elBWcGxNSEcybzgvTHFDdnh6elZPUDUxeXdLZEtxaUMwSVEKQ0I5T2wwWW5scE9UNEh1b2hSUzBPOStlMm9KdFZsNUIyczRpbDlhZ3RTVXFxUlU9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K"
  tls.key: "LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2RhaURFZlZsZHdkbFIKd1V5eFpJWmVEZWNuTkFhbWh4d1NpeWF5N1AvOE9ta3NVQ3FCWmNpQ0RzZUh2dGtzbzlCSzhBZi9WemFhWm9zcApnZjYzUlZuZmNmVUlRQUN3WHhHVFhHMXJKVEVGSzhRSHA3VkpMcnpLUC9QOUxZcFlYTE0yYzZ3MmtjZUNmZitrCkU1bEVlNUJVbUNUV09UM3c4S1lPNzFLSWVuNEZJWTZMMDUrc2JGQmd1Z0ExUE5JdWFubm9UTWtlZTRuMG4rTDQKb3NCM01ZUDhtQmtRQlAzeE9JNHl3YjREZXUraURyU2pKSHJzQmlIT05Xc0RadXJFaXVJMmdoY1kxeWIyWHI2UAozVFVOcGNSbC9pVG9zQngxcHJHclk4V09HZVdPeGxZZmcvbWIvNnBuOUYvNWxlQlkrZStjSTlTMkQ0YXBKWUdpCkwxeHZzVWtGQWdNQkFBRUNnZ0VBZFhCK0xkbk8ySElOTGo5bWRsb25IUGlHWWVzZ294RGQwci9hQ1Zkank4dlEKTjIwL3FQWkUxek1yall6Ry9kVGhTMmMwc0QxaTBXSjdwR1lGb0xtdXlWTjltY0FXUTM5SjM0VHZaU2FFSWZWNgo5TE1jUHhNTmFsNjRLMFRVbUFQZytGam9QSFlhUUxLOERLOUtnNXNrSE5pOWNzMlY5ckd6VWlVZWtBL0RBUlBTClI3L2ZjUFBacDRuRWVBZmI3WTk1R1llb1p5V21SU3VKdlNyblBESGtUdW1vVlVWdkxMRHRzaG9reUxiTWVtN3oKMmJzVmpwSW1GTHJqbGtmQXlpNHg0WjJrV3YyMFRrdWtsZU1jaVlMbjk4QWxiRi9DSmRLM3QraTRoMTVlR2ZQegpoTnh3bk9QdlVTaDR2Q0o3c2Q5TmtEUGJvS2JneVVHOXBYamZhRGR2UVFLQmdRRFFLM01nUkhkQ1pKNVFqZWFKClFGdXF4cHdnNzhZTjQyL1NwenlUYmtGcVFoQWtyczJxWGx1MDZBRzhrZzIzQkswaHkzaE9zSGgxcXRVK3NHZVAKOWRERHBsUWV0ODZsY2FlR3hoc0V0L1R6cEdtNGFKSm5oNzVVaTVGZk9QTDhPTm1FZ3MxMVRhUldhNzZxelRyMgphRlpjQ2pWV1g0YnRSTHVwSkgrMjZnY0FhUUtCZ1FEQmxVSUUzTnNVOFBBZEYvL25sQVB5VWs1T3lDdWc3dmVyClUycXlrdXFzYnBkSi9hODViT1JhM05IVmpVM25uRGpHVHBWaE9JeXg5TEFrc2RwZEFjVmxvcG9HODhXYk9lMTAKMUdqbnkySmdDK3JVWUZiRGtpUGx1K09IYnRnOXFYcGJMSHBzUVpsMGhucDBYSFNYVm9CMUliQndnMGEyOFVadApCbFBtWmc2d1BRS0JnRHVIUVV2SDZHYTNDVUsxNFdmOFhIcFFnMU16M2VvWTBPQm5iSDRvZUZKZmcraEppSXlnCm9RN3hqWldVR3BIc3AyblRtcHErQWlSNzdyRVhsdlhtOElVU2FsbkNiRGlKY01Pc29RdFBZNS9NczJMRm5LQTQKaENmL0pWb2FtZm1nZEN0ZGtFMXNINE9MR2lJVHdEbTRpb0dWZGIwMllnbzFyb2htNUpLMUI3MkpBb0dBUW01UQpHNDhXOTVhL0w1eSt5dCsyZ3YvUHM2VnBvMjZlTzRNQ3lJazJVem9ZWE9IYnNkODJkaC8xT2sybGdHZlI2K3VuCnc1YytZUXRSTHlhQmd3MUtpbGhFZDBKTWU3cGpUSVpnQWJ0LzVPbnlDak9OVXN2aDJjS2lrQ1Z2dTZsZlBjNkQKckliT2ZIaHhxV0RZK2Q1TGN1YSt2NzJ0RkxhenJsSlBsRzlOZHhrQ2dZRUF5elIzT3UyMDNRVVV6bUlCRkwzZAp4Wm5XZ0JLSEo3TnNxcGFWb2RjL0d5aGVycjFDZzE2MmJaSjJDV2RsZkI0VEdtUjZZdmxTZEFOOFRwUWhFbUtKCnFBLzVzdHdxNWd0WGVLOVJmMWxXK29xNThRNTBxMmk1NVdUTThoSDZhTjlaMTltZ0FGdE5VdGNqQUx2dFYxdEYKWSs4WFJkSHJaRnBIWll2NWkwVW1VbGc9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K"
```
Now create the secrets using the file:

```shell
kubectl apply -f nginxsecrets.yaml
kubectl get secrets
```
```
NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
```

Now modify your nginx replicas to start an https server using the certificate in the secret, and the Service, to expose both ports (80 and 443):



 













<table class="includecode" id="servicenetworkingnginx-secure-appyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/nginx-secure-app.yaml" download="service/networking/nginx-secure-app.yaml">
                    <code>service/networking/nginx-secure-app.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnginx-secure-appyaml')" title="Copy service/networking/nginx-secure-app.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">NodePort</span>
  <span style="color:#f92672">ports</span>:
  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">80</span>
    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">443</span>
    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">https</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
---
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">volumes</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">secret-volume</span>
        <span style="color:#f92672">secret</span>:
          <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">nginxsecret</span>
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">configmap-volume</span>
        <span style="color:#f92672">configMap</span>:
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginxconfigmap</span>
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginxhttps</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">bprashanth/nginxhttps:1.0</span>
        <span style="color:#f92672">ports</span>:
        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">443</span>
        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">80</span>
        <span style="color:#f92672">volumeMounts</span>:
        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/etc/nginx/ssl</span>
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">secret-volume</span>
        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/etc/nginx/conf.d</span>
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">configmap-volume</span>
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>



Noteworthy points about the nginx-secure-app manifest:

- It contains both Deployment and Service specification in the same file.
- The [nginx server](https://github.com/kubernetes/examples/tree/master/staging/https-nginx/default.conf)
  serves HTTP traffic on port 80 and HTTPS traffic on 443, and nginx Service
  exposes both ports.
- Each container has access to the keys through a volume mounted at `/etc/nginx/ssl`.
  This is setup *before* the nginx server is started.

```shell
kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml
```

At this point you can reach the nginx server from any node.

```shell
kubectl get pods -o yaml | grep -i podip
    podIP: 10.244.3.5
node $ curl -k https://10.244.3.5
...
<h1>Welcome to nginx!</h1>
```

Note how we supplied the `-k` parameter to curl in the last step, this is because we don't know anything about the pods running nginx at certificate generation time,
so we have to tell curl to ignore the CName mismatch. By creating a Service we linked the CName used in the certificate with the actual DNS name used by pods during Service lookup.
Let's test this from a pod (the same secret is being reused for simplicity, the pod only needs nginx.crt to access the Service):



 













<table class="includecode" id="servicenetworkingcurlpodyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/curlpod.yaml" download="service/networking/curlpod.yaml">
                    <code>service/networking/curlpod.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingcurlpodyaml')" title="Copy service/networking/curlpod.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">curl-deployment</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">curlpod</span>
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">curlpod</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">volumes</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">secret-volume</span>
        <span style="color:#f92672">secret</span>:
          <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">nginxsecret</span>
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">curlpod</span>
        <span style="color:#f92672">command</span>:
        - <span style="color:#ae81ff">sh</span>
        - -<span style="color:#ae81ff">c</span>
        - <span style="color:#ae81ff">while true; do sleep 1; done</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">radial/busyboxplus:curl</span>
        <span style="color:#f92672">volumeMounts</span>:
        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/etc/nginx/ssl</span>
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">secret-volume</span>
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>



```shell
kubectl apply -f ./curlpod.yaml
kubectl get pods -l app=curlpod
```
```
NAME                               READY     STATUS    RESTARTS   AGE
curl-deployment-1515033274-1410r   1/1       Running   0          1m
```
```shell
kubectl exec curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/tls.crt
...
<title>Welcome to nginx!</title>
...
```
 -->
<h2 id="为-service-加安全层">为 Service 加安全层</h2>
<p>到目前为止我们都是在集群内访问这个 nginx 服务。 在将这个 Service 暴露到互联网之前，需要确保
连接是安全。 因此，必须要:</p>
<ul>
<li>Self signed certificates for https (unless you already have an identity certificate)</li>
<li>An nginx server configured to use the certificates</li>
<li>A <a href="/docs/concepts/configuration/secret/">secret</a> that makes the certificates accessible to pods</li>
</ul>
<ul>
<li>创建一个自签的 https 证书(除非已经有对应的证书)</li>
<li>配置一个使用该证书的 nginx 服务</li>
<li>创建一个 <a href="/docs/concepts/configuration/secret/">Secret</a>， 让证书在 Pod 中可用</li>
</ul>
<p>所有的这些都可以参考
<a href="https://github.com/kubernetes/examples/tree/master/staging/https-nginx">nginx https 示例</a>
这个需要有 go 环境和安装打包工具。如果不想安装这些， 则跟着下面步骤手动操作， 简单说:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">make keys KEY<span style="color:#f92672">=</span>/tmp/nginx.key CERT<span style="color:#f92672">=</span>/tmp/nginx.crt
kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt
</code></pre></div><pre><code>secret/nginxsecret created
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get secrets
</code></pre></div><pre><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>再创建 Configmap:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl create configmap nginxconfigmap --from-file<span style="color:#f92672">=</span>default.conf
</code></pre></div><pre><code>configmap/nginxconfigmap created
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get configmaps
</code></pre></div><pre><code>NAME             DATA   AGE
nginxconfigmap   1      114s
</code></pre><p>如果运行 make 有问题，则跟随下面的手动步骤操作(比如在 windows 上):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#75715e"># Create a public private key pair</span>
openssl req -x509 -nodes -days <span style="color:#ae81ff">365</span> -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj <span style="color:#e6db74">&#34;/CN=my-nginx/O=my-nginx&#34;</span>
<span style="color:#75715e"># Convert the keys to base64 encoding</span>
cat /d/tmp/nginx.crt | base64
cat /d/tmp/nginx.key | base64
</code></pre></div><p>Use the output from the previous commands to create a yaml file as follows. The base64 encoded value should all be on a single line.
使用上面的输出创建以下的 yaml 配置文件。 base64 编码的内容应该只有一行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#e6db74">&#34;v1&#34;</span>
<span style="color:#f92672">kind</span>: <span style="color:#e6db74">&#34;Secret&#34;</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;nginxsecret&#34;</span>
  <span style="color:#f92672">namespace</span>: <span style="color:#e6db74">&#34;default&#34;</span>
<span style="color:#f92672">type</span>: <span style="color:#ae81ff">kubernetes.io/tls</span>
<span style="color:#f92672">data</span>:
  <span style="color:#f92672">tls.crt</span>: <span style="color:#e6db74">&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lKQUp5M3lQK0pzMlpJTUEwR0NTcUdTSWIzRFFFQkJRVUFNQ1l4RVRBUEJnTlYKQkFNVENHNW5hVzU0YzNaak1SRXdEd1lEVlFRS0V3aHVaMmx1ZUhOMll6QWVGdzB4TnpFd01qWXdOekEzTVRKYQpGdzB4T0RFd01qWXdOekEzTVRKYU1DWXhFVEFQQmdOVkJBTVRDRzVuYVc1NGMzWmpNUkV3RHdZRFZRUUtFd2h1CloybHVlSE4yWXpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSjFxSU1SOVdWM0IKMlZIQlRMRmtobDRONXljMEJxYUhIQktMSnJMcy8vdzZhU3hRS29GbHlJSU94NGUrMlN5ajBFcndCLzlYTnBwbQppeW1CL3JkRldkOXg5UWhBQUxCZkVaTmNiV3NsTVFVcnhBZW50VWt1dk1vLzgvMHRpbGhjc3paenJEYVJ4NEo5Ci82UVRtVVI3a0ZTWUpOWTVQZkR3cGc3dlVvaDZmZ1Voam92VG42eHNVR0M2QURVODBpNXFlZWhNeVI1N2lmU2YKNHZpaXdIY3hnL3lZR1JBRS9mRTRqakxCdmdONjc2SU90S01rZXV3R0ljNDFhd05tNnNTSzRqYUNGeGpYSnZaZQp2by9kTlEybHhHWCtKT2l3SEhXbXNhdGp4WTRaNVk3R1ZoK0QrWnYvcW1mMFgvbVY0Rmo1NzV3ajFMWVBocWtsCmdhSXZYRyt4U1FVQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjcKTUI4R0ExVWRJd1FZTUJhQUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjdNQXdHQTFVZEV3UUZNQU1CQWY4dwpEUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRVhTMW9FU0lFaXdyMDhWcVA0K2NwTHI3TW5FMTducDBvMm14alFvCjRGb0RvRjdRZnZqeE04Tzd2TjB0clcxb2pGSW0vWDE4ZnZaL3k4ZzVaWG40Vm8zc3hKVmRBcStNZC9jTStzUGEKNmJjTkNUekZqeFpUV0UrKzE5NS9zb2dmOUZ3VDVDK3U2Q3B5N0M3MTZvUXRUakViV05VdEt4cXI0Nk1OZWNCMApwRFhWZmdWQTRadkR4NFo3S2RiZDY5eXM3OVFHYmg5ZW1PZ05NZFlsSUswSGt0ejF5WU4vbVpmK3FqTkJqbWZjCkNnMnlwbGQ0Wi8rUUNQZjl3SkoybFIrY2FnT0R4elBWcGxNSEcybzgvTHFDdnh6elZPUDUxeXdLZEtxaUMwSVEKQ0I5T2wwWW5scE9UNEh1b2hSUzBPOStlMm9KdFZsNUIyczRpbDlhZ3RTVXFxUlU9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K&#34;</span>
  <span style="color:#f92672">tls.key</span>: <span style="color:#e6db74">&#34;LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2RhaURFZlZsZHdkbFIKd1V5eFpJWmVEZWNuTkFhbWh4d1NpeWF5N1AvOE9ta3NVQ3FCWmNpQ0RzZUh2dGtzbzlCSzhBZi9WemFhWm9zcApnZjYzUlZuZmNmVUlRQUN3WHhHVFhHMXJKVEVGSzhRSHA3VkpMcnpLUC9QOUxZcFlYTE0yYzZ3MmtjZUNmZitrCkU1bEVlNUJVbUNUV09UM3c4S1lPNzFLSWVuNEZJWTZMMDUrc2JGQmd1Z0ExUE5JdWFubm9UTWtlZTRuMG4rTDQKb3NCM01ZUDhtQmtRQlAzeE9JNHl3YjREZXUraURyU2pKSHJzQmlIT05Xc0RadXJFaXVJMmdoY1kxeWIyWHI2UAozVFVOcGNSbC9pVG9zQngxcHJHclk4V09HZVdPeGxZZmcvbWIvNnBuOUYvNWxlQlkrZStjSTlTMkQ0YXBKWUdpCkwxeHZzVWtGQWdNQkFBRUNnZ0VBZFhCK0xkbk8ySElOTGo5bWRsb25IUGlHWWVzZ294RGQwci9hQ1Zkank4dlEKTjIwL3FQWkUxek1yall6Ry9kVGhTMmMwc0QxaTBXSjdwR1lGb0xtdXlWTjltY0FXUTM5SjM0VHZaU2FFSWZWNgo5TE1jUHhNTmFsNjRLMFRVbUFQZytGam9QSFlhUUxLOERLOUtnNXNrSE5pOWNzMlY5ckd6VWlVZWtBL0RBUlBTClI3L2ZjUFBacDRuRWVBZmI3WTk1R1llb1p5V21SU3VKdlNyblBESGtUdW1vVlVWdkxMRHRzaG9reUxiTWVtN3oKMmJzVmpwSW1GTHJqbGtmQXlpNHg0WjJrV3YyMFRrdWtsZU1jaVlMbjk4QWxiRi9DSmRLM3QraTRoMTVlR2ZQegpoTnh3bk9QdlVTaDR2Q0o3c2Q5TmtEUGJvS2JneVVHOXBYamZhRGR2UVFLQmdRRFFLM01nUkhkQ1pKNVFqZWFKClFGdXF4cHdnNzhZTjQyL1NwenlUYmtGcVFoQWtyczJxWGx1MDZBRzhrZzIzQkswaHkzaE9zSGgxcXRVK3NHZVAKOWRERHBsUWV0ODZsY2FlR3hoc0V0L1R6cEdtNGFKSm5oNzVVaTVGZk9QTDhPTm1FZ3MxMVRhUldhNzZxelRyMgphRlpjQ2pWV1g0YnRSTHVwSkgrMjZnY0FhUUtCZ1FEQmxVSUUzTnNVOFBBZEYvL25sQVB5VWs1T3lDdWc3dmVyClUycXlrdXFzYnBkSi9hODViT1JhM05IVmpVM25uRGpHVHBWaE9JeXg5TEFrc2RwZEFjVmxvcG9HODhXYk9lMTAKMUdqbnkySmdDK3JVWUZiRGtpUGx1K09IYnRnOXFYcGJMSHBzUVpsMGhucDBYSFNYVm9CMUliQndnMGEyOFVadApCbFBtWmc2d1BRS0JnRHVIUVV2SDZHYTNDVUsxNFdmOFhIcFFnMU16M2VvWTBPQm5iSDRvZUZKZmcraEppSXlnCm9RN3hqWldVR3BIc3AyblRtcHErQWlSNzdyRVhsdlhtOElVU2FsbkNiRGlKY01Pc29RdFBZNS9NczJMRm5LQTQKaENmL0pWb2FtZm1nZEN0ZGtFMXNINE9MR2lJVHdEbTRpb0dWZGIwMllnbzFyb2htNUpLMUI3MkpBb0dBUW01UQpHNDhXOTVhL0w1eSt5dCsyZ3YvUHM2VnBvMjZlTzRNQ3lJazJVem9ZWE9IYnNkODJkaC8xT2sybGdHZlI2K3VuCnc1YytZUXRSTHlhQmd3MUtpbGhFZDBKTWU3cGpUSVpnQWJ0LzVPbnlDak9OVXN2aDJjS2lrQ1Z2dTZsZlBjNkQKckliT2ZIaHhxV0RZK2Q1TGN1YSt2NzJ0RkxhenJsSlBsRzlOZHhrQ2dZRUF5elIzT3UyMDNRVVV6bUlCRkwzZAp4Wm5XZ0JLSEo3TnNxcGFWb2RjL0d5aGVycjFDZzE2MmJaSjJDV2RsZkI0VEdtUjZZdmxTZEFOOFRwUWhFbUtKCnFBLzVzdHdxNWd0WGVLOVJmMWxXK29xNThRNTBxMmk1NVdUTThoSDZhTjlaMTltZ0FGdE5VdGNqQUx2dFYxdEYKWSs4WFJkSHJaRnBIWll2NWkwVW1VbGc9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&#34;</span>
</code></pre></div><p>然后使用这引文件创建 Secret：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f nginxsecrets.yaml
kubectl get secrets
</code></pre></div><pre><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>这时候修改 nginx 副本使用 Secret 中的证书启动一个 https 服务。 Service 也需要同时暴露 80 和 443 端口:</p>


 













<table class="includecode" id="servicenetworkingnginx-secure-appyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/nginx-secure-app.yaml" download="service/networking/nginx-secure-app.yaml">
                    <code>service/networking/nginx-secure-app.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingnginx-secure-appyaml')" title="Copy service/networking/nginx-secure-app.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
  <span style="color:#f92672">labels</span>:
    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">type</span>: <span style="color:#ae81ff">NodePort</span>
  <span style="color:#f92672">ports</span>:
  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">8080</span>
    <span style="color:#f92672">targetPort</span>: <span style="color:#ae81ff">80</span>
    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">http</span>
  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">443</span>
    <span style="color:#f92672">protocol</span>: <span style="color:#ae81ff">TCP</span>
    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">https</span>
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
---
<span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">my-nginx</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">run</span>: <span style="color:#ae81ff">my-nginx</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">volumes</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">secret-volume</span>
        <span style="color:#f92672">secret</span>:
          <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">nginxsecret</span>
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">configmap-volume</span>
        <span style="color:#f92672">configMap</span>:
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginxconfigmap</span>
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginxhttps</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">bprashanth/nginxhttps:1.0</span>
        <span style="color:#f92672">ports</span>:
        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">443</span>
        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">80</span>
        <span style="color:#f92672">volumeMounts</span>:
        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/etc/nginx/ssl</span>
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">secret-volume</span>
        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/etc/nginx/conf.d</span>
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">configmap-volume</span>
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


<p>需要重点注意 nginx-secure-app 的地方:</p>
<ul>
<li>在同一个文件中包含了 Deployment 和 Service 的定义配置。</li>
<li><a href="https://github.com/kubernetes/examples/tree/master/staging/https-nginx/default.conf">nginx 服务器</a>
同时在 80 端口提供 HTTP 流量和 443 端口提供 HTTPS 流量， nginx Service 同时暴露了这两个端口。</li>
<li>每个容器都通过挂载在  <code>/etc/nginx/ssl</code> 的数据卷来访问证书
因此需要在 nginx 服务启动 <em>之前</em> 配置好</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml
</code></pre></div><p>这时候就可以在任意一个节点上访问这个 nginx 服务</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get pods -o yaml | grep -i podip
    podIP: 10.244.3.5
node $ curl -k https://10.244.3.5
</code></pre></div><pre><code>...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre><p>注意这里最后一步中的 curl 使用用了 <code>-k</code>， 因为在创建证书的时候不会知道运行 nginx 的 Pod的
任何信息， 因此要让 curl 忽略 CName 不匹配的问题。通过创建一个 Service, 就可以把证书中的
CName 和 Pod 在对 Service 解析使用的 DNS 名称统一起来。
在一个 Pod 中再测试一下(为了简单使用同一个 Secret, 这个 Pod 访问 Service 只需要 nginx.crt)</p>


 













<table class="includecode" id="servicenetworkingcurlpodyaml">
    <thead>
        <tr>
            <th>
                <a href="https://%25!s%28%3cnil%3e%29/master/content/zh/examples/service/networking/curlpod.yaml" download="service/networking/curlpod.yaml">
                    <code>service/networking/curlpod.yaml</code>
                </a>
                <img src="/k8sDocs/images/copycode.svg" style="max-height:24px; cursor: pointer" onclick="copyCode('servicenetworkingcurlpodyaml')" title="Copy service/networking/curlpod.yaml to clipboard">
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
<span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Deployment</span>
<span style="color:#f92672">metadata</span>:
  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">curl-deployment</span>
<span style="color:#f92672">spec</span>:
  <span style="color:#f92672">selector</span>:
    <span style="color:#f92672">matchLabels</span>:
      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">curlpod</span>
  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">1</span>
  <span style="color:#f92672">template</span>:
    <span style="color:#f92672">metadata</span>:
      <span style="color:#f92672">labels</span>:
        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">curlpod</span>
    <span style="color:#f92672">spec</span>:
      <span style="color:#f92672">volumes</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">secret-volume</span>
        <span style="color:#f92672">secret</span>:
          <span style="color:#f92672">secretName</span>: <span style="color:#ae81ff">nginxsecret</span>
      <span style="color:#f92672">containers</span>:
      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">curlpod</span>
        <span style="color:#f92672">command</span>:
        - <span style="color:#ae81ff">sh</span>
        - -<span style="color:#ae81ff">c</span>
        - <span style="color:#ae81ff">while true; do sleep 1; done</span>
        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">radial/busyboxplus:curl</span>
        <span style="color:#f92672">volumeMounts</span>:
        - <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/etc/nginx/ssl</span>
          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">secret-volume</span>
</code></pre></div>  </td>
        </tr>
    </tbody>
</table>


<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl apply -f ./curlpod.yaml
kubectl get pods -l app<span style="color:#f92672">=</span>curlpod
</code></pre></div><pre><code>NAME                               READY     STATUS    RESTARTS   AGE
curl-deployment-1515033274-1410r   1/1       Running   0          1m
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl exec curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/tls.crt
</code></pre></div><pre><code>...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
...
</code></pre><!--
## Exposing the Service

For some parts of your applications you may want to expose a Service onto an
external IP address. Kubernetes supports two ways of doing this: NodePorts and
LoadBalancers. The Service created in the last section already used `NodePort`,
so your nginx HTTPS replica is ready to serve traffic on the internet if your
node has a public IP.

```shell
kubectl get svc my-nginx -o yaml | grep nodePort -C 5
  uid: 07191fb3-f61a-11e5-8ae5-42010af00002
spec:
  clusterIP: 10.0.162.149
  ports:
  - name: http
    nodePort: 31704
    port: 8080
    protocol: TCP
    targetPort: 80
  - name: https
    nodePort: 32453
    port: 443
    protocol: TCP
    targetPort: 443
  selector:
    run: my-nginx
```
```shell
kubectl get nodes -o yaml | grep ExternalIP -C 1
    - address: 104.197.41.11
      type: ExternalIP
    allocatable:
--
    - address: 23.251.152.56
      type: ExternalIP
    allocatable:
...

$ curl https://<EXTERNAL-IP>:<NODE-PORT> -k
...
<h1>Welcome to nginx!</h1>
```

Let's now recreate the Service to use a cloud load balancer, just change the `Type` of `my-nginx` Service from `NodePort` to `LoadBalancer`:

```shell
kubectl edit svc my-nginx
kubectl get svc my-nginx
```
```
NAME       TYPE           CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE
my-nginx   LoadBalancer   10.0.162.149     xx.xxx.xxx.xxx     8080:30163/TCP        21s
```
```
curl https://<EXTERNAL-IP> -k
...
<title>Welcome to nginx!</title>
```

The IP address in the `EXTERNAL-IP` column is the one that is available on the public internet.  The `CLUSTER-IP` is only available inside your
cluster/private cloud network.

Note that on AWS, type `LoadBalancer` creates an ELB, which uses a (long)
hostname, not an IP.  It's too long to fit in the standard `kubectl get svc`
output, in fact, so you'll need to do `kubectl describe service my-nginx` to
see it.  You'll see something like this:

```shell
kubectl describe service my-nginx
...
LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com
...
```
 -->
<h2 id="暴露这个-service">暴露这个 Service</h2>
<p>For some parts of your applications you may want to expose a Service onto an
external IP address. Kubernetes supports two ways of doing this: NodePorts and
LoadBalancers. The Service created in the last section already used <code>NodePort</code>,
so your nginx HTTPS replica is ready to serve traffic on the internet if your
node has a public IP.</p>
<p>对于应用中的一部分，用户可能希望通过一个 Service 将其暴露到一个公网 IP 地址上。 k8s 支持两种方式:
NodePort 和 负载均衡器。 最后创建的这个 Service 已经使用了 <code>NodePort</code>， 所以如果集群中的
节点有公网IP，这个 nginx 的 HTTPS 就可以通过公网访问。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get svc my-nginx -o yaml | grep nodePort -C <span style="color:#ae81ff">5</span>
</code></pre></div><pre><code>uid: 07191fb3-f61a-11e5-8ae5-42010af00002
spec:
clusterIP: 10.0.162.149
ports:
- name: http
  nodePort: 31704
  port: 8080
  protocol: TCP
  targetPort: 80
- name: https
  nodePort: 32453
  port: 443
  protocol: TCP
  targetPort: 443
selector:
  run: my-nginx
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl get nodes -o yaml | grep ExternalIP -C <span style="color:#ae81ff">1</span>
</code></pre></div><pre><code>- address: 104.197.41.11
  type: ExternalIP
allocatable:
--
- address: 23.251.152.56
  type: ExternalIP
allocatable:
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ curl https://&lt;EXTERNAL-IP&gt;:&lt;NODE-PORT&gt; -k
</code></pre></div><pre><code>...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre><p>现在修改 Service 使它使用云负载均衡器，只需要将 <code>my-nginx</code> Service 的 <code>Type</code> 由 <code>NodePort</code> 改为 <code>LoadBalancer</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl edit svc my-nginx
kubectl get svc my-nginx
</code></pre></div><pre><code>NAME       TYPE           CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE
my-nginx   LoadBalancer   10.0.162.149     xx.xxx.xxx.xxx     8080:30163/TCP        21s
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">curl https://&lt;EXTERNAL-IP&gt; -k
</code></pre></div><pre><code>...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</code></pre><p>The IP address in the <code>EXTERNAL-IP</code> column is the one that is available on the public internet.  The <code>CLUSTER-IP</code> is only available inside your
cluster/private cloud network.
<code>EXTERNAL-IP</code> 列中的 IP 地址就是一个公网可用的地址。 <code>CLUSTER-IP</code> 只能在集群内部使用。
Note that on AWS, type <code>LoadBalancer</code> creates an ELB, which uses a (long)
hostname, not an IP.  It&rsquo;s too long to fit in the standard <code>kubectl get svc</code>
output, in fact, so you&rsquo;ll need to do <code>kubectl describe service my-nginx</code> to
see it.  You&rsquo;ll see something like this:</p>
<p>要注意在 AWS 上， <code>LoadBalancer</code> 类型的 Service 会创建一个 ELB, 它会使用一个(很长的)主机名，
而不是一个 IP 地址。 因为这个主机名太长而不适配标准的 <code>kubectl get svc</code> 输出，实际上需要使用
<code>kubectl describe service my-nginx</code> 命令才能看当输出的这个主机名，样子就类似下面的:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">kubectl describe service my-nginx
</code></pre></div><pre><code>...
LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com
...
</code></pre><h2 id="相关资料">相关资料</h2>
<ul>
<li>实践 <a href="/docs/tasks/access-application-cluster/service-access-application-cluster/">使用 Service 让集群中的一个应用可以访问</a></li>
<li>实践 <a href="/docs/tasks/access-application-cluster/connecting-frontend-backend/">使用 Service 连接前后端应用</a></li>
<li>实践 <a href="/docs/tasks/access-application-cluster/create-external-load-balancer/">创建一个外部负载均衡器</a></li>
</ul>



            
            <div class="text-muted mt-5 pt-3 border-top">最后修改 2020-12-22 15:20:00: <a  href="https://github.com/lostsquirrel/k8sDocs/commit/e228eb74cc8b072214fa345ce237b7d97efa1957">publish configmap (e228eb7)</a>
</div>
            
          </main>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
            






<div class="td-page-meta ml-2 pb-1 pt-2 mb-0">











<a href="https://github.com/lostsquirrel/k8sDocs/edit/master/content/zh/docs/concepts/services-networking/connect-applications-service.md" target="_blank"><i class="fa fa-edit fa-fw"></i> 编辑此页</a>
<a href="https://github.com/lostsquirrel/k8sDocs/new/master/content/zh/docs/concepts/services-networking/connect-applications-service.md?filename=change-me.md&amp;value=---%0Atitle%3A&#43;%22Long&#43;Page&#43;Title%22%0AlinkTitle%3A&#43;%22Short&#43;Nav&#43;Title%22%0Aweight%3A&#43;100%0Adescription%3A&#43;%3E-%0A&#43;&#43;&#43;&#43;&#43;Page&#43;description&#43;for&#43;heading&#43;and&#43;indexes.%0A---%0A%0A%23%23&#43;Heading%0A%0AEdit&#43;this&#43;template&#43;to&#43;create&#43;your&#43;new&#43;page.%0A%0A%2A&#43;Give&#43;it&#43;a&#43;good&#43;name%2C&#43;ending&#43;in&#43;%60.md%60&#43;-&#43;e.g.&#43;%60getting-started.md%60%0A%2A&#43;Edit&#43;the&#43;%22front&#43;matter%22&#43;section&#43;at&#43;the&#43;top&#43;of&#43;the&#43;page&#43;%28weight&#43;controls&#43;how&#43;its&#43;ordered&#43;amongst&#43;other&#43;pages&#43;in&#43;the&#43;same&#43;directory%3B&#43;lowest&#43;number&#43;first%29.%0A%2A&#43;Add&#43;a&#43;good&#43;commit&#43;message&#43;at&#43;the&#43;bottom&#43;of&#43;the&#43;page&#43;%28%3C80&#43;characters%3B&#43;use&#43;the&#43;extended&#43;description&#43;field&#43;for&#43;more&#43;detail%29.%0A%2A&#43;Create&#43;a&#43;new&#43;branch&#43;so&#43;you&#43;can&#43;preview&#43;your&#43;new&#43;file&#43;and&#43;request&#43;a&#43;review&#43;via&#43;Pull&#43;Request.%0A" target="_blank"><i class="fa fa-edit fa-fw"></i> 添加子页面</a>
<a href="https://github.com/lostsquirrel/k8sDocs/issues/new?title=%e9%80%9a%e8%bf%87%20Service%20%e8%bf%9e%e6%8e%a5%e5%ba%94%e7%94%a8" target="_blank"><i class="fab fa-github fa-fw"></i> 提交文档问题</a>

</div>






<nav id="TableOfContents">
  <ul>
    <li><a href="#连接到容器的-k8s-模型">连接到容器的 k8s 模型</a></li>
    <li><a href="#将-pod-暴露到集群中">将 Pod 暴露到集群中</a></li>
    <li><a href="#创建一个-service">创建一个 Service</a></li>
    <li><a href="#访问这个-service">访问这个 Service</a>
      <ul>
        <li><a href="#环境变量">环境变量</a></li>
        <li><a href="#dns">DNS</a></li>
      </ul>
    </li>
    <li><a href="#为-service-加安全层">为 Service 加安全层</a></li>
    <li><a href="#暴露这个-service">暴露这个 Service</a></li>
    <li><a href="#相关资料">相关资料</a></li>
  </ul>
</nav>



          </div>
        </div>
      </div>
      
<footer class="bg-dark py-5 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">
        
      </div>
      <div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
        
      </div>
      <div class="col-12 col-sm-4 text-center py-2 order-sm-2">
        
        
	
		
	
      </div>
    </div>
  </div>
</footer>


    </div>
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>











<script src="/k8sDocs/js/main.min.446a2e681f8167f44314691b77368dd561bf0b67514487f3f0fd999316c6da4a.js" integrity="sha256-RGouaB&#43;BZ/RDFGkbdzaN1WG/C2dRRIfz8P2ZkxbG2ko=" crossorigin="anonymous"></script>




  </body>
</html>