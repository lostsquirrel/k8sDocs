<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes – 安全</title>
    <link>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/</link>
    <description>Recent content in 安全 on Kubernetes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: 云原生安全概述</title>
      <link>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/overview/</guid>
      <description>
        
        
        &lt;!--
---
reviewers:
- zparnold
title: Overview of Cloud Native Security
content_type: concept
weight: 10
---
 --&gt;
&lt;!-- overview --&gt;
&lt;!--
This overview defines a model for thinking about Kubernetes security in the context of Cloud Native security.
 --&gt;
&lt;p&gt;本文定义了一个模式用于思考在云原生安全语境下的 k8s 安全&lt;/p&gt;
&lt;blockquote class=&#34;warning&#34;&gt;
  &lt;div&gt;&lt;strong&gt;警告：&lt;/strong&gt; &lt;!--
This container security model provides suggestions, not proven information security policies.
 --&gt;
&lt;p&gt;这个容器安全模型只提供建议，并不提供安全策略信息。&lt;/div&gt;
&lt;/blockquote&gt;

&lt;!-- body --&gt;
&lt;!--
## The 4C&#39;s of Cloud Native security

You can think about security in layers. The 4C&#39;s of Cloud Native security are Cloud,
Clusters, Containers, and Code.

&lt;blockquote class=&#34;note&#34;&gt;
  &lt;div&gt;&lt;strong&gt;说明：&lt;/strong&gt; This layered approach augments the &lt;a href=&#34;https://en.wikipedia.org/wiki/Defense_in_depth_(computing)&#34;&gt;defense in depth&lt;/a&gt;
computing approach to security, which is widely regarded as a best practice for securing
software systems.&lt;/div&gt;
&lt;/blockquote&gt;


&lt;figure&gt;
    &lt;img src=&#34;https://lostsquirrel.github.io/k8sDocs/images/docs/4c.png&#34;/&gt; &lt;figcaption&gt;
            &lt;h4&gt;The 4C&amp;#39;s of Cloud Native Security&lt;/h4&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;


Each layer of the Cloud Native security model builds upon the next outermost layer.
The Code layer benefits from strong base (Cloud, Cluster, Container) security layers.
You cannot safeguard against poor security standards in the base layers by addressing
security at the Code level.
 --&gt;
&lt;h2 id=&#34;the-4cs-of-cloud-native-security&#34;&gt;云原生安全的 4C 概念&lt;/h2&gt;
&lt;p&gt;可以将安全进行分层。 云原生安全的 4 个 C 就是云(Cloud), 集群(Clusters), 容器(Containers),
和 代码(Code).&lt;/p&gt;
&lt;blockquote class=&#34;note&#34;&gt;
  &lt;div&gt;&lt;strong&gt;说明：&lt;/strong&gt; 这种计算机安全通过分层的方式实现在
&lt;a href=&#34;https://en.wikipedia.org/wiki/Defense_in_depth_(computing)&#34;&gt;纵深防御&lt;/a&gt;
中有讨论，也是广泛认可作为软件系统安全的最佳实践。&lt;/div&gt;
&lt;/blockquote&gt;

&lt;figure&gt;
    &lt;img src=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/images/docs/4c.png&#34;/&gt; &lt;figcaption&gt;
            &lt;h4&gt;云原生安全的 4C 概念&lt;/h4&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;云原生安全模型的每一层都是构建于其外层的。 代码(Code)层受益于 (Cloud, Cluster, Container)
层的安全基础。 不能希望在基础层安全薄弱的情况下只通过代码层的安全策略就能提供良好的安全保障。&lt;/p&gt;
&lt;!--
## Cloud

In many ways, the Cloud (or co-located servers, or the corporate datacenter) is the
[trusted computing base](https://en.wikipedia.org/wiki/Trusted_computing_base)
of a Kubernetes cluster. If the Cloud layer is vulnerable (or
configured in a vulnerable way) then there is no guarantee that the components built
on top of this base are secure. Each cloud provider makes security recommendations
for running workloads securely in their environment.
 --&gt;
&lt;h2 id=&#34;cloud&#34;&gt;云环境&lt;/h2&gt;
&lt;p&gt;在大多数情况下， 云环境(或同一个地方的服务器，或公司的数据中心) 在 k8s 集群中是
&lt;a href=&#34;https://en.wikipedia.org/wiki/Trusted_computing_base&#34;&gt;受信任的计算基础&lt;/a&gt;。 如果在云
环境层是不安全的(或者以一个不安全的方式配置的)，那么基于这个基础构建的组建也是没有安全保证的。
每个云提供商都对在其环境上安全运行工作负载的安全建议&lt;/p&gt;
&lt;!--
### Cloud provider security

If you are running a Kubernetes cluster on your own hardware or a different cloud provider,
consult your documentation for security best practices.
Here are links to some of the popular cloud providers&#39; security documentation:






&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Cloud provider security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IaaS Provider&lt;/th&gt;
&lt;th&gt;Link&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Alibaba Cloud&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.alibabacloud.com/trust-center&#34;&gt;https://www.alibabacloud.com/trust-center&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Amazon Web Services&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://aws.amazon.com/security/&#34;&gt;https://aws.amazon.com/security/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Google Cloud Platform&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://cloud.google.com/security/&#34;&gt;https://cloud.google.com/security/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IBM Cloud&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.ibm.com/cloud/security&#34;&gt;https://www.ibm.com/cloud/security&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microsoft Azure&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/security/azure-security&#34;&gt;https://docs.microsoft.com/en-us/azure/security/azure-security&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VMWare VSphere&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.vmware.com/security/hardening-guides.html&#34;&gt;https://www.vmware.com/security/hardening-guides.html&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 --&gt;
&lt;h3 id=&#34;Cloud-provider-security&#34;&gt;云提供商安全&lt;/h3&gt;
&lt;p&gt;如果 k8s 集群运行在自己的硬件上或不同的云提供商，请查询相应文档获取最佳安全实践。
下面是一些主流云提供商的安全文档的链接地址.&lt;/p&gt;





&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;云提供商安全&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IaaS 提供商&lt;/th&gt;
&lt;th&gt;链接&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Alibaba Cloud&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.alibabacloud.com/trust-center&#34;&gt;https://www.alibabacloud.com/trust-center&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Amazon Web Services&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://aws.amazon.com/security/&#34;&gt;https://aws.amazon.com/security/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Google Cloud Platform&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://cloud.google.com/security/&#34;&gt;https://cloud.google.com/security/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IBM Cloud&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.ibm.com/cloud/security&#34;&gt;https://www.ibm.com/cloud/security&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microsoft Azure&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/security/azure-security&#34;&gt;https://docs.microsoft.com/en-us/azure/security/azure-security&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VMWare VSphere&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.vmware.com/security/hardening-guides.html&#34;&gt;https://www.vmware.com/security/hardening-guides.html&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;!--
### Infrastructure security {#infrastructure-security}

Suggestions for securing your infrastructure in a Kubernetes cluster:






&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Infrastructure security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Area of Concern for Kubernetes Infrastructure&lt;/th&gt;
&lt;th&gt;Recommendation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Network access to API Server (Control plane)&lt;/td&gt;
&lt;td&gt;All access to the Kubernetes control plane is not allowed publicly on the internet and is controlled by network access control lists restricted to the set of IP addresses needed to administer the cluster.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Network access to Nodes (nodes)&lt;/td&gt;
&lt;td&gt;Nodes should be configured to &lt;em&gt;only&lt;/em&gt; accept connections (via network access control lists)from the control plane on the specified ports, and accept connections for services in Kubernetes of type NodePort and LoadBalancer. If possible, these nodes should not be exposed on the public internet entirely.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kubernetes access to Cloud Provider API&lt;/td&gt;
&lt;td&gt;Each cloud provider needs to grant a different set of permissions to the Kubernetes control plane and nodes. It is best to provide the cluster with cloud provider access that follows the &lt;a href=&#34;https://en.wikipedia.org/wiki/Principle_of_least_privilege&#34;&gt;principle of least privilege&lt;/a&gt; for the resources it needs to administer. The &lt;a href=&#34;https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles&#34;&gt;Kops documentation&lt;/a&gt; provides information about IAM policies and roles.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access to etcd&lt;/td&gt;
&lt;td&gt;Access to etcd (the datastore of Kubernetes) should be limited to the control plane only. Depending on your configuration, you should attempt to use etcd over TLS. More information can be found in the &lt;a href=&#34;https://github.com/etcd-io/etcd/tree/master/Documentation&#34;&gt;etcd documentation&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;etcd Encryption&lt;/td&gt;
&lt;td&gt;Wherever possible it&amp;rsquo;s a good practice to encrypt all drives at rest, but since etcd holds the state of the entire cluster (including Secrets) its disk should especially be encrypted at rest.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 --&gt;
&lt;!--
### Infrastructure security {#infrastructure-security}

Suggestions for securing your infrastructure in a Kubernetes cluster:






&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Infrastructure security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Area of Concern for Kubernetes Infrastructure&lt;/th&gt;
&lt;th&gt;Recommendation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Network access to API Server (Control plane)&lt;/td&gt;
&lt;td&gt;All access to the Kubernetes control plane is not allowed publicly on the internet and is controlled by network access control lists restricted to the set of IP addresses needed to administer the cluster.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Network access to Nodes (nodes)&lt;/td&gt;
&lt;td&gt;Nodes should be configured to &lt;em&gt;only&lt;/em&gt; accept connections (via network access control lists)from the control plane on the specified ports, and accept connections for services in Kubernetes of type NodePort and LoadBalancer. If possible, these nodes should not be exposed on the public internet entirely.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kubernetes access to Cloud Provider API&lt;/td&gt;
&lt;td&gt;Each cloud provider needs to grant a different set of permissions to the Kubernetes control plane and nodes. It is best to provide the cluster with cloud provider access that follows the &lt;a href=&#34;https://en.wikipedia.org/wiki/Principle_of_least_privilege&#34;&gt;principle of least privilege&lt;/a&gt; for the resources it needs to administer. The &lt;a href=&#34;https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles&#34;&gt;Kops documentation&lt;/a&gt; provides information about IAM policies and roles.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access to etcd&lt;/td&gt;
&lt;td&gt;Access to etcd (the datastore of Kubernetes) should be limited to the control plane only. Depending on your configuration, you should attempt to use etcd over TLS. More information can be found in the &lt;a href=&#34;https://github.com/etcd-io/etcd/tree/master/Documentation&#34;&gt;etcd documentation&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;etcd Encryption&lt;/td&gt;
&lt;td&gt;Wherever possible it&amp;rsquo;s a good practice to encrypt all drives at rest, but since etcd holds the state of the entire cluster (including Secrets) its disk should especially be encrypted at rest.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 --&gt;
&lt;h3 id=&#34;infrastructure-security&#34;&gt;基础设施安全&lt;/h3&gt;
&lt;p&gt;k8s 集群基础设计安全加固建议:&lt;/p&gt;





&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;基础设施安全&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;k8s 基础设计关注领域&lt;/th&gt;
&lt;th&gt;推荐&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;访问 API 服务 (控制中心) 的网络&lt;/td&gt;
&lt;td&gt;k8s 控制中心是不允许任意来自公共互联网的访问，并且对控制中心的访问应该限制在那些需要管理集群的 IP 集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问节点 (nodes) 的网络&lt;/td&gt;
&lt;td&gt;节点应该配置成 &lt;em&gt;只&lt;/em&gt; 允许来自控制中心访问指定端口的连接(通过网络访问控制列表)，和接收来自 k8s 中 NodePort 和 LoadBalancer 类型 Service 的连接。 如果可能，避免让所有的节点都暴露到互联网。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;k8s 对云提供商 API 的访问&lt;/td&gt;
&lt;td&gt;每个云提供商需要给 k8s 控制中心和节点授予不同个权限集。 在授予集群云提供商访问权限时，依照&lt;a href=&#34;https://en.wikipedia.org/wiki/Principle_of_least_privilege&#34;&gt;最小权限原则&lt;/a&gt;，只给予其所需要管理的资源。 &lt;a href=&#34;https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles&#34;&gt;Kops documentation&lt;/a&gt; 文档提供了关于 IAM 和角色的信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问 etcd&lt;/td&gt;
&lt;td&gt;对 etcd (k8s 的数据源)应该限制到只给控制中心。 基于配置，应该使用配置有 TLS 的 etcd。 更多信息可以在 &lt;a href=&#34;https://github.com/etcd-io/etcd/tree/master/Documentation&#34;&gt;etcd 文档&lt;/a&gt;中找到.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;etcd 加密&lt;/td&gt;
&lt;td&gt;如果可能，对所有驱动器在落盘时加密是一种好的实践，但因为 etcd 中存放了整个集群的状态(包括 Secret)它的数据最应该在落盘时加密。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;div&gt;&lt;strong&gt;TODO: &lt;/strong&gt;说得不太清楚，需要实践理解后再考虑怎么修改&lt;/div&gt;
&lt;/blockquote&gt;

&lt;!--
## Cluster

There are two areas of concern for securing Kubernetes:

* Securing the cluster components that are configurable
* Securing the applications which run in the cluster
 --&gt;
&lt;h2 id=&#34;cluster&#34;&gt;集群&lt;/h2&gt;
&lt;p&gt;在对 k8s 安全加固时有两个值得关注的领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全加固那些可配置的集群组件&lt;/li&gt;
&lt;li&gt;安全加固那些运行在集群中的应用&lt;/li&gt;
&lt;/ul&gt;
&lt;!--
### Components of the Cluster {#cluster-components}

If you want to protect your cluster from accidental or malicious access and adopt
good information practices, read and follow the advice about
[securing your cluster](/docs/tasks/administer-cluster/securing-a-cluster/).
 --&gt;
&lt;h3 id=&#34;cluster-components&#34;&gt;集群的组件&lt;/h3&gt;
&lt;p&gt;如果希望保护集群免于偶然或恶意的访问和彩良好的信息实践，请阅读下面的建议
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/administer-cluster/securing-a-cluster/&#34;&gt;集群安全加固&lt;/a&gt;.&lt;/p&gt;
&lt;!--
### Components in the cluster (your application) {#cluster-applications}

Depending on the attack surface of your application, you may want to focus on specific
aspects of security. For example: If you are running a service (Service A) that is critical
in a chain of other resources and a separate workload (Service B) which is
vulnerable to a resource exhaustion attack then the risk of compromising Service A
is high if you do not limit the resources of Service B. The following table lists
areas of security concerns and recommendations for securing workloads running in Kubernetes:

Area of Concern for Workload Security | Recommendation |
------------------------------ | --------------------- |
RBAC Authorization (Access to the Kubernetes API) | https://kubernetes.io/docs/reference/access-authn-authz/rbac/
Authentication | https://kubernetes.io/docs/concepts/security/controlling-access/
Application secrets management (and encrypting them in etcd at rest) | https://kubernetes.io/docs/concepts/configuration/secret/ &lt;br&gt; https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/
Pod Security Policies | https://kubernetes.io/docs/concepts/policy/pod-security-policy/
Quality of Service (and Cluster resource management) | https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/
Network Policies | https://kubernetes.io/docs/concepts/services-networking/network-policies/
TLS For Kubernetes Ingress | https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
 --&gt;
&lt;h3 id=&#34;cluster-applications&#34;&gt;集群中的组件 (你的应用)&lt;/h3&gt;
&lt;p&gt;基于应用的攻击面，可能希望专注于某个方面的安全。 例如: 如果运行了一个服务(Service A)它是与其它资源
组成的链中的关键，另一个工作负载 (Service B), 这应用面对资源枯竭攻击是很脆弱的，如果不对 Service B
进行资源限制则会让 Service A 被攻陷的风险变高。下面表格里面列举安全关注领域和加固集群中运行的工作
负载安全的建议:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;工作负载安全关注领域&lt;/th&gt;
&lt;th&gt;建议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RBAC 授权 (对 k8s API 的访问)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/rbac/&#34;&gt;https://kubernetes.io/docs/reference/access-authn-authz/rbac/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;认证方式&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/security/controlling-access/&#34;&gt;https://kubernetes.io/docs/concepts/security/controlling-access/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用 Secret 管理 (和其在 etcd 落盘时加密)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/configuration/secret/&#34;&gt;https://kubernetes.io/docs/concepts/configuration/secret/&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/&#34;&gt;https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pod 安全策略&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/&#34;&gt;https://kubernetes.io/docs/concepts/policy/pod-security-policy/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务资源 (和集群资源管理)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/&#34;&gt;https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络策略&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/network-policies/&#34;&gt;https://kubernetes.io/docs/concepts/services-networking/network-policies/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;为 k8s Ingress 添加 TLS&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/#tls&#34;&gt;https://kubernetes.io/docs/concepts/services-networking/ingress/#tls&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
## Container

Container security is outside the scope of this guide. Here are general recommendations and
links to explore this topic:

Area of Concern for Containers | Recommendation |
------------------------------ | -------------- |
Container Vulnerability Scanning and OS Dependency Security | As part of an image build step, you should scan your containers for known vulnerabilities.
Image Signing and Enforcement | Sign container images to maintain a system of trust for the content of your containers.
Disallow privileged users | When constructing containers, consult your documentation for how to create users inside of the containers that have the least level of operating system privilege necessary in order to carry out the goal of the container.
 --&gt;
&lt;h2 id=&#34;container&#34;&gt;容器&lt;/h2&gt;
&lt;p&gt;容器安全不在本文的讨论范围。 下面是一些通用的建议和关于本话题的延伸阅读链接:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;容器安全关注领域&lt;/th&gt;
&lt;th&gt;建议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;容器漏洞扫描 和 操作系统信赖安全&lt;/td&gt;
&lt;td&gt;作为一个镜像构建的步骤，应该对容器进行已知漏洞扫描。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;镜像签名和验签&lt;/td&gt;
&lt;td&gt;容器镜像的签名可以维护系统对容器内存的信任&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;禁用特权用户&lt;/td&gt;
&lt;td&gt;在构建容器时，查询文档关于怎么创建可以实现容器目标的最小操作系统权限的用户&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
## Code

Application code is one of the primary attack surfaces over which you have the most control.
While securing application code is outside of the Kubernetes security topic, here
are recommendations to protect application code:
 --&gt;
&lt;h2 id=&#34;code&#34;&gt;代码&lt;/h2&gt;
&lt;p&gt;应用代码是一个最受开发者控制的主要攻击面之一。 因为对应用代码的安全加固不在 k8s 安全话题之内，下面
是一些保护应用代码的建议:&lt;/p&gt;
&lt;!--
### Code security






&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Code security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Area of Concern for Code&lt;/th&gt;
&lt;th&gt;Recommendation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Access over TLS only&lt;/td&gt;
&lt;td&gt;If your code needs to communicate by TCP, perform a TLS handshake with the client ahead of time. With the exception of a few cases, encrypt everything in transit. Going one step further, it&amp;rsquo;s a good idea to encrypt network traffic between services. This can be done through a process known as mutual or &lt;a href=&#34;https://en.wikipedia.org/wiki/Mutual_authentication&#34;&gt;mTLS&lt;/a&gt; which performs a two sided verification of communication between two certificate holding services.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Limiting port ranges of communication&lt;/td&gt;
&lt;td&gt;This recommendation may be a bit self-explanatory, but wherever possible you should only expose the ports on your service that are absolutely essential for communication or metric gathering.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3rd Party Dependency Security&lt;/td&gt;
&lt;td&gt;It is a good practice to regularly scan your application&amp;rsquo;s third party libraries for known security vulnerabilities. Each programming language has a tool for performing this check automatically.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Static Code Analysis&lt;/td&gt;
&lt;td&gt;Most languages provide a way for a snippet of code to be analyzed for any potentially unsafe coding practices. Whenever possible you should perform checks using automated tooling that can scan codebases for common security errors. Some of the tools can be found at: &lt;a href=&#34;https://owasp.org/www-community/Source_Code_Analysis_Tools&#34;&gt;https://owasp.org/www-community/Source_Code_Analysis_Tools&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dynamic probing attacks&lt;/td&gt;
&lt;td&gt;There are a few automated tools that you can run against your service to try some of the well known service attacks. These include SQL injection, CSRF, and XSS. One of the most popular dynamic analysis tools is the &lt;a href=&#34;https://owasp.org/www-project-zap/&#34;&gt;OWASP Zed Attack proxy&lt;/a&gt; tool.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 --&gt;
&lt;h3 id=&#34;code-security&#34;&gt;代码安全&lt;/h3&gt;





&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Code security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代码安全关注领域&lt;/th&gt;
&lt;th&gt;建议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;只允许通过 TLS 访问&lt;/td&gt;
&lt;td&gt;如果你的代码需要通过 TCP 通信，提前与客户端执行 TLS 握手。除了少数情况下，对所有传输内容加密。更进一步，对服务之间的网络流量加密也是一个好主意。这可以通过相互(mutual)过程或 &lt;a href=&#34;https://en.wikipedia.org/wiki/Mutual_authentication&#34;&gt;mTLS&lt;/a&gt; 也就是两个服务都包含证书，对通信进行双向加密和验证。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;限制通信端口范围&lt;/td&gt;
&lt;td&gt;这个建议应该是不言自明的， 但无论啥时候都应该只暴露服务必不可少的通信或度量采集端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三方信赖安全&lt;/td&gt;
&lt;td&gt;定期扫描应用的第三方信赖库是否有已知的安全漏洞是一个好的实践。 每种编辑语言都有自动执行这种检查的工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;静态代码分析&lt;/td&gt;
&lt;td&gt;大多数语言都提供了对代码片断分析检查是否有潜在的不安全代码实践。 无论啥时候都应该使用自动化工作对代码库执行这种检查，以提早发现常见的安全错误。 一些工具可以在这里找: &lt;a href=&#34;https://owasp.org/www-community/Source_Code_Analysis_Tools&#34;&gt;https://owasp.org/www-community/Source_Code_Analysis_Tools&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动态探测攻击&lt;/td&gt;
&lt;td&gt;有几种自动化工具可以用来对着服务运行，尝试一些流行的服务攻击。 包含 SQL 注入， CSRF, 和 XSS. 最流行的动态分析工具之一就是 &lt;a href=&#34;https://owasp.org/www-project-zap/&#34;&gt;OWASP Zed Attack proxy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;相关资料&#34;&gt;相关资料&lt;/h2&gt;
&lt;!--
Learn about related Kubernetes security topics:

* [Pod security standards](/docs/concepts/security/pod-security-standards/)
* [Network policies for Pods](/docs/concepts/services-networking/network-policies/)
* [Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access)
* [Securing your cluster](/docs/tasks/administer-cluster/securing-a-cluster/)
* [Data encryption in transit](/docs/tasks/tls/managing-tls-in-a-cluster/) for the control plane
* [Data encryption at rest](/docs/tasks/administer-cluster/encrypt-data/)
* [Secrets in Kubernetes](/docs/concepts/configuration/secret/)
 --&gt;
&lt;p&gt;更多关于 k8s 安全的主题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/security/pod-security-standards/&#34;&gt;Pod 安全标准&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/services-networking/network-policies/&#34;&gt;Pod 网络策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/security/controlling-access&#34;&gt;对 k8s API 的访问控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/administer-cluster/securing-a-cluster/&#34;&gt;集群网络加固&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;对控制中心&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/tls/managing-tls-in-a-cluster/&#34;&gt;传输中的数据加密&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/administer-cluster/encrypt-data/&#34;&gt;数据落盘加密&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/configuration/secret/&#34;&gt;k8s 中的 Secret&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Pod 安全标准</title>
      <link>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/pod-security-standards/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/pod-security-standards/</guid>
      <description>
        
        
        &lt;!--
---
reviewers:
- tallclair
title: Pod Security Standards
content_type: concept
weight: 10
---
 --&gt;
&lt;!-- overview --&gt;
&lt;!--
Security settings for Pods are typically applied by using [security
contexts](/docs/tasks/configure-pod-container/security-context/). Security Contexts allow for the
definition of privilege and access controls on a per-Pod basis.

The enforcement and policy-based definition of cluster requirements of security contexts has
previously been achieved using [Pod Security Policy](/docs/concepts/policy/pod-security-policy/). A
_Pod Security Policy_ is a cluster-level resource that controls security sensitive aspects of the
Pod specification.

However, numerous means of policy enforcement have arisen that augment or replace the use of
PodSecurityPolicy. The intent of this page is to detail recommended Pod security profiles, decoupled
from any specific instantiation.
 --&gt;
&lt;p&gt;对于 Pod 的安全设置通常是使用
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/configure-pod-container/security-context/&#34;&gt;安全性上下文&lt;/a&gt;.
安全性上下文允许对 Pod 级的权限定义和访问控制。&lt;/p&gt;
&lt;p&gt;实施和基于策略定义的集群安全性上下文要求是通过使用
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/docs/concepts/policy/pod-security-policy/&#34;&gt;Pod 安全性策略&lt;/a&gt;
实现的。 &lt;em&gt;Pod 安全性策略&lt;/em&gt; 是集群级别的资源，用来控制安全性敏感方面的 Pod 定义。&lt;/p&gt;
&lt;p&gt;但是， 多种方式的执行策略会引发争论或替换 PodSecurityPolicy 的使用。 本文的目的是详细推荐
安全策略方案， 与任意指定实例解耦。&lt;/p&gt;
&lt;!-- body --&gt;
&lt;!--
## Policy Types

There is an immediate need for base policy definitions to broadly cover the security spectrum. These
should range from highly restricted to highly flexible:

- **_Privileged_** - Unrestricted policy, providing the widest possible level of permissions. This
  policy allows for known privilege escalations.
- **_Baseline/Default_** - Minimally restrictive policy while preventing known privilege
  escalations. Allows the default (minimally specified) Pod configuration.
- **_Restricted_** - Heavily restricted policy, following current Pod hardening best practices.
 --&gt;
&lt;h2 id=&#34;policy-types&#34;&gt;策略类别&lt;/h2&gt;
&lt;p&gt;安全策略定义来大体上能覆盖安全相关问题。 下面这些从高限制到高灵活性的范围:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Privileged&lt;/em&gt;&lt;/strong&gt; - 不受限策略， 提供最大可能级别的权限。 这个策略允许所有已知权限升级。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Baseline/Default&lt;/em&gt;&lt;/strong&gt; - 在防止已知权限升级的情况下相对最小限制策略。 允许默认(最少配置)的 Pod 配置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Restricted&lt;/em&gt;&lt;/strong&gt; - 严重限制策略， 依照目前 Pod 加固最佳实践&lt;/li&gt;
&lt;/ul&gt;
&lt;!--
## Policies

### Privileged

The Privileged policy is purposely-open, and entirely unrestricted. This type of policy is typically
aimed at system- and infrastructure-level workloads managed by privileged, trusted users.

The privileged policy is defined by an absence of restrictions. For allow-by-default enforcement
mechanisms (such as gatekeeper), the privileged profile may be an absence of applied constraints
rather than an instantiated policy. In contrast, for a deny-by-default mechanism (such as Pod
Security Policy) the privileged policy should enable all controls (disable all restrictions).
 --&gt;
&lt;h2 id=&#34;policies&#34;&gt;策略&lt;/h2&gt;
&lt;h3 id=&#34;privileged&#34;&gt;特权&lt;/h3&gt;
&lt;p&gt;特权策略是以开放为目的的，并且完全没有限制。这个策略类别通常是用于系统级和基础设施级别的工作负载，
它们由特权，受信的用户管理。&lt;/p&gt;
&lt;p&gt;特权策略的定义方式就是没有限制。 对于 默认允许执行机制(如守门人(&lt;code&gt;gatekeeper&lt;/code&gt;)), 特权方案是没有
执行的约束条件而不是一个实际的策略。相反的，在一个 默认拒绝的机制中(如 Pod 安全策略)，特权策略
就应该启用所有控制(关闭所有约束)。&lt;/p&gt;
&lt;!--
### Baseline/Default

The Baseline/Default policy is aimed at ease of adoption for common containerized workloads while
preventing known privilege escalations. This policy is targeted at application operators and
developers of non-critical applications. The following listed controls should be
enforced/disallowed:

&lt;table&gt;
	&lt;caption style=&#34;display:none&#34;&gt;Baseline policy specification&lt;/caption&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;Control&lt;/strong&gt;&lt;/td&gt;
			&lt;td&gt;&lt;strong&gt;Policy&lt;/strong&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Host Namespaces&lt;/td&gt;
			&lt;td&gt;
				Sharing the host namespaces must be disallowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.hostNetwork&lt;br&gt;
				spec.hostPID&lt;br&gt;
				spec.hostIPC&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; false&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Privileged Containers&lt;/td&gt;
			&lt;td&gt;
				Privileged Pods disable most security mechanisms and must be disallowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.privileged&lt;br&gt;
				spec.initContainers[*].securityContext.privileged&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; false, undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Capabilities&lt;/td&gt;
			&lt;td&gt;
				Adding additional capabilities beyond the &lt;a href=&#34;https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities&#34;&gt;default set&lt;/a&gt; must be disallowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.capabilities.add&lt;br&gt;
				spec.initContainers[*].securityContext.capabilities.add&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; empty (or restricted to a known list)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;HostPath Volumes&lt;/td&gt;
			&lt;td&gt;
				HostPath volumes must be forbidden.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.volumes[*].hostPath&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Host Ports&lt;/td&gt;
			&lt;td&gt;
				HostPorts should be disallowed, or at minimum restricted to a known list.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].ports[*].hostPort&lt;br&gt;
				spec.initContainers[*].ports[*].hostPort&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; 0, undefined (or restricted to a known list)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;AppArmor &lt;em&gt;(optional)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
				On supported hosts, the &#39;runtime/default&#39; AppArmor profile is applied by default. The default policy should prevent overriding or disabling the policy, or restrict overrides to an allowed set of profiles.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				metadata.annotations[&#39;container.apparmor.security.beta.kubernetes.io/*&#39;]&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; &#39;runtime/default&#39;, undefined&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;SELinux &lt;em&gt;(optional)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
				Setting custom SELinux options should be disallowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.seLinuxOptions&lt;br&gt;
				spec.containers[*].securityContext.seLinuxOptions&lt;br&gt;
				spec.initContainers[*].securityContext.seLinuxOptions&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;/proc Mount Type&lt;/td&gt;
			&lt;td&gt;
				The default /proc masks are set up to reduce attack surface, and should be required.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.procMount&lt;br&gt;
				spec.initContainers[*].securityContext.procMount&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; undefined/nil, &#39;Default&#39;&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Sysctls&lt;/td&gt;
			&lt;td&gt;
				Sysctls can disable security mechanisms or affect all containers on a host, and should be disallowed except for an allowed &#34;safe&#34; subset.
				A sysctl is considered safe if it is namespaced in the container or the Pod, and it is isolated from other Pods or processes on the same Node.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.sysctls&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt;&lt;br&gt;
				kernel.shm_rmid_forced&lt;br&gt;
				net.ipv4.ip_local_port_range&lt;br&gt;
				net.ipv4.tcp_syncookies&lt;br&gt;
				net.ipv4.ping_group_range&lt;br&gt;
				undefined/empty&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
 --&gt;
&lt;h3 id=&#34;baseline&#34;&gt;基线/默认&lt;/h3&gt;
&lt;p&gt;基线/默认策略的目的是在防止已知的特权升级情况下，让得普通的容器化工作负载来使用。 这个策略的目标
用户是应用运维人员和非关键应用的开发者。 下面列举这这些控制应该受限/不被允许:&lt;/p&gt;
&lt;table&gt;
	&lt;caption style=&#34;display:none&#34;&gt;基线策略规范&lt;/caption&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;控制&lt;/strong&gt;&lt;/td&gt;
			&lt;td&gt;&lt;strong&gt;策略&lt;/strong&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;宿主机命令空间&lt;/td&gt;
			&lt;td&gt;
				Sharing the host namespaces must be disallowed.&lt;br&gt;
        主机命名空间分离必须禁止。
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.hostNetwork&lt;br&gt;
				spec.hostPID&lt;br&gt;
				spec.hostIPC&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; false&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;特权容器&lt;/td&gt;
			&lt;td&gt;
        特权 Pod 禁用了多数安全机制，必须禁止。
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.privileged&lt;br&gt;
				spec.initContainers[*].securityContext.privileged&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; false, undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Capabilities&lt;/td&gt;
			&lt;td&gt;
        [默认集](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)
        外的额外能力是不允许的
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.capabilities.add&lt;br&gt;
				spec.initContainers[*].securityContext.capabilities.add&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; empty (or restricted to a known list)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;HostPath 卷&lt;/td&gt;
			&lt;td&gt;
				HostPath 卷必须禁止&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.volumes[*].hostPath&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;宿主机端口&lt;/td&gt;
			&lt;td&gt;
				宿主机端口应该禁用, 或最少限制在一个已知列表.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].ports[*].hostPort&lt;br&gt;
				spec.initContainers[*].ports[*].hostPort&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; 0, undefined (或限制在一个已知列表)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;AppArmor &lt;em&gt;(可选)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
        在受支持的主机上，默认执行 &#39;runtime/default&#39; AppArmor 方案。 默认策略应该防止被覆盖或
        禁用策略，或限制对允许方案集的覆盖.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				metadata.annotations[&#39;container.apparmor.security.beta.kubernetes.io/*&#39;]&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; &#39;runtime/default&#39;, undefined&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;SELinux &lt;em&gt;(可选)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
        不允许设置自定义SELinux选项.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.seLinuxOptions&lt;br&gt;
				spec.containers[*].securityContext.seLinuxOptions&lt;br&gt;
				spec.initContainers[*].securityContext.seLinuxOptions&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;/proc 挂载类别&lt;/td&gt;
			&lt;td&gt;
        默认的 /proc masks 被设置来减少攻击面， 是必要的.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.procMount&lt;br&gt;
				spec.initContainers[*].securityContext.procMount&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; undefined/nil, &#39;Default&#39;&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Sysctls&lt;/td&gt;
			&lt;td&gt;
        Sysctls 可以禁用安全机制或影响主机上的所有容器，在允许的安全子集外都应该被禁止。
        如果 sysctl 命名空间为容器内或 Pod 内被认为是安全的， 它会被与同一个节点上其它 Pod 或进程隔离.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.sysctls&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt;&lt;br&gt;
				kernel.shm_rmid_forced&lt;br&gt;
				net.ipv4.ip_local_port_range&lt;br&gt;
				net.ipv4.tcp_syncookies&lt;br&gt;
				net.ipv4.ping_group_range&lt;br&gt;
				undefined/empty&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
### Restricted

The Restricted policy is aimed at enforcing current Pod hardening best practices, at the expense of
some compatibility. It is targeted at operators and developers of security-critical applications, as
well as lower-trust users.The following listed controls should be enforced/disallowed:


&lt;table&gt;
	&lt;caption style=&#34;display:none&#34;&gt;Restricted policy specification&lt;/caption&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;Control&lt;/strong&gt;&lt;/td&gt;
			&lt;td&gt;&lt;strong&gt;Policy&lt;/strong&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan=&#34;2&#34;&gt;&lt;em&gt;Everything from the default profile.&lt;/em&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Volume Types&lt;/td&gt;
			&lt;td&gt;
				In addition to restricting HostPath volumes, the restricted profile limits usage of non-core volume types to those defined through PersistentVolumes.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.volumes[*].hostPath&lt;br&gt;
				spec.volumes[*].gcePersistentDisk&lt;br&gt;
				spec.volumes[*].awsElasticBlockStore&lt;br&gt;
				spec.volumes[*].gitRepo&lt;br&gt;
				spec.volumes[*].nfs&lt;br&gt;
				spec.volumes[*].iscsi&lt;br&gt;
				spec.volumes[*].glusterfs&lt;br&gt;
				spec.volumes[*].rbd&lt;br&gt;
				spec.volumes[*].flexVolume&lt;br&gt;
				spec.volumes[*].cinder&lt;br&gt;
				spec.volumes[*].cephFS&lt;br&gt;
				spec.volumes[*].flocker&lt;br&gt;
				spec.volumes[*].fc&lt;br&gt;
				spec.volumes[*].azureFile&lt;br&gt;
				spec.volumes[*].vsphereVolume&lt;br&gt;
				spec.volumes[*].quobyte&lt;br&gt;
				spec.volumes[*].azureDisk&lt;br&gt;
				spec.volumes[*].portworxVolume&lt;br&gt;
				spec.volumes[*].scaleIO&lt;br&gt;
				spec.volumes[*].storageos&lt;br&gt;
				spec.volumes[*].csi&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Privilege Escalation&lt;/td&gt;
			&lt;td&gt;
				Privilege escalation (such as via set-user-ID or set-group-ID file mode) should not be allowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.allowPrivilegeEscalation&lt;br&gt;
				spec.initContainers[*].securityContext.allowPrivilegeEscalation&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; false&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Running as Non-root&lt;/td&gt;
			&lt;td&gt;
				Containers must be required to run as non-root users.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.runAsNonRoot&lt;br&gt;
				spec.containers[*].securityContext.runAsNonRoot&lt;br&gt;
				spec.initContainers[*].securityContext.runAsNonRoot&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; true&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Non-root groups &lt;em&gt;(optional)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
				Containers should be forbidden from running with a root primary or supplementary GID.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.runAsGroup&lt;br&gt;
				spec.securityContext.supplementalGroups[*]&lt;br&gt;
				spec.securityContext.fsGroup&lt;br&gt;
				spec.containers[*].securityContext.runAsGroup&lt;br&gt;
				spec.initContainers[*].securityContext.runAsGroup&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt;&lt;br&gt;
				non-zero&lt;br&gt;
				undefined / nil (except for `*.runAsGroup`)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Seccomp&lt;/td&gt;
			&lt;td&gt;
				The RuntimeDefault seccomp profile must be required, or allow specific additional profiles.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.seccompProfile.type&lt;br&gt;
				spec.containers[*].securityContext.seccompProfile&lt;br&gt;
				spec.initContainers[*].securityContext.seccompProfile&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt;&lt;br&gt;
				&#39;runtime/default&#39;&lt;br&gt;
				undefined / nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
 --&gt;
&lt;h3 id=&#34;restricted&#34;&gt;受限的&lt;/h3&gt;
&lt;p&gt;受限策略旨在实施目前的 Pod 加固最佳实践，代价就是牺牲一些兼容性。目标用户为高安全性应用的运维和
开发人员，也可以是低信任度的用户。 下面列举的控制项应该受限/不被允许:&lt;/p&gt;
&lt;table&gt;
	&lt;caption style=&#34;display:none&#34;&gt;受限策略规范&lt;/caption&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;Control&lt;/strong&gt;&lt;/td&gt;
			&lt;td&gt;&lt;strong&gt;Policy&lt;/strong&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan=&#34;2&#34;&gt;&lt;em&gt;所有都来自默认方案&lt;/em&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;卷类型&lt;/td&gt;
			&lt;td&gt;
        为了进一步限制 HostPath 卷， 受限方案在定义 PV 时限制了这些非核心卷类型的使用.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.volumes[*].hostPath&lt;br&gt;
				spec.volumes[*].gcePersistentDisk&lt;br&gt;
				spec.volumes[*].awsElasticBlockStore&lt;br&gt;
				spec.volumes[*].gitRepo&lt;br&gt;
				spec.volumes[*].nfs&lt;br&gt;
				spec.volumes[*].iscsi&lt;br&gt;
				spec.volumes[*].glusterfs&lt;br&gt;
				spec.volumes[*].rbd&lt;br&gt;
				spec.volumes[*].flexVolume&lt;br&gt;
				spec.volumes[*].cinder&lt;br&gt;
				spec.volumes[*].cephFS&lt;br&gt;
				spec.volumes[*].flocker&lt;br&gt;
				spec.volumes[*].fc&lt;br&gt;
				spec.volumes[*].azureFile&lt;br&gt;
				spec.volumes[*].vsphereVolume&lt;br&gt;
				spec.volumes[*].quobyte&lt;br&gt;
				spec.volumes[*].azureDisk&lt;br&gt;
				spec.volumes[*].portworxVolume&lt;br&gt;
				spec.volumes[*].scaleIO&lt;br&gt;
				spec.volumes[*].storageos&lt;br&gt;
				spec.volumes[*].csi&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;权限提升&lt;/td&gt;
			&lt;td&gt;
				权限提升 (如通过设置 set-user-ID 或 set-group-ID 文件模式) 应该被禁止.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.allowPrivilegeEscalation&lt;br&gt;
				spec.initContainers[*].securityContext.allowPrivilegeEscalation&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; false&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;以 非root用户运行&lt;/td&gt;
			&lt;td&gt;
				要求容器必须以非 root 用户运行 .&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.runAsNonRoot&lt;br&gt;
				spec.containers[*].securityContext.runAsNonRoot&lt;br&gt;
				spec.initContainers[*].securityContext.runAsNonRoot&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; true&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;非root 组 &lt;em&gt;(可选)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
				容器应该避免以 root 主要或辅助的 GID 来运行 .&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.runAsGroup&lt;br&gt;
				spec.securityContext.supplementalGroups[*]&lt;br&gt;
				spec.securityContext.fsGroup&lt;br&gt;
				spec.containers[*].securityContext.runAsGroup&lt;br&gt;
				spec.initContainers[*].securityContext.runAsGroup&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt;&lt;br&gt;
				non-zero&lt;br&gt;
				undefined / nil (`*.runAsGroup` 除外)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Seccomp&lt;/td&gt;
			&lt;td&gt;
				必须要使用 RuntimeDefault 安全计算模式(seccomp) 方案，或允许指定额外方案.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.seccompProfile.type&lt;br&gt;
				spec.containers[*].securityContext.seccompProfile&lt;br&gt;
				spec.initContainers[*].securityContext.seccompProfile&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt;&lt;br&gt;
				&#39;runtime/default&#39;&lt;br&gt;
				undefined / nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
## Policy Instantiation

Decoupling policy definition from policy instantiation allows for a common understanding and
consistent language of policies across clusters, independent of the underlying enforcement
mechanism.

As mechanisms mature, they will be defined below on a per-policy basis. The methods of enforcement
of individual policies are not defined here.

[**PodSecurityPolicy**](/docs/concepts/policy/pod-security-policy/)

- [Privileged](https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/privileged-psp.yaml)
- [Baseline](https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/baseline-psp.yaml)
- [Restricted](https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml)
 --&gt;
&lt;h2 id=&#34;policy-instantiation&#34;&gt;策略安装&lt;/h2&gt;
&lt;p&gt;将策略定义从策略安装中解耦出来可以使用其成功一个共识和跨集群策略的统一语言，独立于底层的执行机制。&lt;/p&gt;
&lt;p&gt;作为成熟机制， 它们会定义在单个策略基础之下。 每个策略的执行方法不是在这里定义的。
&lt;blockquote&gt;
  &lt;div&gt;&lt;strong&gt;TODO: &lt;/strong&gt;说得不太清楚，需要实践理解后再考虑怎么修改&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/policy/pod-security-policy/&#34;&gt;&lt;strong&gt;PodSecurityPolicy&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/privileged-psp.yaml&#34;&gt;Privileged&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/baseline-psp.yaml&#34;&gt;Baseline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml&#34;&gt;Restricted&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--
## FAQ

### Why isn&#39;t there a profile between privileged and default?

The three profiles defined here have a clear linear progression from most secure (restricted) to least
secure (privileged), and cover a broad set of workloads. Privileges required above the baseline
policy are typically very application specific, so we do not offer a standard profile in this
niche. This is not to say that the privileged profile should always be used in this case, but that
policies in this space need to be defined on a case-by-case basis.

SIG Auth may reconsider this position in the future, should a clear need for other profiles arise.
 --&gt;
&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;
&lt;h3 id=&#34;why-isnt-there-a-profile-between-privileged-and-default&#34;&gt;为啥在 特权(privileged)和基线(default) 之间没有一个中间方案 &lt;/h3&gt;
&lt;p&gt;这里定义的三个方案有一个明显的线性变化， 从最安全(受限)到最不安全(特权)，覆盖了广泛的工作负载集。
在基线策略之上的权限需求通常是特别具体到应用的， 所以在这个层面我会不需要提供一个标准的方案。
这也不是说特权方案就会始终用于这个应用场景，但是在这个地方用到的策略就需要单个场景级别地来定义。&lt;/p&gt;
&lt;p&gt;如果有明确的其它方案的需求提出来，未来 SIG Auth 可以重新考虑加到这里。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;div&gt;&lt;strong&gt;TODO: &lt;/strong&gt;说得不太清楚，需要实践理解后再考虑怎么修改&lt;/div&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;whats-the-difference-between-a-security-policy-and-a-security-context&#34;&gt;安全策略与安全上下文之间的区别&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/configure-pod-container/security-context/&#34;&gt;安全上下文&lt;/a&gt; 是在
Pod 和 容器的运行时上配置。 安全上下文是在Pod 配置中作为 Pod 和容器定义的一部分存在的，代表
传递给容器运行时的参数。&lt;/p&gt;
&lt;p&gt;安全策略是在安全上下文中执行指定设置的控制面板机制，连同安全上下文之外的其它参数。 从 2020 年 2 月
形如，当前原生执行这些安全策略的方案就是
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/policy/pod-security-policy/&#34;&gt;Pod 安全策略&lt;/a&gt; - 一个在集群中
以中心化方式在 Pod 上执行安全策略的机制。 其它执行安全策略的方式也已经在 k8s 生态中开发了，就
如
&lt;a href=&#34;https://github.com/open-policy-agent/gatekeeper&#34;&gt;OPA Gatekeeper&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;what-profiles-should-i-apply-to-my-windows-pods&#34;&gt;Windows Pod 应该执行哪个方案&lt;/h3&gt;
&lt;p&gt;windows 在 k8s 中是有些限制且与基于 Linux 的标准工作负载有明显差异的。 特别是  Pod 的 SecurityContext
字段在
&lt;a href=&#34;https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#v1-podsecuritycontext&#34;&gt;Windows Pod 上是没有效果的&lt;/a&gt;. 因此，目前是没有标准的 Pod 安全方案存在的。&lt;/p&gt;
&lt;h3 id=&#34;what-about-sandboxed-pods&#34;&gt;沙盒 Pod 是个啥情况&lt;/h3&gt;
&lt;p&gt;目前没有一个标准的 API 可以控制一个 Pod 是否被认为是沙盒。沙盒 Pod 可能可以通过使用一个沙盒
运行时(如 gVisor 或 Kata容器)来识别， 但没有对沙盒运行时有一个标准的定义。&lt;/p&gt;
&lt;p&gt;对沙盒工作负载的保护需求可能与其它的不同。 例如，在工作负载从底层内核隔离后对特殊权限的限制需求就减少了。
这使得工作负载在隔离的情况下提升指定的权限。&lt;/p&gt;
&lt;p&gt;另外，对沙盒工作负载的保护调度信赖沙盒的实现方式。 例如，没有一个推荐策略可以推荐给所有的沙盒工作负载。&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
