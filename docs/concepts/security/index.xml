<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes – 安全</title>
    <link>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/</link>
    <description>Recent content in 安全 on Kubernetes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	  <atom:link href="https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: 云原生安全概述</title>
      <link>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/overview/</guid>
      <description>
        
        
        &lt;!--
---
reviewers:
- zparnold
title: Overview of Cloud Native Security
content_type: concept
weight: 10
---
 --&gt;
&lt;!-- overview --&gt;
&lt;!--
This overview defines a model for thinking about Kubernetes security in the context of Cloud Native security.
 --&gt;
&lt;p&gt;本文定义了一个模式用于思考在云原生安全语境下的 k8s 安全&lt;/p&gt;
&lt;blockquote class=&#34;warning&#34;&gt;
  &lt;div&gt;&lt;strong&gt;警告：&lt;/strong&gt; &lt;!--
This container security model provides suggestions, not proven information security policies.
 --&gt;
&lt;p&gt;这个容器安全模型只提供建议，并不提供安全策略信息。&lt;/div&gt;
&lt;/blockquote&gt;

&lt;!-- body --&gt;
&lt;!--
## The 4C&#39;s of Cloud Native security

You can think about security in layers. The 4C&#39;s of Cloud Native security are Cloud,
Clusters, Containers, and Code.

&lt;blockquote class=&#34;note&#34;&gt;
  &lt;div&gt;&lt;strong&gt;说明：&lt;/strong&gt; This layered approach augments the &lt;a href=&#34;https://en.wikipedia.org/wiki/Defense_in_depth_(computing)&#34;&gt;defense in depth&lt;/a&gt;
computing approach to security, which is widely regarded as a best practice for securing
software systems.&lt;/div&gt;
&lt;/blockquote&gt;


&lt;figure&gt;
    &lt;img src=&#34;https://lostsquirrel.github.io/k8sDocs/images/docs/4c.png&#34;/&gt; &lt;figcaption&gt;
            &lt;h4&gt;The 4C&amp;#39;s of Cloud Native Security&lt;/h4&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;


Each layer of the Cloud Native security model builds upon the next outermost layer.
The Code layer benefits from strong base (Cloud, Cluster, Container) security layers.
You cannot safeguard against poor security standards in the base layers by addressing
security at the Code level.
 --&gt;
&lt;h2 id=&#34;the-4cs-of-cloud-native-security&#34;&gt;云原生安全的 4C 概念&lt;/h2&gt;
&lt;p&gt;可以将安全进行分层。 云原生安全的 4 个 C 就是云(Cloud), 集群(Clusters), 容器(Containers),
和 代码(Code).&lt;/p&gt;
&lt;blockquote class=&#34;note&#34;&gt;
  &lt;div&gt;&lt;strong&gt;说明：&lt;/strong&gt; 这种计算机安全通过分层的方式实现在
&lt;a href=&#34;https://en.wikipedia.org/wiki/Defense_in_depth_(computing)&#34;&gt;纵深防御&lt;/a&gt;
中有讨论，也是广泛认可作为软件系统安全的最佳实践。&lt;/div&gt;
&lt;/blockquote&gt;

&lt;figure&gt;
    &lt;img src=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/images/docs/4c.png&#34;/&gt; &lt;figcaption&gt;
            &lt;h4&gt;云原生安全的 4C 概念&lt;/h4&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;云原生安全模型的每一层都是构建于其外层的。 代码(Code)层受益于 (Cloud, Cluster, Container)
层的安全基础。 不能希望在基础层安全薄弱的情况下只通过代码层的安全策略就能提供良好的安全保障。&lt;/p&gt;
&lt;!--
## Cloud

In many ways, the Cloud (or co-located servers, or the corporate datacenter) is the
[trusted computing base](https://en.wikipedia.org/wiki/Trusted_computing_base)
of a Kubernetes cluster. If the Cloud layer is vulnerable (or
configured in a vulnerable way) then there is no guarantee that the components built
on top of this base are secure. Each cloud provider makes security recommendations
for running workloads securely in their environment.
 --&gt;
&lt;h2 id=&#34;cloud&#34;&gt;云环境&lt;/h2&gt;
&lt;p&gt;在大多数情况下， 云环境(或同一个地方的服务器，或公司的数据中心) 在 k8s 集群中是
&lt;a href=&#34;https://en.wikipedia.org/wiki/Trusted_computing_base&#34;&gt;受信任的计算基础&lt;/a&gt;。 如果在云
环境层是不安全的(或者以一个不安全的方式配置的)，那么基于这个基础构建的组建也是没有安全保证的。
每个云提供商都对在其环境上安全运行工作负载的安全建议&lt;/p&gt;
&lt;!--
### Cloud provider security

If you are running a Kubernetes cluster on your own hardware or a different cloud provider,
consult your documentation for security best practices.
Here are links to some of the popular cloud providers&#39; security documentation:






&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Cloud provider security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IaaS Provider&lt;/th&gt;
&lt;th&gt;Link&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Alibaba Cloud&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.alibabacloud.com/trust-center&#34;&gt;https://www.alibabacloud.com/trust-center&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Amazon Web Services&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://aws.amazon.com/security/&#34;&gt;https://aws.amazon.com/security/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Google Cloud Platform&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://cloud.google.com/security/&#34;&gt;https://cloud.google.com/security/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IBM Cloud&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.ibm.com/cloud/security&#34;&gt;https://www.ibm.com/cloud/security&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microsoft Azure&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/security/azure-security&#34;&gt;https://docs.microsoft.com/en-us/azure/security/azure-security&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VMWare VSphere&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.vmware.com/security/hardening-guides.html&#34;&gt;https://www.vmware.com/security/hardening-guides.html&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 --&gt;
&lt;h3 id=&#34;Cloud-provider-security&#34;&gt;云提供商安全&lt;/h3&gt;
&lt;p&gt;如果 k8s 集群运行在自己的硬件上或不同的云提供商，请查询相应文档获取最佳安全实践。
下面是一些主流云提供商的安全文档的链接地址.&lt;/p&gt;





&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;云提供商安全&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IaaS 提供商&lt;/th&gt;
&lt;th&gt;链接&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Alibaba Cloud&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.alibabacloud.com/trust-center&#34;&gt;https://www.alibabacloud.com/trust-center&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Amazon Web Services&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://aws.amazon.com/security/&#34;&gt;https://aws.amazon.com/security/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Google Cloud Platform&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://cloud.google.com/security/&#34;&gt;https://cloud.google.com/security/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IBM Cloud&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.ibm.com/cloud/security&#34;&gt;https://www.ibm.com/cloud/security&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microsoft Azure&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/azure/security/azure-security&#34;&gt;https://docs.microsoft.com/en-us/azure/security/azure-security&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VMWare VSphere&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://www.vmware.com/security/hardening-guides.html&#34;&gt;https://www.vmware.com/security/hardening-guides.html&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;!--
### Infrastructure security {#infrastructure-security}

Suggestions for securing your infrastructure in a Kubernetes cluster:






&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Infrastructure security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Area of Concern for Kubernetes Infrastructure&lt;/th&gt;
&lt;th&gt;Recommendation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Network access to API Server (Control plane)&lt;/td&gt;
&lt;td&gt;All access to the Kubernetes control plane is not allowed publicly on the internet and is controlled by network access control lists restricted to the set of IP addresses needed to administer the cluster.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Network access to Nodes (nodes)&lt;/td&gt;
&lt;td&gt;Nodes should be configured to &lt;em&gt;only&lt;/em&gt; accept connections (via network access control lists)from the control plane on the specified ports, and accept connections for services in Kubernetes of type NodePort and LoadBalancer. If possible, these nodes should not be exposed on the public internet entirely.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kubernetes access to Cloud Provider API&lt;/td&gt;
&lt;td&gt;Each cloud provider needs to grant a different set of permissions to the Kubernetes control plane and nodes. It is best to provide the cluster with cloud provider access that follows the &lt;a href=&#34;https://en.wikipedia.org/wiki/Principle_of_least_privilege&#34;&gt;principle of least privilege&lt;/a&gt; for the resources it needs to administer. The &lt;a href=&#34;https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles&#34;&gt;Kops documentation&lt;/a&gt; provides information about IAM policies and roles.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access to etcd&lt;/td&gt;
&lt;td&gt;Access to etcd (the datastore of Kubernetes) should be limited to the control plane only. Depending on your configuration, you should attempt to use etcd over TLS. More information can be found in the &lt;a href=&#34;https://github.com/etcd-io/etcd/tree/master/Documentation&#34;&gt;etcd documentation&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;etcd Encryption&lt;/td&gt;
&lt;td&gt;Wherever possible it&amp;rsquo;s a good practice to encrypt all drives at rest, but since etcd holds the state of the entire cluster (including Secrets) its disk should especially be encrypted at rest.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 --&gt;
&lt;!--
### Infrastructure security {#infrastructure-security}

Suggestions for securing your infrastructure in a Kubernetes cluster:






&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Infrastructure security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Area of Concern for Kubernetes Infrastructure&lt;/th&gt;
&lt;th&gt;Recommendation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Network access to API Server (Control plane)&lt;/td&gt;
&lt;td&gt;All access to the Kubernetes control plane is not allowed publicly on the internet and is controlled by network access control lists restricted to the set of IP addresses needed to administer the cluster.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Network access to Nodes (nodes)&lt;/td&gt;
&lt;td&gt;Nodes should be configured to &lt;em&gt;only&lt;/em&gt; accept connections (via network access control lists)from the control plane on the specified ports, and accept connections for services in Kubernetes of type NodePort and LoadBalancer. If possible, these nodes should not be exposed on the public internet entirely.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kubernetes access to Cloud Provider API&lt;/td&gt;
&lt;td&gt;Each cloud provider needs to grant a different set of permissions to the Kubernetes control plane and nodes. It is best to provide the cluster with cloud provider access that follows the &lt;a href=&#34;https://en.wikipedia.org/wiki/Principle_of_least_privilege&#34;&gt;principle of least privilege&lt;/a&gt; for the resources it needs to administer. The &lt;a href=&#34;https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles&#34;&gt;Kops documentation&lt;/a&gt; provides information about IAM policies and roles.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access to etcd&lt;/td&gt;
&lt;td&gt;Access to etcd (the datastore of Kubernetes) should be limited to the control plane only. Depending on your configuration, you should attempt to use etcd over TLS. More information can be found in the &lt;a href=&#34;https://github.com/etcd-io/etcd/tree/master/Documentation&#34;&gt;etcd documentation&lt;/a&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;etcd Encryption&lt;/td&gt;
&lt;td&gt;Wherever possible it&amp;rsquo;s a good practice to encrypt all drives at rest, but since etcd holds the state of the entire cluster (including Secrets) its disk should especially be encrypted at rest.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 --&gt;
&lt;h3 id=&#34;infrastructure-security&#34;&gt;基础设施安全&lt;/h3&gt;
&lt;p&gt;k8s 集群基础设计安全加固建议:&lt;/p&gt;





&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;基础设施安全&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;k8s 基础设计关注领域&lt;/th&gt;
&lt;th&gt;推荐&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;访问 API 服务 (控制中心) 的网络&lt;/td&gt;
&lt;td&gt;k8s 控制中心是不允许任意来自公共互联网的访问，并且对控制中心的访问应该限制在那些需要管理集群的 IP 集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问节点 (nodes) 的网络&lt;/td&gt;
&lt;td&gt;节点应该配置成 &lt;em&gt;只&lt;/em&gt; 允许来自控制中心访问指定端口的连接(通过网络访问控制列表)，和接收来自 k8s 中 NodePort 和 LoadBalancer 类型 Service 的连接。 如果可能，避免让所有的节点都暴露到互联网。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;k8s 对云提供商 API 的访问&lt;/td&gt;
&lt;td&gt;每个云提供商需要给 k8s 控制中心和节点授予不同个权限集。 在授予集群云提供商访问权限时，依照&lt;a href=&#34;https://en.wikipedia.org/wiki/Principle_of_least_privilege&#34;&gt;最小权限原则&lt;/a&gt;，只给予其所需要管理的资源。 &lt;a href=&#34;https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles&#34;&gt;Kops documentation&lt;/a&gt; 文档提供了关于 IAM 和角色的信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问 etcd&lt;/td&gt;
&lt;td&gt;对 etcd (k8s 的数据源)应该限制到只给控制中心。 基于配置，应该使用配置有 TLS 的 etcd。 更多信息可以在 &lt;a href=&#34;https://github.com/etcd-io/etcd/tree/master/Documentation&#34;&gt;etcd 文档&lt;/a&gt;中找到.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;etcd 加密&lt;/td&gt;
&lt;td&gt;如果可能，对所有驱动器在落盘时加密是一种好的实践，但因为 etcd 中存放了整个集群的状态(包括 Secret)它的数据最应该在落盘时加密。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;div&gt;&lt;strong&gt;TODO: &lt;/strong&gt;说得不太清楚，需要实践理解后再考虑怎么修改&lt;/div&gt;
&lt;/blockquote&gt;

&lt;!--
## Cluster

There are two areas of concern for securing Kubernetes:

* Securing the cluster components that are configurable
* Securing the applications which run in the cluster
 --&gt;
&lt;h2 id=&#34;cluster&#34;&gt;集群&lt;/h2&gt;
&lt;p&gt;在对 k8s 安全加固时有两个值得关注的领域：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全加固那些可配置的集群组件&lt;/li&gt;
&lt;li&gt;安全加固那些运行在集群中的应用&lt;/li&gt;
&lt;/ul&gt;
&lt;!--
### Components of the Cluster {#cluster-components}

If you want to protect your cluster from accidental or malicious access and adopt
good information practices, read and follow the advice about
[securing your cluster](/docs/tasks/administer-cluster/securing-a-cluster/).
 --&gt;
&lt;h3 id=&#34;cluster-components&#34;&gt;集群的组件&lt;/h3&gt;
&lt;p&gt;如果希望保护集群免于偶然或恶意的访问和彩良好的信息实践，请阅读下面的建议
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/administer-cluster/securing-a-cluster/&#34;&gt;集群安全加固&lt;/a&gt;.&lt;/p&gt;
&lt;!--
### Components in the cluster (your application) {#cluster-applications}

Depending on the attack surface of your application, you may want to focus on specific
aspects of security. For example: If you are running a service (Service A) that is critical
in a chain of other resources and a separate workload (Service B) which is
vulnerable to a resource exhaustion attack then the risk of compromising Service A
is high if you do not limit the resources of Service B. The following table lists
areas of security concerns and recommendations for securing workloads running in Kubernetes:

Area of Concern for Workload Security | Recommendation |
------------------------------ | --------------------- |
RBAC Authorization (Access to the Kubernetes API) | https://kubernetes.io/docs/reference/access-authn-authz/rbac/
Authentication | https://kubernetes.io/docs/concepts/security/controlling-access/
Application secrets management (and encrypting them in etcd at rest) | https://kubernetes.io/docs/concepts/configuration/secret/ &lt;br&gt; https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/
Pod Security Policies | https://kubernetes.io/docs/concepts/policy/pod-security-policy/
Quality of Service (and Cluster resource management) | https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/
Network Policies | https://kubernetes.io/docs/concepts/services-networking/network-policies/
TLS For Kubernetes Ingress | https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
 --&gt;
&lt;h3 id=&#34;cluster-applications&#34;&gt;集群中的组件 (你的应用)&lt;/h3&gt;
&lt;p&gt;基于应用的攻击面，可能希望专注于某个方面的安全。 例如: 如果运行了一个服务(Service A)它是与其它资源
组成的链中的关键，另一个工作负载 (Service B), 这应用面对资源枯竭攻击是很脆弱的，如果不对 Service B
进行资源限制则会让 Service A 被攻陷的风险变高。下面表格里面列举安全关注领域和加固集群中运行的工作
负载安全的建议:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;工作负载安全关注领域&lt;/th&gt;
&lt;th&gt;建议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RBAC 授权 (对 k8s API 的访问)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/rbac/&#34;&gt;https://kubernetes.io/docs/reference/access-authn-authz/rbac/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;认证方式&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/security/controlling-access/&#34;&gt;https://kubernetes.io/docs/concepts/security/controlling-access/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;应用 Secret 管理 (和其在 etcd 落盘时加密)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/configuration/secret/&#34;&gt;https://kubernetes.io/docs/concepts/configuration/secret/&lt;/a&gt; &lt;br&gt; &lt;a href=&#34;https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/&#34;&gt;https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pod 安全策略&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/policy/pod-security-policy/&#34;&gt;https://kubernetes.io/docs/concepts/policy/pod-security-policy/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务资源 (和集群资源管理)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/&#34;&gt;https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络策略&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/network-policies/&#34;&gt;https://kubernetes.io/docs/concepts/services-networking/network-policies/&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;为 k8s Ingress 添加 TLS&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/#tls&#34;&gt;https://kubernetes.io/docs/concepts/services-networking/ingress/#tls&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
## Container

Container security is outside the scope of this guide. Here are general recommendations and
links to explore this topic:

Area of Concern for Containers | Recommendation |
------------------------------ | -------------- |
Container Vulnerability Scanning and OS Dependency Security | As part of an image build step, you should scan your containers for known vulnerabilities.
Image Signing and Enforcement | Sign container images to maintain a system of trust for the content of your containers.
Disallow privileged users | When constructing containers, consult your documentation for how to create users inside of the containers that have the least level of operating system privilege necessary in order to carry out the goal of the container.
 --&gt;
&lt;h2 id=&#34;container&#34;&gt;容器&lt;/h2&gt;
&lt;p&gt;容器安全不在本文的讨论范围。 下面是一些通用的建议和关于本话题的延伸阅读链接:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;容器安全关注领域&lt;/th&gt;
&lt;th&gt;建议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;容器漏洞扫描 和 操作系统信赖安全&lt;/td&gt;
&lt;td&gt;作为一个镜像构建的步骤，应该对容器进行已知漏洞扫描。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;镜像签名和验签&lt;/td&gt;
&lt;td&gt;容器镜像的签名可以维护系统对容器内存的信任&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;禁用特权用户&lt;/td&gt;
&lt;td&gt;在构建容器时，查询文档关于怎么创建可以实现容器目标的最小操作系统权限的用户&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
## Code

Application code is one of the primary attack surfaces over which you have the most control.
While securing application code is outside of the Kubernetes security topic, here
are recommendations to protect application code:
 --&gt;
&lt;h2 id=&#34;code&#34;&gt;代码&lt;/h2&gt;
&lt;p&gt;应用代码是一个最受开发者控制的主要攻击面之一。 因为对应用代码的安全加固不在 k8s 安全话题之内，下面
是一些保护应用代码的建议:&lt;/p&gt;
&lt;!--
### Code security






&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Code security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Area of Concern for Code&lt;/th&gt;
&lt;th&gt;Recommendation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Access over TLS only&lt;/td&gt;
&lt;td&gt;If your code needs to communicate by TCP, perform a TLS handshake with the client ahead of time. With the exception of a few cases, encrypt everything in transit. Going one step further, it&amp;rsquo;s a good idea to encrypt network traffic between services. This can be done through a process known as mutual or &lt;a href=&#34;https://en.wikipedia.org/wiki/Mutual_authentication&#34;&gt;mTLS&lt;/a&gt; which performs a two sided verification of communication between two certificate holding services.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Limiting port ranges of communication&lt;/td&gt;
&lt;td&gt;This recommendation may be a bit self-explanatory, but wherever possible you should only expose the ports on your service that are absolutely essential for communication or metric gathering.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3rd Party Dependency Security&lt;/td&gt;
&lt;td&gt;It is a good practice to regularly scan your application&amp;rsquo;s third party libraries for known security vulnerabilities. Each programming language has a tool for performing this check automatically.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Static Code Analysis&lt;/td&gt;
&lt;td&gt;Most languages provide a way for a snippet of code to be analyzed for any potentially unsafe coding practices. Whenever possible you should perform checks using automated tooling that can scan codebases for common security errors. Some of the tools can be found at: &lt;a href=&#34;https://owasp.org/www-community/Source_Code_Analysis_Tools&#34;&gt;https://owasp.org/www-community/Source_Code_Analysis_Tools&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dynamic probing attacks&lt;/td&gt;
&lt;td&gt;There are a few automated tools that you can run against your service to try some of the well known service attacks. These include SQL injection, CSRF, and XSS. One of the most popular dynamic analysis tools is the &lt;a href=&#34;https://owasp.org/www-project-zap/&#34;&gt;OWASP Zed Attack proxy&lt;/a&gt; tool.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

 --&gt;
&lt;h3 id=&#34;code-security&#34;&gt;代码安全&lt;/h3&gt;





&lt;table&gt;&lt;caption style=&#34;display: none;&#34;&gt;Code security&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代码安全关注领域&lt;/th&gt;
&lt;th&gt;建议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;只允许通过 TLS 访问&lt;/td&gt;
&lt;td&gt;如果你的代码需要通过 TCP 通信，提前与客户端执行 TLS 握手。除了少数情况下，对所有传输内容加密。更进一步，对服务之间的网络流量加密也是一个好主意。这可以通过相互(mutual)过程或 &lt;a href=&#34;https://en.wikipedia.org/wiki/Mutual_authentication&#34;&gt;mTLS&lt;/a&gt; 也就是两个服务都包含证书，对通信进行双向加密和验证。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;限制通信端口范围&lt;/td&gt;
&lt;td&gt;这个建议应该是不言自明的， 但无论啥时候都应该只暴露服务必不可少的通信或度量采集端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三方信赖安全&lt;/td&gt;
&lt;td&gt;定期扫描应用的第三方信赖库是否有已知的安全漏洞是一个好的实践。 每种编辑语言都有自动执行这种检查的工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;静态代码分析&lt;/td&gt;
&lt;td&gt;大多数语言都提供了对代码片断分析检查是否有潜在的不安全代码实践。 无论啥时候都应该使用自动化工作对代码库执行这种检查，以提早发现常见的安全错误。 一些工具可以在这里找: &lt;a href=&#34;https://owasp.org/www-community/Source_Code_Analysis_Tools&#34;&gt;https://owasp.org/www-community/Source_Code_Analysis_Tools&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动态探测攻击&lt;/td&gt;
&lt;td&gt;有几种自动化工具可以用来对着服务运行，尝试一些流行的服务攻击。 包含 SQL 注入， CSRF, 和 XSS. 最流行的动态分析工具之一就是 &lt;a href=&#34;https://owasp.org/www-project-zap/&#34;&gt;OWASP Zed Attack proxy&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;相关资料&#34;&gt;相关资料&lt;/h2&gt;
&lt;!--
Learn about related Kubernetes security topics:

* [Pod security standards](/docs/concepts/security/pod-security-standards/)
* [Network policies for Pods](/docs/concepts/services-networking/network-policies/)
* [Controlling Access to the Kubernetes API](/docs/concepts/security/controlling-access)
* [Securing your cluster](/docs/tasks/administer-cluster/securing-a-cluster/)
* [Data encryption in transit](/docs/tasks/tls/managing-tls-in-a-cluster/) for the control plane
* [Data encryption at rest](/docs/tasks/administer-cluster/encrypt-data/)
* [Secrets in Kubernetes](/docs/concepts/configuration/secret/)
 --&gt;
&lt;p&gt;更多关于 k8s 安全的主题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/security/pod-security-standards/&#34;&gt;Pod 安全标准&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/services-networking/network-policies/&#34;&gt;Pod 网络策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/security/controlling-access&#34;&gt;对 k8s API 的访问控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/administer-cluster/securing-a-cluster/&#34;&gt;集群网络加固&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;对控制中心&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/tls/managing-tls-in-a-cluster/&#34;&gt;传输中的数据加密&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/administer-cluster/encrypt-data/&#34;&gt;数据落盘加密&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/configuration/secret/&#34;&gt;k8s 中的 Secret&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Pod 安全标准</title>
      <link>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/pod-security-standards/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/pod-security-standards/</guid>
      <description>
        
        
        &lt;!--
---
reviewers:
- tallclair
title: Pod Security Standards
content_type: concept
weight: 10
---
 --&gt;
&lt;!-- overview --&gt;
&lt;!--
Security settings for Pods are typically applied by using [security
contexts](/docs/tasks/configure-pod-container/security-context/). Security Contexts allow for the
definition of privilege and access controls on a per-Pod basis.

The enforcement and policy-based definition of cluster requirements of security contexts has
previously been achieved using [Pod Security Policy](/docs/concepts/policy/pod-security-policy/). A
_Pod Security Policy_ is a cluster-level resource that controls security sensitive aspects of the
Pod specification.

However, numerous means of policy enforcement have arisen that augment or replace the use of
PodSecurityPolicy. The intent of this page is to detail recommended Pod security profiles, decoupled
from any specific instantiation.
 --&gt;
&lt;p&gt;对于 Pod 的安全设置通常是使用
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/configure-pod-container/security-context/&#34;&gt;安全性上下文&lt;/a&gt;.
安全性上下文允许对 Pod 级的权限定义和访问控制。&lt;/p&gt;
&lt;p&gt;实施和基于策略定义的集群安全性上下文要求是通过使用
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/docs/concepts/policy/pod-security-policy/&#34;&gt;Pod 安全性策略&lt;/a&gt;
实现的。 &lt;em&gt;Pod 安全性策略&lt;/em&gt; 是集群级别的资源，用来控制安全性敏感方面的 Pod 定义。&lt;/p&gt;
&lt;p&gt;但是， 多种方式的执行策略会引发争论或替换 PodSecurityPolicy 的使用。 本文的目的是详细推荐
安全策略方案， 与任意指定实例解耦。&lt;/p&gt;
&lt;!-- body --&gt;
&lt;!--
## Policy Types

There is an immediate need for base policy definitions to broadly cover the security spectrum. These
should range from highly restricted to highly flexible:

- **_Privileged_** - Unrestricted policy, providing the widest possible level of permissions. This
  policy allows for known privilege escalations.
- **_Baseline/Default_** - Minimally restrictive policy while preventing known privilege
  escalations. Allows the default (minimally specified) Pod configuration.
- **_Restricted_** - Heavily restricted policy, following current Pod hardening best practices.
 --&gt;
&lt;h2 id=&#34;policy-types&#34;&gt;策略类别&lt;/h2&gt;
&lt;p&gt;安全策略定义来大体上能覆盖安全相关问题。 下面这些从高限制到高灵活性的范围:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Privileged&lt;/em&gt;&lt;/strong&gt; - 不受限策略， 提供最大可能级别的权限。 这个策略允许所有已知权限升级。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Baseline/Default&lt;/em&gt;&lt;/strong&gt; - 在防止已知权限升级的情况下相对最小限制策略。 允许默认(最少配置)的 Pod 配置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Restricted&lt;/em&gt;&lt;/strong&gt; - 严重限制策略， 依照目前 Pod 加固最佳实践&lt;/li&gt;
&lt;/ul&gt;
&lt;!--
## Policies

### Privileged

The Privileged policy is purposely-open, and entirely unrestricted. This type of policy is typically
aimed at system- and infrastructure-level workloads managed by privileged, trusted users.

The privileged policy is defined by an absence of restrictions. For allow-by-default enforcement
mechanisms (such as gatekeeper), the privileged profile may be an absence of applied constraints
rather than an instantiated policy. In contrast, for a deny-by-default mechanism (such as Pod
Security Policy) the privileged policy should enable all controls (disable all restrictions).
 --&gt;
&lt;h2 id=&#34;policies&#34;&gt;策略&lt;/h2&gt;
&lt;h3 id=&#34;privileged&#34;&gt;特权&lt;/h3&gt;
&lt;p&gt;特权策略是以开放为目的的，并且完全没有限制。这个策略类别通常是用于系统级和基础设施级别的工作负载，
它们由特权，受信的用户管理。&lt;/p&gt;
&lt;p&gt;特权策略的定义方式就是没有限制。 对于 默认允许执行机制(如守门人(&lt;code&gt;gatekeeper&lt;/code&gt;)), 特权方案是没有
执行的约束条件而不是一个实际的策略。相反的，在一个 默认拒绝的机制中(如 Pod 安全策略)，特权策略
就应该启用所有控制(关闭所有约束)。&lt;/p&gt;
&lt;!--
### Baseline/Default

The Baseline/Default policy is aimed at ease of adoption for common containerized workloads while
preventing known privilege escalations. This policy is targeted at application operators and
developers of non-critical applications. The following listed controls should be
enforced/disallowed:

&lt;table&gt;
	&lt;caption style=&#34;display:none&#34;&gt;Baseline policy specification&lt;/caption&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;Control&lt;/strong&gt;&lt;/td&gt;
			&lt;td&gt;&lt;strong&gt;Policy&lt;/strong&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Host Namespaces&lt;/td&gt;
			&lt;td&gt;
				Sharing the host namespaces must be disallowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.hostNetwork&lt;br&gt;
				spec.hostPID&lt;br&gt;
				spec.hostIPC&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; false&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Privileged Containers&lt;/td&gt;
			&lt;td&gt;
				Privileged Pods disable most security mechanisms and must be disallowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.privileged&lt;br&gt;
				spec.initContainers[*].securityContext.privileged&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; false, undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Capabilities&lt;/td&gt;
			&lt;td&gt;
				Adding additional capabilities beyond the &lt;a href=&#34;https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities&#34;&gt;default set&lt;/a&gt; must be disallowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.capabilities.add&lt;br&gt;
				spec.initContainers[*].securityContext.capabilities.add&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; empty (or restricted to a known list)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;HostPath Volumes&lt;/td&gt;
			&lt;td&gt;
				HostPath volumes must be forbidden.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.volumes[*].hostPath&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Host Ports&lt;/td&gt;
			&lt;td&gt;
				HostPorts should be disallowed, or at minimum restricted to a known list.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].ports[*].hostPort&lt;br&gt;
				spec.initContainers[*].ports[*].hostPort&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; 0, undefined (or restricted to a known list)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;AppArmor &lt;em&gt;(optional)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
				On supported hosts, the &#39;runtime/default&#39; AppArmor profile is applied by default. The default policy should prevent overriding or disabling the policy, or restrict overrides to an allowed set of profiles.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				metadata.annotations[&#39;container.apparmor.security.beta.kubernetes.io/*&#39;]&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; &#39;runtime/default&#39;, undefined&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;SELinux &lt;em&gt;(optional)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
				Setting custom SELinux options should be disallowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.seLinuxOptions&lt;br&gt;
				spec.containers[*].securityContext.seLinuxOptions&lt;br&gt;
				spec.initContainers[*].securityContext.seLinuxOptions&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;/proc Mount Type&lt;/td&gt;
			&lt;td&gt;
				The default /proc masks are set up to reduce attack surface, and should be required.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.procMount&lt;br&gt;
				spec.initContainers[*].securityContext.procMount&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; undefined/nil, &#39;Default&#39;&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Sysctls&lt;/td&gt;
			&lt;td&gt;
				Sysctls can disable security mechanisms or affect all containers on a host, and should be disallowed except for an allowed &#34;safe&#34; subset.
				A sysctl is considered safe if it is namespaced in the container or the Pod, and it is isolated from other Pods or processes on the same Node.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.sysctls&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt;&lt;br&gt;
				kernel.shm_rmid_forced&lt;br&gt;
				net.ipv4.ip_local_port_range&lt;br&gt;
				net.ipv4.tcp_syncookies&lt;br&gt;
				net.ipv4.ping_group_range&lt;br&gt;
				undefined/empty&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
 --&gt;
&lt;h3 id=&#34;baseline&#34;&gt;基线/默认&lt;/h3&gt;
&lt;p&gt;基线/默认策略的目的是在防止已知的特权升级情况下，让得普通的容器化工作负载来使用。 这个策略的目标
用户是应用运维人员和非关键应用的开发者。 下面列举这这些控制应该受限/不被允许:&lt;/p&gt;
&lt;table&gt;
	&lt;caption style=&#34;display:none&#34;&gt;基线策略规范&lt;/caption&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;控制&lt;/strong&gt;&lt;/td&gt;
			&lt;td&gt;&lt;strong&gt;策略&lt;/strong&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;宿主机命令空间&lt;/td&gt;
			&lt;td&gt;
				Sharing the host namespaces must be disallowed.&lt;br&gt;
        主机命名空间分离必须禁止。
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.hostNetwork&lt;br&gt;
				spec.hostPID&lt;br&gt;
				spec.hostIPC&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; false&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;特权容器&lt;/td&gt;
			&lt;td&gt;
        特权 Pod 禁用了多数安全机制，必须禁止。
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.privileged&lt;br&gt;
				spec.initContainers[*].securityContext.privileged&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; false, undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Capabilities&lt;/td&gt;
			&lt;td&gt;
        [默认集](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)
        外的额外能力是不允许的
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.capabilities.add&lt;br&gt;
				spec.initContainers[*].securityContext.capabilities.add&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; empty (or restricted to a known list)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;HostPath 卷&lt;/td&gt;
			&lt;td&gt;
				HostPath 卷必须禁止&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.volumes[*].hostPath&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;宿主机端口&lt;/td&gt;
			&lt;td&gt;
				宿主机端口应该禁用, 或最少限制在一个已知列表.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].ports[*].hostPort&lt;br&gt;
				spec.initContainers[*].ports[*].hostPort&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; 0, undefined (或限制在一个已知列表)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;AppArmor &lt;em&gt;(可选)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
        在受支持的主机上，默认执行 &#39;runtime/default&#39; AppArmor 方案。 默认策略应该防止被覆盖或
        禁用策略，或限制对允许方案集的覆盖.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				metadata.annotations[&#39;container.apparmor.security.beta.kubernetes.io/*&#39;]&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; &#39;runtime/default&#39;, undefined&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;SELinux &lt;em&gt;(可选)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
        不允许设置自定义SELinux选项.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.seLinuxOptions&lt;br&gt;
				spec.containers[*].securityContext.seLinuxOptions&lt;br&gt;
				spec.initContainers[*].securityContext.seLinuxOptions&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;/proc 挂载类别&lt;/td&gt;
			&lt;td&gt;
        默认的 /proc masks 被设置来减少攻击面， 是必要的.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.procMount&lt;br&gt;
				spec.initContainers[*].securityContext.procMount&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; undefined/nil, &#39;Default&#39;&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Sysctls&lt;/td&gt;
			&lt;td&gt;
        Sysctls 可以禁用安全机制或影响主机上的所有容器，在允许的安全子集外都应该被禁止。
        如果 sysctl 命名空间为容器内或 Pod 内被认为是安全的， 它会被与同一个节点上其它 Pod 或进程隔离.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.sysctls&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt;&lt;br&gt;
				kernel.shm_rmid_forced&lt;br&gt;
				net.ipv4.ip_local_port_range&lt;br&gt;
				net.ipv4.tcp_syncookies&lt;br&gt;
				net.ipv4.ping_group_range&lt;br&gt;
				undefined/empty&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
### Restricted

The Restricted policy is aimed at enforcing current Pod hardening best practices, at the expense of
some compatibility. It is targeted at operators and developers of security-critical applications, as
well as lower-trust users.The following listed controls should be enforced/disallowed:


&lt;table&gt;
	&lt;caption style=&#34;display:none&#34;&gt;Restricted policy specification&lt;/caption&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;Control&lt;/strong&gt;&lt;/td&gt;
			&lt;td&gt;&lt;strong&gt;Policy&lt;/strong&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan=&#34;2&#34;&gt;&lt;em&gt;Everything from the default profile.&lt;/em&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Volume Types&lt;/td&gt;
			&lt;td&gt;
				In addition to restricting HostPath volumes, the restricted profile limits usage of non-core volume types to those defined through PersistentVolumes.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.volumes[*].hostPath&lt;br&gt;
				spec.volumes[*].gcePersistentDisk&lt;br&gt;
				spec.volumes[*].awsElasticBlockStore&lt;br&gt;
				spec.volumes[*].gitRepo&lt;br&gt;
				spec.volumes[*].nfs&lt;br&gt;
				spec.volumes[*].iscsi&lt;br&gt;
				spec.volumes[*].glusterfs&lt;br&gt;
				spec.volumes[*].rbd&lt;br&gt;
				spec.volumes[*].flexVolume&lt;br&gt;
				spec.volumes[*].cinder&lt;br&gt;
				spec.volumes[*].cephFS&lt;br&gt;
				spec.volumes[*].flocker&lt;br&gt;
				spec.volumes[*].fc&lt;br&gt;
				spec.volumes[*].azureFile&lt;br&gt;
				spec.volumes[*].vsphereVolume&lt;br&gt;
				spec.volumes[*].quobyte&lt;br&gt;
				spec.volumes[*].azureDisk&lt;br&gt;
				spec.volumes[*].portworxVolume&lt;br&gt;
				spec.volumes[*].scaleIO&lt;br&gt;
				spec.volumes[*].storageos&lt;br&gt;
				spec.volumes[*].csi&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Privilege Escalation&lt;/td&gt;
			&lt;td&gt;
				Privilege escalation (such as via set-user-ID or set-group-ID file mode) should not be allowed.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.allowPrivilegeEscalation&lt;br&gt;
				spec.initContainers[*].securityContext.allowPrivilegeEscalation&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; false&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Running as Non-root&lt;/td&gt;
			&lt;td&gt;
				Containers must be required to run as non-root users.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.runAsNonRoot&lt;br&gt;
				spec.containers[*].securityContext.runAsNonRoot&lt;br&gt;
				spec.initContainers[*].securityContext.runAsNonRoot&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt; true&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Non-root groups &lt;em&gt;(optional)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
				Containers should be forbidden from running with a root primary or supplementary GID.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.runAsGroup&lt;br&gt;
				spec.securityContext.supplementalGroups[*]&lt;br&gt;
				spec.securityContext.fsGroup&lt;br&gt;
				spec.containers[*].securityContext.runAsGroup&lt;br&gt;
				spec.initContainers[*].securityContext.runAsGroup&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt;&lt;br&gt;
				non-zero&lt;br&gt;
				undefined / nil (except for `*.runAsGroup`)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Seccomp&lt;/td&gt;
			&lt;td&gt;
				The RuntimeDefault seccomp profile must be required, or allow specific additional profiles.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Restricted Fields:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.seccompProfile.type&lt;br&gt;
				spec.containers[*].securityContext.seccompProfile&lt;br&gt;
				spec.initContainers[*].securityContext.seccompProfile&lt;br&gt;
				&lt;br&gt;&lt;b&gt;Allowed Values:&lt;/b&gt;&lt;br&gt;
				&#39;runtime/default&#39;&lt;br&gt;
				undefined / nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
 --&gt;
&lt;h3 id=&#34;restricted&#34;&gt;受限的&lt;/h3&gt;
&lt;p&gt;受限策略旨在实施目前的 Pod 加固最佳实践，代价就是牺牲一些兼容性。目标用户为高安全性应用的运维和
开发人员，也可以是低信任度的用户。 下面列举的控制项应该受限/不被允许:&lt;/p&gt;
&lt;table&gt;
	&lt;caption style=&#34;display:none&#34;&gt;受限策略规范&lt;/caption&gt;
	&lt;tbody&gt;
		&lt;tr&gt;
			&lt;td&gt;&lt;strong&gt;Control&lt;/strong&gt;&lt;/td&gt;
			&lt;td&gt;&lt;strong&gt;Policy&lt;/strong&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td colspan=&#34;2&#34;&gt;&lt;em&gt;所有都来自默认方案&lt;/em&gt;&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;卷类型&lt;/td&gt;
			&lt;td&gt;
        为了进一步限制 HostPath 卷， 受限方案在定义 PV 时限制了这些非核心卷类型的使用.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.volumes[*].hostPath&lt;br&gt;
				spec.volumes[*].gcePersistentDisk&lt;br&gt;
				spec.volumes[*].awsElasticBlockStore&lt;br&gt;
				spec.volumes[*].gitRepo&lt;br&gt;
				spec.volumes[*].nfs&lt;br&gt;
				spec.volumes[*].iscsi&lt;br&gt;
				spec.volumes[*].glusterfs&lt;br&gt;
				spec.volumes[*].rbd&lt;br&gt;
				spec.volumes[*].flexVolume&lt;br&gt;
				spec.volumes[*].cinder&lt;br&gt;
				spec.volumes[*].cephFS&lt;br&gt;
				spec.volumes[*].flocker&lt;br&gt;
				spec.volumes[*].fc&lt;br&gt;
				spec.volumes[*].azureFile&lt;br&gt;
				spec.volumes[*].vsphereVolume&lt;br&gt;
				spec.volumes[*].quobyte&lt;br&gt;
				spec.volumes[*].azureDisk&lt;br&gt;
				spec.volumes[*].portworxVolume&lt;br&gt;
				spec.volumes[*].scaleIO&lt;br&gt;
				spec.volumes[*].storageos&lt;br&gt;
				spec.volumes[*].csi&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; undefined/nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;权限提升&lt;/td&gt;
			&lt;td&gt;
				权限提升 (如通过设置 set-user-ID 或 set-group-ID 文件模式) 应该被禁止.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.containers[*].securityContext.allowPrivilegeEscalation&lt;br&gt;
				spec.initContainers[*].securityContext.allowPrivilegeEscalation&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; false&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;以 非root用户运行&lt;/td&gt;
			&lt;td&gt;
				要求容器必须以非 root 用户运行 .&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.runAsNonRoot&lt;br&gt;
				spec.containers[*].securityContext.runAsNonRoot&lt;br&gt;
				spec.initContainers[*].securityContext.runAsNonRoot&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt; true&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;非root 组 &lt;em&gt;(可选)&lt;/em&gt;&lt;/td&gt;
			&lt;td&gt;
				容器应该避免以 root 主要或辅助的 GID 来运行 .&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.runAsGroup&lt;br&gt;
				spec.securityContext.supplementalGroups[*]&lt;br&gt;
				spec.securityContext.fsGroup&lt;br&gt;
				spec.containers[*].securityContext.runAsGroup&lt;br&gt;
				spec.initContainers[*].securityContext.runAsGroup&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt;&lt;br&gt;
				non-zero&lt;br&gt;
				undefined / nil (`*.runAsGroup` 除外)&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
		&lt;tr&gt;
			&lt;td&gt;Seccomp&lt;/td&gt;
			&lt;td&gt;
				必须要使用 RuntimeDefault 安全计算模式(seccomp) 方案，或允许指定额外方案.&lt;br&gt;
				&lt;br&gt;&lt;b&gt;受限字段:&lt;/b&gt;&lt;br&gt;
				spec.securityContext.seccompProfile.type&lt;br&gt;
				spec.containers[*].securityContext.seccompProfile&lt;br&gt;
				spec.initContainers[*].securityContext.seccompProfile&lt;br&gt;
				&lt;br&gt;&lt;b&gt;可用值:&lt;/b&gt;&lt;br&gt;
				&#39;runtime/default&#39;&lt;br&gt;
				undefined / nil&lt;br&gt;
			&lt;/td&gt;
		&lt;/tr&gt;
	&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
## Policy Instantiation

Decoupling policy definition from policy instantiation allows for a common understanding and
consistent language of policies across clusters, independent of the underlying enforcement
mechanism.

As mechanisms mature, they will be defined below on a per-policy basis. The methods of enforcement
of individual policies are not defined here.

[**PodSecurityPolicy**](/docs/concepts/policy/pod-security-policy/)

- [Privileged](https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/privileged-psp.yaml)
- [Baseline](https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/baseline-psp.yaml)
- [Restricted](https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml)
 --&gt;
&lt;h2 id=&#34;policy-instantiation&#34;&gt;策略安装&lt;/h2&gt;
&lt;p&gt;将策略定义从策略安装中解耦出来可以使用其成功一个共识和跨集群策略的统一语言，独立于底层的执行机制。&lt;/p&gt;
&lt;p&gt;作为成熟机制， 它们会定义在单个策略基础之下。 每个策略的执行方法不是在这里定义的。
&lt;blockquote&gt;
  &lt;div&gt;&lt;strong&gt;TODO: &lt;/strong&gt;说得不太清楚，需要实践理解后再考虑怎么修改&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/policy/pod-security-policy/&#34;&gt;&lt;strong&gt;PodSecurityPolicy&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/privileged-psp.yaml&#34;&gt;Privileged&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/baseline-psp.yaml&#34;&gt;Baseline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml&#34;&gt;Restricted&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--
## FAQ

### Why isn&#39;t there a profile between privileged and default?

The three profiles defined here have a clear linear progression from most secure (restricted) to least
secure (privileged), and cover a broad set of workloads. Privileges required above the baseline
policy are typically very application specific, so we do not offer a standard profile in this
niche. This is not to say that the privileged profile should always be used in this case, but that
policies in this space need to be defined on a case-by-case basis.

SIG Auth may reconsider this position in the future, should a clear need for other profiles arise.
 --&gt;
&lt;h2 id=&#34;faq&#34;&gt;FAQ&lt;/h2&gt;
&lt;h3 id=&#34;why-isnt-there-a-profile-between-privileged-and-default&#34;&gt;为啥在 特权(privileged)和基线(default) 之间没有一个中间方案 &lt;/h3&gt;
&lt;p&gt;这里定义的三个方案有一个明显的线性变化， 从最安全(受限)到最不安全(特权)，覆盖了广泛的工作负载集。
在基线策略之上的权限需求通常是特别具体到应用的， 所以在这个层面我会不需要提供一个标准的方案。
这也不是说特权方案就会始终用于这个应用场景，但是在这个地方用到的策略就需要单个场景级别地来定义。&lt;/p&gt;
&lt;p&gt;如果有明确的其它方案的需求提出来，未来 SIG Auth 可以重新考虑加到这里。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;div&gt;&lt;strong&gt;TODO: &lt;/strong&gt;说得不太清楚，需要实践理解后再考虑怎么修改&lt;/div&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;whats-the-difference-between-a-security-policy-and-a-security-context&#34;&gt;安全策略与安全上下文之间的区别&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/configure-pod-container/security-context/&#34;&gt;安全上下文&lt;/a&gt; 是在
Pod 和 容器的运行时上配置。 安全上下文是在Pod 配置中作为 Pod 和容器定义的一部分存在的，代表
传递给容器运行时的参数。&lt;/p&gt;
&lt;p&gt;安全策略是在安全上下文中执行指定设置的控制面板机制，连同安全上下文之外的其它参数。 从 2020 年 2 月
形如，当前原生执行这些安全策略的方案就是
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/policy/pod-security-policy/&#34;&gt;Pod 安全策略&lt;/a&gt; - 一个在集群中
以中心化方式在 Pod 上执行安全策略的机制。 其它执行安全策略的方式也已经在 k8s 生态中开发了，就
如
&lt;a href=&#34;https://github.com/open-policy-agent/gatekeeper&#34;&gt;OPA Gatekeeper&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;what-profiles-should-i-apply-to-my-windows-pods&#34;&gt;Windows Pod 应该执行哪个方案&lt;/h3&gt;
&lt;p&gt;windows 在 k8s 中是有些限制且与基于 Linux 的标准工作负载有明显差异的。 特别是  Pod 的 SecurityContext
字段在
&lt;a href=&#34;https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#v1-podsecuritycontext&#34;&gt;Windows Pod 上是没有效果的&lt;/a&gt;. 因此，目前是没有标准的 Pod 安全方案存在的。&lt;/p&gt;
&lt;h3 id=&#34;what-about-sandboxed-pods&#34;&gt;沙盒 Pod 是个啥情况&lt;/h3&gt;
&lt;p&gt;目前没有一个标准的 API 可以控制一个 Pod 是否被认为是沙盒。沙盒 Pod 可能可以通过使用一个沙盒
运行时(如 gVisor 或 Kata容器)来识别， 但没有对沙盒运行时有一个标准的定义。&lt;/p&gt;
&lt;p&gt;对沙盒工作负载的保护需求可能与其它的不同。 例如，在工作负载从底层内核隔离后对特殊权限的限制需求就减少了。
这使得工作负载在隔离的情况下提升指定的权限。&lt;/p&gt;
&lt;p&gt;另外，对沙盒工作负载的保护调度信赖沙盒的实现方式。 例如，没有一个推荐策略可以推荐给所有的沙盒工作负载。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: 对 k8s API 的访问控制</title>
      <link>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/controlling-access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lostsquirrel.github.io/k8sDocs/docs/concepts/security/controlling-access/</guid>
      <description>
        
        
        &lt;!--
---
reviewers:
- erictune
- lavalamp
title: Controlling Access to the Kubernetes API
content_type: concept
---
 --&gt;
&lt;!-- overview --&gt;
&lt;!--
This page provides an overview of controlling access to the Kubernetes API.
 --&gt;
&lt;p&gt;本文概述对 k8s API 的访问控制&lt;/p&gt;
&lt;!-- body --&gt;
&lt;!--
Users access the [Kubernetes API](/docs/concepts/overview/kubernetes-api/) using `kubectl`,
client libraries, or by making REST requests.  Both human users and
[Kubernetes service accounts](/docs/tasks/configure-pod-container/configure-service-account/) can be
authorized for API access.
When a request reaches the API, it goes through several stages, illustrated in the
following diagram:
 --&gt;
&lt;p&gt;用户可以使用 &lt;code&gt;kubectl&lt;/code&gt;, 客户端库，或发送 REST 请求来访问
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/overview/kubernetes-api/&#34;&gt;Kubernetes API&lt;/a&gt;. 用户和
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/configure-pod-container/configure-service-account/&#34;&gt;k8s 服务账号&lt;/a&gt;
都可以授权访问 API。 当一个请求到达 API 时，会经过几个阶段，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/images/docs/admin/access-control-overview.svg&#34; alt=&#34;k8s API 请求的处理步骤图&#34;&gt;&lt;/p&gt;
&lt;!--
## Transport security

In a typical Kubernetes cluster, the API serves on port 443, protected by TLS.
The API server presents a certificate. This certificate may be signed using
a private certificate authority (CA), or based on a public key infrastructure linked
to a generally recognized CA.

If your cluster uses a private certificate authority, you need a copy of that CA
certifcate configured into your `~/.kube/config` on the client, so that you can
trust the connection and be confident it was not intercepted.

Your client can present a TLS client certificate at this stage.
 --&gt;
&lt;h2 id=&#34;transport-security&#34;&gt;传输安全&lt;/h2&gt;
&lt;p&gt;在一个典型的 k8s 集群中，API 使用 443 端口提供服务，由 TLS 保护。 API 服务提供一个证书。这个
证书可能使用一个私人证书颁发机构(CA), 或基于一个与公认 CA 连接的公钥签发的。&lt;/p&gt;
&lt;p&gt;如果集群使用了一个 私人证书颁发机构， 需要将 CA 证书拷贝到客户机的  &lt;code&gt;~/.kube/config&lt;/code&gt; 中，这样
才能信任这个连接并相邻这个连接不会被拦截。&lt;/p&gt;
&lt;p&gt;在这一步，客户端也可以提供一个 TLS 客户端证书。&lt;/p&gt;
&lt;!--
## Authentication

Once TLS is established, the HTTP request moves to the Authentication step.
This is shown as step **1** in the diagram.
The cluster creation script or cluster admin configures the API server to run
one or more Authenticator modules.
Authenticators are described in more detail in
[Authentication](/docs/reference/access-authn-authz/authentication/).

The input to the authentication step is the entire HTTP request; however, it typically
just examines the headers and/or client certificate.

Authentication modules include client certificates, password, and plain tokens,
bootstrap tokens, and JSON Web Tokens (used for service accounts).

Multiple authentication modules can be specified, in which case each one is tried in sequence,
until one of them succeeds.

If the request cannot be authenticated, it is rejected with HTTP status code 401.
Otherwise, the user is authenticated as a specific `username`, and the user name
is available to subsequent steps to use in their decisions.  Some authenticators
also provide the group memberships of the user, while other authenticators
do not.

While Kubernetes uses usernames for access control decisions and in request logging,
it does not have a `User` object nor does it store usernames or other information about
users in its API.
 --&gt;
&lt;h2 id=&#34;authentication&#34;&gt;认证&lt;/h2&gt;
&lt;p&gt;当 TLS 建立后， HTTP 请求就进行到认证这一步。也就是前面图片中的步骤 &lt;strong&gt;1&lt;/strong&gt; 。
集群创建脚本或集群管理会让 API 服务运行一个或多个认证器模块。更多关于认证器的信息见
&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authentication/&#34;&gt;Authentication&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;认证步骤的输入就整个 HTTP 请求； 但是，它通常只会检查头和/或 客户端证书。&lt;/p&gt;
&lt;p&gt;认证模块包括和客户端证书，密码，和普通令牌， 引导令牌，JSON Web令牌(用于服务账号)。&lt;/p&gt;
&lt;p&gt;可以指定多个认证模块，在这种情况下他们会按顺序逐个尝试直到有一个成功(也可能会者失败)&lt;/p&gt;
&lt;p&gt;如果请求认证失败，则会使用 &lt;code&gt;401&lt;/code&gt; HTTP 状态码以示拒绝。 否则用户以指定 &lt;code&gt;username&lt;/code&gt; 来认证，这个
用户名就会被用到接下来的步骤中的决策中。 有些认证器也会提供用户的组信息，有些认证器则不会。&lt;/p&gt;
&lt;p&gt;当 k8s 在使用用户名作为访问控制决策和在请求日志中，是不会有一个 &lt;code&gt;User&lt;/code&gt; 对象，也不会在 API 存储用户名
或其它关于用户的信息的。&lt;/p&gt;
&lt;!--
## Authorization

After the request is authenticated as coming from a specific user, the request must be authorized. This is shown as step **2** in the diagram.

A request must include the username of the requester, the requested action, and the object affected by the action. The request is authorized if an existing policy declares that the user has permissions to complete the requested action.

For example, if Bob has the policy below, then he can read pods only in the namespace `projectCaribou`:

```json
{
    &#34;apiVersion&#34;: &#34;abac.authorization.kubernetes.io/v1beta1&#34;,
    &#34;kind&#34;: &#34;Policy&#34;,
    &#34;spec&#34;: {
        &#34;user&#34;: &#34;bob&#34;,
        &#34;namespace&#34;: &#34;projectCaribou&#34;,
        &#34;resource&#34;: &#34;pods&#34;,
        &#34;readonly&#34;: true
    }
}
```
If Bob makes the following request, the request is authorized because he is allowed to read objects in the `projectCaribou` namespace:

```json
{
  &#34;apiVersion&#34;: &#34;authorization.k8s.io/v1beta1&#34;,
  &#34;kind&#34;: &#34;SubjectAccessReview&#34;,
  &#34;spec&#34;: {
    &#34;resourceAttributes&#34;: {
      &#34;namespace&#34;: &#34;projectCaribou&#34;,
      &#34;verb&#34;: &#34;get&#34;,
      &#34;group&#34;: &#34;unicorn.example.org&#34;,
      &#34;resource&#34;: &#34;pods&#34;
    }
  }
}
```
If Bob makes a request to write (`create` or `update`) to the objects in the `projectCaribou` namespace, his authorization is denied. If Bob makes a request to read (`get`) objects in a different namespace such as `projectFish`, then his authorization is denied.

Kubernetes authorization requires that you use common REST attributes to interact with existing organization-wide or cloud-provider-wide access control systems. It is important to use REST formatting because these control systems might interact with other APIs besides the Kubernetes API.

Kubernetes supports multiple authorization modules, such as ABAC mode, RBAC Mode, and Webhook mode. When an administrator creates a cluster, they configure the authorization modules that should be used in the API server. If more than one authorization modules are configured, Kubernetes checks each module, and if any module authorizes the request, then the request can proceed. If all of the modules deny the request, then the request is denied (HTTP status code 403).

To learn more about Kubernetes authorization, including details about creating policies using the supported authorization modules, see [Authorization](/docs/reference/access-authn-authz/authorization/).
 --&gt;
&lt;h2 id=&#34;authorization&#34;&gt;授权&lt;/h2&gt;
&lt;p&gt;当来自指定用户的请求认证后，这个请求必须要被授权。 这就是图片中的步骤 &lt;strong&gt;2&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;请求必须包含请求者的用户名，请求行为，和受行为影响的对象。 如果有存在的策略定义这个用户有完成这个
请求行为的权限就表示请求被授权了。&lt;/p&gt;
&lt;p&gt;例如， 如果 Bob 拥有以下策略，则他只能读取命名空间 &lt;code&gt;projectCaribou&lt;/code&gt; 中的 Pod :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;abac.authorization.kubernetes.io/v1beta1&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;kind&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Policy&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;spec&amp;#34;&lt;/span&gt;: {
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bob&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;projectCaribou&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;resource&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;,
        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;readonly&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 Bob 发起以下请求，这个请求会被授权，因为他被允许读取 命名空间 &lt;code&gt;projectCaribou&lt;/code&gt; 中的 Pod :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;apiVersion&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;authorization.k8s.io/v1beta1&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;kind&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SubjectAccessReview&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;spec&amp;#34;&lt;/span&gt;: {
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;resourceAttributes&amp;#34;&lt;/span&gt;: {
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;namespace&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;projectCaribou&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;verb&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;group&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unicorn.example.org&amp;#34;&lt;/span&gt;,
      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;resource&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 Bob 发起一个写请求(&lt;code&gt;create&lt;/code&gt; 或 &lt;code&gt;update&lt;/code&gt;)到命名空间 &lt;code&gt;projectCaribou&lt;/code&gt; 中的对象，他的
授权就会被拒绝的。 如果 Bob 发起一个读请求(&lt;code&gt;get&lt;/code&gt;)到另个名称空间如 &lt;code&gt;projectFish&lt;/code&gt; 中的对象，
这时他的授权也会被拒绝。&lt;/p&gt;
&lt;p&gt;k8s 授权要求用户使用通用 REST 属性与存在的组织内或云提供商内的访问控制系统交互。使用 REST 格式
很重要是因为这些控制系统可能与 k8s API 外的其它 API 进行交互。&lt;/p&gt;
&lt;p&gt;k8s 支持多种授权模块，如 ABAC 模式，RBAC 模式，和 Webhook 模式。 当管理员在创建集群时，他们
每配置 API 服务中使用的授权模块。 如果配置了多个授权模块， k8s 会检查每个模块， 如果有任意一个
模块对这个模块授权，则这个请求就能继续。 如果所有的请求都被拒绝，则这个请求就会被拒绝(HTTP 状态码 403)。&lt;/p&gt;
&lt;p&gt;要学习更多 k8s 授权， 包含使用支持的授权模块创建策略， 见
&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authorization/&#34;&gt;Authorization&lt;/a&gt;.&lt;/p&gt;
&lt;!--
## Admission control

Admission Control modules are software modules that can modify or reject requests.
In addition to the attributes available to Authorization modules, Admission
Control modules can access the contents of the object that is being created or modified.

Admission controllers act on requests that create, modify, delete, or connect to (proxy) an object.
Admission controllers do not act on requests that merely read objects.
When multiple admission controllers are configured, they are called in order.

This is shown as step **3** in the diagram.

Unlike Authentication and Authorization modules, if any admission controller module
rejects, then the request is immediately rejected.

In addition to rejecting objects, admission controllers can also set complex defaults for
fields.

The available Admission Control modules are described in [Admission Controllers](/docs/reference/access-authn-authz/admission-controllers/).

Once a request passes all admission controllers, it is validated using the validation routines
for the corresponding API object, and then written to the object store (shown as step **4**).
 --&gt;
&lt;h2 id=&#34;admission-control&#34;&gt;准入控制&lt;/h2&gt;
&lt;p&gt;准入控制模块是软件模块，它可以修改或拒绝请求。 相对于授权模块能够访问的属性， 准入控制模块可以
访问请求创建或修改的对象的内容。&lt;/p&gt;
&lt;p&gt;准入控制器对对创建，修改，删除或连接(代理)的对象执行操作。 准入控制器不会对只读对象的请求执行操作。
当配置了多个准入控制器时，他们会以顺序调用。&lt;/p&gt;
&lt;p&gt;这就是图片中的步骤 &lt;strong&gt;3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与认证与授权模块不同，如果有任意准入控制器模块拒绝，则这个请求立马就会被拒绝。&lt;/p&gt;
&lt;p&gt;在拒绝对象个，准入控制器也可以设置复杂的默认字段。&lt;/p&gt;
&lt;p&gt;可以使用的准入控制模块描述见
&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&#34;&gt;准入控制器&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;当请求通过了所有准入控制器，会对对应的 API 对象使用验证程序来对其验证，然后将这个对象写入存储(如步骤 &lt;strong&gt;4&lt;/strong&gt; 所示).&lt;/p&gt;
&lt;blockquote&gt;
  &lt;div&gt;&lt;strong&gt;TODO: &lt;/strong&gt;说得不太清楚，需要实践理解后再考虑怎么修改&lt;/div&gt;
&lt;/blockquote&gt;

&lt;!--
## API server ports and IPs

The previous discussion applies to requests sent to the secure port of the API server
(the typical case).  The API server can actually serve on 2 ports:

By default the Kubernetes API server serves HTTP on 2 ports:

  1. `localhost` port:

      - is intended for testing and bootstrap, and for other components of the master node
        (scheduler, controller-manager) to talk to the API
      - no TLS
      - default is port 8080, change with `--insecure-port` flag.
      - default IP is localhost, change with `--insecure-bind-address` flag.
      - request **bypasses** authentication and authorization modules.
      - request handled by admission control module(s).
      - protected by need to have host access

  2. “Secure port”:

      - use whenever possible
      - uses TLS.  Set cert with `--tls-cert-file` and key with `--tls-private-key-file` flag.
      - default is port 6443, change with `--secure-port` flag.
      - default IP is first non-localhost network interface, change with `--bind-address` flag.
      - request handled by authentication and authorization modules.
      - request handled by admission control module(s).
      - authentication and authorization modules run.
 --&gt;
&lt;h2 id=&#34;api-server-ports-and-ips&#34;&gt;API 服务的端口与 IP&lt;/h2&gt;
&lt;p&gt;The previous discussion applies to requests sent to the secure port of the API server
(the typical case).  The API server can actually serve on 2 ports:
上面讨论中执行的请求是发送到 API 服务的安全端口的(典型场景). API 服务实际上是可以使用 2 个端口提供服务:&lt;/p&gt;
&lt;p&gt;By default the Kubernetes API server serves HTTP on 2 ports:
默认情况下 k8s API 服务使用 2 个端口提供 HTTP 服务:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;localhost&lt;/code&gt; 端口:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;主要用于测试和引导，也可以用于主节点上的其它模块(scheduler, controller-manager) 与 API 通信&lt;/li&gt;
&lt;li&gt;没有 TLS&lt;/li&gt;
&lt;li&gt;默认端口是 8080，使用 &lt;code&gt;--insecure-port&lt;/code&gt; 标志修改&lt;/li&gt;
&lt;li&gt;默认 IP 是 &lt;code&gt;localhost&lt;/code&gt;， 使用 &lt;code&gt;--insecure-bind-address&lt;/code&gt; 标志修改&lt;/li&gt;
&lt;li&gt;请求 &lt;strong&gt;绕过&lt;/strong&gt; 认证和授权模块。&lt;/li&gt;
&lt;li&gt;请求会被准入控制模块处理&lt;/li&gt;
&lt;li&gt;保护方式是需要主机访问&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&amp;ldquo;安全端口&amp;rdquo;:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;尽量无论何时都使用&lt;/li&gt;
&lt;li&gt;使用 TLS 使用 &lt;code&gt;--tls-cert-file&lt;/code&gt; 使用证书，使用 &lt;code&gt;--tls-private-key-file&lt;/code&gt; 使用密钥&lt;/li&gt;
&lt;li&gt;默认端口是 6443， 使用 &lt;code&gt;--secure-port&lt;/code&gt; 标志修改&lt;/li&gt;
&lt;li&gt;默认 IP 首先是一个非 localhost 网络接口， 使用 &lt;code&gt;--bind-address&lt;/code&gt; 标志修改&lt;/li&gt;
&lt;li&gt;请求会被认证和授权模块处理&lt;/li&gt;
&lt;li&gt;请求会被准入控制模块处理&lt;/li&gt;
&lt;li&gt;认证和授权模块会运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;相关资料&#34;&gt;相关资料&lt;/h2&gt;
&lt;!--

Read more documentation on authentication, authorization and API access control:

- [Authenticating](/docs/reference/access-authn-authz/authentication/)
   - [Authenticating with Bootstrap Tokens](/docs/reference/access-authn-authz/bootstrap-tokens/)
- [Admission Controllers](/docs/reference/access-authn-authz/admission-controllers/)
   - [Dynamic Admission Control](/docs/reference/access-authn-authz/extensible-admission-controllers/)
- [Authorization](/docs/reference/access-authn-authz/authorization/)
   - [Role Based Access Control](/docs/reference/access-authn-authz/rbac/)
   - [Attribute Based Access Control](/docs/reference/access-authn-authz/abac/)
   - [Node Authorization](/docs/reference/access-authn-authz/node/)
   - [Webhook Authorization](/docs/reference/access-authn-authz/webhook/)
- [Certificate Signing Requests](/docs/reference/access-authn-authz/certificate-signing-requests/)
   - including [CSR approval](/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection)
     and [certificate signing](/docs/reference/access-authn-authz/certificate-signing-requests/#signing)
- Service accounts
  - [Developer guide](/docs/tasks/configure-pod-container/configure-service-account/)
  - [Administration](/docs/reference/access-authn-authz/service-accounts-admin/)

You can learn about:
- how Pods can use
  [Secrets](/docs/concepts/configuration/secret/#service-accounts-automatically-create-and-attach-secrets-with-api-credentials)
  to obtain API credentials.
 --&gt;
&lt;p&gt;更多关于 认证，授权， API 准入控制的文档:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authentication/&#34;&gt;Authenticating&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/&#34;&gt;Authenticating with Bootstrap Tokens&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/&#34;&gt;Admission Controllers&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/&#34;&gt;Dynamic Admission Control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/authorization/&#34;&gt;Authorization&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/rbac/&#34;&gt;Role Based Access Control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/abac/&#34;&gt;Attribute Based Access Control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/node/&#34;&gt;Node Authorization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/webhook/&#34;&gt;Webhook Authorization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/&#34;&gt;Certificate Signing Requests&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;including &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection&#34;&gt;CSR approval&lt;/a&gt;
and &lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#signing&#34;&gt;certificate signing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务账号
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/tasks/configure-pod-container/configure-service-account/&#34;&gt;开发者引导&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/&#34;&gt;Administration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还可以学习:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pod 怎么使用
&lt;a href=&#34;https://lostsquirrel.github.io/k8sDocs/k8sDocs/docs/concepts/configuration/secret/#service-accounts-automatically-create-and-attach-secrets-with-api-credentials&#34;&gt;Secret&lt;/a&gt;
获取 API 凭据&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
